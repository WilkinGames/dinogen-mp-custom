/**
 * Dinogen Online - Game Logic
 * ©2023 Wilkin Games
 * https://wilkingames.com - https://dinogenonline.com
 */
const GameServer = {
    EVENT_ERROR: 0,
    EVENT_BATCH: 1,
    EVENT_GAME_INIT: 2,
    EVENT_GAME_TIMER: 3,
    EVENT_GAME_PRE_TIMER: 4,
    EVENT_GAME_START: 5,
    EVENT_GAME_END: 6,
    EVENT_GAME_UPDATE: 7,
    EVENT_PLAYER_JOIN: 8,
    EVENT_PLAYER_LEAVE: 9,
    EVENT_PLAYER_UPDATE: 10,
    EVENT_SPAWN_CHARACTER: 11,
    EVENT_OBJECT_UPDATE: 12,
    EVENT_PLAYER_INPUT: 13,
    EVENT_PLAYER_TRIGGER_WEAPON: 14,
    EVENT_PAWN_DAMAGE: 19,
    EVENT_PAWN_DIE: 20,
    EVENT_PAWN_ACTION: 21,
    EVENT_PLAYER_MULTI_KILL: 35,
    EVENT_PLAYER_INTERACT: 38,
    EVENT_PLAYER_UPDATE_INVENTORY: 39,
    EVENT_PLAYER_TRIGGER_EQUIPMENT: 41,
    EVENT_PLAYER_TRIGGER_GRENADE: 43,
    EVENT_KILLFEED_ADD: 45,
    EVENT_MESSAGE_ADD: 46,
    EVENT_SPAWN_OBJECT: 47,
    EVENT_SPAWN_BULLET: 48,
    EVENT_SPAWN_EXPLOSION: 49,
    EVENT_GAME_PAUSE: 50,
    EVENT_INTERACTABLE_USED: 60,
    EVENT_REMOVE_OBJECT: 61,
    EVENT_BUY: 62,
    EVENT_USE_ITEM: 63,
    EVENT_ROUND: 64,
    PAWN_FIRE_WEAPON: 1,
    PAWN_HIT_SHIELD: 2,
    PAWN_START_REVIVE: 3,
    PAWN_END_REVIVE: 4,
    PAWN_SHARED_CRATE: 5,
    PAWN_STOLE_CRATE: 6,
    PAWN_START_INTERACTION: 7,
    PAWN_NO_AMMO: 8,
    PAWN_OPEN_LAPTOP: 9,
    PAWN_ON_FIRE: 10,
    PAWN_STUN: 11,
    PAWN_FLASH: 12,
    PAWN_FREEZE: 13,
    PAWN_SET_JAMMED: 14,
    PAWN_UPDATE_DOOR: 15,
    PAWN_INVESTIGATE: 16,
    PAWN_TROPHY_HIT: 17,
    PAWN_START_SHIELD_COOLDOWN: 18,
    PAWN_END_SHIELD_COOLDOWN: 19,
    PAWN_END_FIRE_DELAY: 20,
    PAWN_END_BOLT_DELAY: 21,
    PAWN_END_THROW_DELAY: 22,
    PAWN_END_EQUIPMENT_DELAY: 23,
    PAWN_END_MELEE_DELAY: 24,
    PAWN_RELOAD_COMPLETE: 25,
    PAWN_CLOSE_LAPTOP: 26,
    PAWN_START_FLAME: 27,
    PAWN_END_FLAME: 28,
    PAWN_RELOAD: 29,
    PAWN_PULL_BOLT: 30,
    PAWN_CANCEL_RELOAD: 31,
    PAWN_CANCEL_BOLT_PULL: 32,
    PAWN_THROW_GRENADE: 33,
    PAWN_USE_STIM: 34,
    PAWN_RECEIVE_STIM: 35,
    PAWN_PLACE_EQUIPMENT: 36,
    PAWN_MELEE_ATTACK: 37,
    PAWN_FIRE_MELEE: 38,
    PAWN_FIRE_ROCKET: 39,
    PAWN_TRIGGER_MINE: 40,
    PAWN_END_INTERACTION: 41,
    PAWN_JUMP: 42,
    PAWN_ON_BOOST: 43,
    PAWN_START_LADDER_CLIMB: 44,
    PAWN_LEAVE_LADDER: 45,
    PAWN_DROP_CRATE: 46,
    PAWN_FLAG: 47,
    PAWN_HIT: 48,
    PAWN_VEHICLE_ENTER: 49,
    PAWN_VEHICLE_LEAVE: 50,
    PAWN_UPDATE: 51,
    PAWN_PARACHUTE: 52,
    PAWN_VEHICLE_HORN: 54,
    PAWN_VEHICLE_UPDATE: 54,
    PAWN_SWITCH_SEATS: 55,
    PAWN_REQUEST: 56,
    PAWN_WEAPON_COOLDOWN: 57,
    PAWN_LOCK_ACQUIRED: 58,
    PAWN_INTERACTABLE_USED: 59,
    PAWN_MOVE: 60,
    PAWN_VOX: 61,
    INV_CLASS_DATA: 1,
    INV_CURRENT_INVENTORY_INDEX: 2,
    INV_FIRE: 3,
    INV_PERK_ADD: 4,
    INV_PERKS: 5,
    INV_PERKS_SET: 6,
    INV_MOD_SET: 7,
    INV_EQUIPMENT_SET: 8,
    INV_EQUIPMENT_ADD: 9,
    INV_AMMO: 10,
    INV_AMMO_ADD: 11,
    INV_MAG: 12,
    INV_MAG_ADD: 13,
    INV_BURSTS: 14,
    INV_BURSTS_ADD: 15,
    INV_ITEM: 16,
    INV_ITEM_ADD: 17,
    INV_ITEM_REPLACE: 18,
    INV_INVENTORY_REPLACE: 19,
    INV_INVENTORY: 21,
    INV_EQUIPMENT: 22,
    INV_UNDERBARREL_EQUIP: 23
};
const CollisionGroups = {
    PAWN: Math.pow(2, 0),
    HELICOPTER: Math.pow(2, 1),
    OBJECT: Math.pow(2, 2),
    GROUND: Math.pow(2, 3),
    PROJECTILE: Math.pow(2, 4),
    BOUNDS: Math.pow(2, 5),
    SHIELD: Math.pow(2, 6),
    FLAME: Math.pow(2, 7)
};
const ObjectType = {
    GROUND: "ground",
    CHARACTER: "character",
    DINOSAUR: "dinosaur",
    FLYING_DINOSAUR: "flyingDinosaur",
    DUMMY: "dummy",
    ROCKET: "rocket",
    GRENADE: "grenade",
    EQUIPMENT: "equipment",
    CAR: "car",
    TANK: "tank",
    HELICOPTER: "helicopter",
    MOUNTED_WEAPON: "mountedWeapon",
    WINDOW: "window",
    LEVER: "lever",
    DROPPED_WEAPON: "droppedWeapon",
    FLAG: "flag",
    CRATE: "crate",
    FLAME: "flame",
    OBSTACLE: "obstacle",
    DOOR: "door",
    REVIVER: "reviver",
    SHIELD: "shield",
    MONEY: "money",
    ARROW: "arrow",
    EGG: "egg",
    TREE: "tree",
    TRIGGER_AREA: "triggerArea",
    SPAWNER: "spawner",
    PROJECTILE: "projectile",
    TEXT: "text",
    ICON: "icon",
    EMITTER: "emitter",
    SPAWN_POINT: "spawnPoint"
};
const Material = {
    DEFAULT: "default",
    METAL: "metal",
    WOOD: "wood",
    WATER: "water",
    FLESH: "flesh",
    VENOM: "venom",
    SANDBAG: "sandbag",
    GLASS: "glass"
};
const Colours = {
    WHITE: 0xFFFFFF,
    WHITE_STRING: "#FFFFFF",
    BLACK: 0x000000,
    BLACK_STRING: "#000000",
    XP: 0xFFE633,
    XP_STRING: "#FFE633",
    GREEN: 0x5FFF7F,
    GREEN_STRING: "#5FFF7F",
    RED: 0xFF5F5F,
    RED_STRING: "#FF5F5F",
    PLAYER: 0x5FFF7F,
    PLAYER_STRING: "#5FFF7F",
    ENEMY: 0xFF5F5F,
    ENEMY_STRING: "#FF5F5F",
    ALLY: 0x45B3E4,
    ALLY_STRING: "#45B3E4",
    THEME: 0xD85540,
    THEME_STRING: "#D85540",
    ORANGE: 0xFFAE33,
    ORANGE_STRING: "#FFAE33"
};
const DamageType = {
    DAMAGE_BULLET: 1,
    DAMAGE_MELEE: 2,
    DAMAGE_EXPLOSIVE: 3,
    DAMAGE_FIRE: 4,
    DAMAGE_WORLD: 5
};
const BotSkill = {
    SKILL_EASY: 0,
    SKILL_NORMAL: 1,
    SKILL_HARD: 2,
    SKILL_INSANE: 3,
    SKILL_GOD: 4,
    SKILL_IMPOSSIBLE: 5
};
const FeedItem = {
    TYPE_MESSAGE: "message",
    TYPE_KILL: "kill",
    TYPE_CHAT: "chat"
};
const Control = {
    LOOK: "look",
    INTERACT: "interact",
    RELOAD: "reload",
    SWITCH: "switch",
    INV_NEXT: "inv_next",
    INV_PREV: "inv_prev",
    GRENADE: "grenade",
    EQUIPMENT: "equipment",
    WEAPON: "weapon",
    LEFT: "left",
    RIGHT: "right",
    UP: "up",
    DOWN: "down",
    JUMP: "jump",
    CROUCH: "crouch",
    SPRINT: "sprint",
    MELEE: "melee",
    ITEM: "item",
    FIRE: "fire",
    ITEM_1: "item_1",
    ITEM_2: "item_2",
    ITEM_3: "item_3",
};
const Rocket = {
    DEFAULT: "TYPE_DEFAULT",
    HELLFIRE: "TYPE_HELLFIRE",
    NAPALM: "TYPE_NAPALM"
};
const Item = {
    AMMO_AIRDROP: "item_ammo",
    WEAPON_AIRDROP: "item_weapon",
    HEAVY_AIRDROP: "item_weapon_heavy",
    SENTRY: "item_sentry",
    SENTRY_SHOTGUN: "item_sentry_shotgun",
    SENTRY_SAM: "item_sentry_rocket",
    SENTRY_FLAME: "item_sentry_flame",
    SENTRY_GRENADE: "item_sentry_grenade",
    SENTRY_SNIPER: "item_sentry_sniper",
    SENTRY_RAILGUN: "item_sentry_railgun",
    M2: "item_m2",
    BGM71: "item_bgm71",
    M242: "item_m242",
    ESCORT_AIRDROP: "item_osprey",
    SUPPORT_AIRDROP: "item_mh6",
    QUAD: "item_quad",
    GROWLER: "item_growler",
    MRAP: "item_mrap",
    LAV25: "item_lav25",
    ABRAMS: "item_abrams",
    T90: "item_t90",
    COBRA: "item_cobra",
    BLACKHAWK: "item_blackhawk",
    APACHE: "item_apache",
    KIOWA: "item_kiowa",
    EGG_COMPY: "item_egg_compy",
    EGG_DILO: "item_egg_dilo",
    EGG_RAPTOR: "item_egg_raptor",
    EGG_NEEDLER: "item_egg_needler",
    EGG_ALLOSAURUS: "item_egg_allosaurus",
    EGG_SPINOSAURUS: "item_egg_spinosaurus",
    AIRSTRIKE: "item_airstrike",
    AIRSTRIKE_NAPALM: "item_airstrike_napalm",
    DEADSWITCH: "item_deadswitch"
};
const Helicopter = {
    MH6: "mh6",
    COBRA: "cobra",
    APACHE: "apache",
    SEAKNIGHT: "seaknight",
    KIOWA: "kiowa",
    BLACKHAWK: "blackhawk",
    OSPREY: "osprey",
    CHICKENCOPTER: "chickencopter"
};
const Tank = {
    ABRAMS: "abrams",
    T90: "t90"
};
const Car = {
    QUAD: "quad",
    GROWLER: "growler",
    PICKUP: "pickup",
    MRAP: "mrap",
    LAV25: "lav25"
};
const MountedWeapon = {
    SENTRY: "sentry",
    SENTRY_SHOTGUN: "sentry_shotgun",
    SENTRY_SNIPER: "sentry_sniper",
    SENTRY_GRENADE: "sentry_grenade",
    SENTRY_SAM: "sentry_rocket",
    SENTRY_FLAME: "sentry_flame",
    SENTRY_RAILGUN: "sentry_railgun",
    M2: "m2",
    BGM71: "bgm71",
    M242: "m242"
};
const Commands = {
    REQUEST_AMMO: 1,
    REQUEST_VEHICLE: 2,
    REQUEST_SUPPORT: 3,
    REQUEST_FOLLOW: 4,
    REQUEST_COVER: 5,
    REQUEST_REPAIR: 6,
    HOLD: 7,
    TAUNT: 8
};
const Crate = {
    STORE: "CRATE_STORE",
    AMMO: "CRATE_AMMO",
    DECOY: "CRATE_DECOY",
    KILLSTREAK: "CRATE_KILLSTREAK",
    ITEM: "CRATE_ITEM",
    WEAPON: "CRATE_WEAPON",
    PERK: "CRATE_PERK",
    BOMB: "CRATE_BOMB",
    BOMB_GENERIC: "CRATE_BOMB_GENERIC",
    SHARD: "CRATE_SHARD",
    XP: "CRATE_XP",
    LIFE: "CRATE_LIFE",
    TURRET: "CRATE_TURRET",
    CLASS_SELECTOR: "CRATE_CLASS_SELECTOR",
    OBJECTIVE: "CRATE_OBJECTIVE"
};
const Weapon = {
    TYPE_MELEE: "TYPE_MELEE",
    TYPE_PISTOL: "TYPE_PISTOL",
    TYPE_MACHINE_PISTOL: "TYPE_MACHINE_PISTOL",
    TYPE_SMG: "TYPE_SMG",
    TYPE_SHOTGUN: "TYPE_SHOTGUN",
    TYPE_SNIPER: "TYPE_SNIPER",
    TYPE_DMR: "TYPE_DMR",
    TYPE_CARBINE: "TYPE_CARBINE",
    TYPE_RIFLE: "TYPE_RIFLE",
    TYPE_LMG: "TYPE_LMG",
    TYPE_LAUNCHER: "TYPE_LAUNCHER",
    TYPE_GRENADE: "TYPE_GRENADE",
    TYPE_EXPLOSIVE: "TYPE_EXPLOSIVE",
    TYPE_TACTICAL: "TYPE_TACTICAL",
    TYPE_WEAPON_TACTICAL: "TYPE_WEAPON_TACTICAL",
    MODE_AUTO: "MODE_AUTO",
    MODE_BURST: "MODE_BURST",
    MODE_SEMI: "MODE_SEMI"
};
const Mods = {
    TYPE_BASE: "base",
    TYPE_OPTIC: "optic",
    TYPE_AMMO: "ammo",
    TYPE_BARREL: "barrel",
    TYPE_ACCESSORY: "accessory",
    OPTIC_REFLEX: "reflex",
    OPTIC_EOTECH: "eotech",
    OPTIC_ACOG: "acog",
    OPTIC_SCOPE: "scope",
    OPTIC_SCOPE_DMR: "scope_dmr",
    BASE_DEADEYE: "base_marksman",
    BASE_RAPID_FIRE: "base_rapid_fire",
    BASE_LOCK_ON: "base_lock_on",
    BASE_DAMPER: "base_damper",
    BASE_SPEED: "base_speed",
    BASE_RANGE: "base_range",
    BASE_BURST_FIRE: "base_burst_fire",
    BASE_MODE_SELECTOR: "base_mode_selector",
    BASE_FULL_AUTO: "base_full_auto",
    BASE_SINGLE_FIRE: "base_single_fire",
    BASE_SHIELD_DAMAGE: "base_shield_damage",
    BASE_SHIELD_RAPID_FIRE: "base_shield_alloy",
    AMMO_FMJ: "ammo_fmj",
    AMMO_PIERCING: "ammo_ap",
    AMMO_IMPACT: "ammo_impact",
    AMMO_EXTENDED: "ammo_extended",
    AMMO_HOLLOW_POINT: "ammo_hollow_point",
    AMMO_STOPPING_POWER: "ammo_high_caliber",
    AMMO_LAUNCHER_RADIUS: "ammo_radius",
    AMMO_LAUNCHER_EXPLOSIVE: "ammo_explosive",
    AMMO_SLUG: "ammo_slug",
    AMMO_DRAGONS_BREATH: "ammo_fire",
    AMMO_EXPLOSIVE: "ammo_explosive",
    ARROW_POISON: "arrow_poison",
    ARROW_EXPLOSIVE: "arrow_explosive",
    GRENADE_SMOKE: "grenade_smoke",
    GRENADE_FLASH: "grenade_flash",
    GRENADE_STUN: "grenade_stun",
    GRENADE_HE: "grenade_he",
    GRENADE_FIRE: "grenade_fire",
    ACCESSORY_MAG_ASSIST: "ammo_magpull",
    AMMO_SPEED_LOADER: "ammo_speed_loader",
    AMMO_HIGH_CALIBER: "ammo_range",
    AMMO_NAPALM: "ammo_napalm",
    BARREL_SILENCER: "barrel_silencer",
    BARREL_COMPENSATOR: "barrel_compensator",
    BARREL_BRAKE: "barrel_booster",
    BARREL_HEAVY: "barrel_range",
    ACCESSORY_LASER: "acc_laser",
    ACCESSORY_MARKER: "acc_marker",
    ACCESSORY_GRIP: "acc_grip",
    ACCESSORY_GRIP_ANGLED: "acc_grip_angled",
    ACCESSORY_M203: "acc_m203",
    ACCESSORY_M320: "acc_m320",
    ACCESSORY_GP25: "acc_gp25",
    ACCESSORY_MASTERKEY: "acc_masterkey"
};
const MatchState = {
    STATE_PRE_GAME: "pre_game",
    STATE_IN_PROGRESS: "in_progress",
    STATE_POST_ROUND: "post_round",
    STATE_POST_GAME: "post_game",
    END_RESULT_WIN: "end_result_win",
    END_RESULT_LOSS: "end_result_loss",
    END_RESULT_DRAW: "end_result_draw",
    END_CONDITION_TIME: "end_condition_time",
    END_CONDITION_SCORE: "end_condition_score",
    END_CONDITION_TREX_KILLED: "end_condition_trex_killed",
    END_CONDITION_KIA: "end_condition_kia",
    END_CONDITION_OBJECTIVE_COMPLETED: "end_condition_objective_completed",
    END_CONDITION_OBJECTIVE_FAILED: "end_condition_objective_failed",
    END_CONDITION_DINOS_RESCUED: "end_condition_dinos_rescued",
    END_CONDITION_HUMANS_KILLED: "end_condition_humans_killed",
    END_CONDITION_HUMANS_EXTRACTED: "end_condition_humans_extracted",
    END_CONDITION_FORFEIT: "end_condition_forfeit",
};
const Map = {
    CUSTOM: "map_custom",
    GENERATED: "map_generated"
};
const GameMode = {
    SCENARIO: "scenario",
    OPEN_WORLD: "open_world",
    FREE_FOR_ALL: "deathmatch",
    TEAM_DEATHMATCH: "team_deathmatch",
    DOMINATION: "domination",
    CONQUEST: "conquest",
    DESTRUCTION: "destruction",
    EVOLUTION: "evolution",
    CAPTURE_THE_FLAG: "capture_the_flag",
    RAPTOR_HUNT: "raptor_hunt",
    TYRANT: "tyrant",
    HUMANS_VS_DINOSAURS: "humans_vs_dinosaurs",
    DINO_RESCUE: "dino_rescue",
    ASSASSINATION: "assassination",
    EXTRACTION: "extraction",
    DEMOLITION: "demolition",
    SURVIVAL_CHAOS: "survival_chaos",
    SURVIVAL_MILITIA: "survival_militia",
    SURVIVAL_DINO: "survival_dino",
    SURVIVAL_ZOMBIE: "survival_zombie",
    SURVIVAL_CHICKEN: "survival_chicken",
    SURVIVAL_PANDEMONIUM: "survival_pandemonium"
};
const Classes = {
    ASSAULT: "assault",
    COMMANDO: "commando",
    SUPPORT: "support",
    HUNTER: "hunter"
};
const Dinosaur = {
    COMPY: "compy",
    DILO: "dilo",
    RAPTOR: "raptor",
    NEEDLER: "needler",
    PACHY: "pachy",
    SPINOSAURUS: "spinosaurus",
    ALLOSAURUS: "allosaurus",
    CARNOTAURUS: "carnotaurus",
    TREX: "trex",
    STEGOSAURUS: "stegosaurus",
    ANKYLOSAURUS: "ankylosaurus",
    LIZARD: "lizard",
    CHICKEN: "chicken",
    PTERODACTYL: "pterodactyl"
};
const Egg = {
    SMALL: "egg_small",
    LARGE: "egg_large",
    HUGE: "egg_huge",
    MASSIVE: "egg_massive"
};
const Character = {
    INDEX_MELEE: 2,
    INDEX_EQUIPMENT: 3,
    INDEX_GRENADE: 4,
    STYLE_DINOGEN: "dinogen",
    STYLE_MILITIA: "militia",
    STYLE_JUGGERNAUT: "juggernaut",
    HAIR_COLOUR_BROWN: "HAIR_COLOUR_BROWN",
    HAIR_COLOUR_BROWN_LIGHT: "HAIR_COLOUR_BROWN_LIGHT",
    HAIR_COLOUR_BLACK: "HAIR_COLOUR_BLACK",
    HAIR_COLOUR_BLONDE: "HAIR_COLOUR_BLONDE",
    HAIR_COLOUR_GINGER: "HAIR_COLOUR_GINGER",
    HAIR_COLOUR_GREY: "HAIR_COLOUR_GREY",
    HAIR_COLOUR_WHITE: "HAIR_COLOUR_WHITE",
    HAIR_COLOUR_RED: "HAIR_COLOUR_RED",
    HAIR_COLOUR_BLUE: "HAIR_COLOUR_BLUE",
    HAIR_COLOUR_GREEN: "HAIR_COLOUR_GREEN",
    FACE_DEFAULT: "face0000",
    FACE_TAN: "face0001",
    FACE_DARK: "face0002",
    FACE_FEMALE: "face0009",
    FACE_ZOMBIE_1: "face0003",
    FACE_ZOMBIE_2: "face0004",
    FACE_ZOMBIE_3: "face0005",
    FACE_ZOMBIE_4: "face0006",
    FACE_ZOMBIE_FAT: "face0007",
    FACE_ZOMBIE_EXPLODER: "face0008",
    FACE_ZOMBIE_SPITTER: "face0009",
    FACE_ZOMBIE_SPRINTER: "face0010",
    FACE_ZOMBIE_SPRINTER_BOSS: "face0011",
    FACE_INFESTOR: "face00012",    
    HAIR_SHORT: "hair0000",
    HAIR_BALD: "hair0008",
    HAIR_LONG: "hair0002",
    HAIR_PONYTAIL: "hair0003",
    HAIR_UNDERCUT: "hair0006",
    HAIR_SPIKES: "hair0005",
    HAIR_BUZZED: "hair0004",
    HAIR_FLAT: "hair0001",
    HAIR_STYLED: "hair0007",
    HAIR_HORSESHOE: "hair0010",
    HAIR_DREADS: "hair0009",
    BEARD_NONE: "beard0000",
    BEARD_STUBBLE: "beard0001",
    BEARD_FULL: "beard0002",
    BEARD_CIRCLE: "beard0003",
    BEARD_GOATEE: "beard0004",
    BEARD_MOUSTACHE: "beard0005",
    BEARD_SIDEBURNS: "beard0006",
    EYEWEAR_NONE: "eyewear0000",
    EYEWEAR_SHADES: "eyewear0001",
    EYEWEAR_GLASSES: "eyewear0002",
    EYEWEAR_GOGGLES_YELLOW: "eyewear0003",
    EYEWEAR_GOGGLES_ORANGE: "eyewear0004",
    EYEWEAR_GOGGLES_WHITE: "eyewear0005",
    EYEWEAR_GOGGLES_BLACK: "eyewear0006",
    FACEWEAR_NONE: "facewear0000",
    FACEWEAR_MASK: "facewear0001",
    FACEWEAR_SKULLMASK: "facewear0002",
    FACEWEAR_GHILLIE: "facewear0003",
    FACEWEAR_SCARF_OPFOR: "facewear0004",
    FACEWEAR_BALACLAVA: "facewear0005",
    FACEWEAR_SCARF_SPETSNAZ: "facewear0006",
    FACEWEAR_BANDANA: "facewear0007",
    FACEWEAR_GAS_MASK: "facewear0008",
    FACEWEAR_BANDANA_GENERIC: "facewear0009",
    FACEWEAR_GAITER: "facewear0010",
    FACEWEAR_TWOPLAYER: "facewear0019",
    HEAD_ERIC_HELMET: "head0082",
    HEAD_AETIC: "head0089",
    HEAD_NONE: "head0000",
    HEAD_MASK: "head0001",
    HEAD_GAS_MASK: "head0002",
    HEAD_RADIO: "head0003",
    HEAD_US_MASK: "head0004",
    HEAD_US_CAP: "head0005",
    HEAD_US_CAP_BACKWARDS: "head0006",
    HEAD_US_SPEC_OPS: "head0007",
    HEAD_US_HELMET: "head0008",
    HEAD_US_HELMET_TACTICAL: "head0009",
    HEAD_US_BOONIE: "head0010",
    HEAD_US_GHILLIE: "head0011",
    HEAD_GIGN_HELMET: "head0012",
    HEAD_GIGN_HELMET_2: "head0013",
    HEAD_GIGN_CAP: "head0014",
    HEAD_GSG9_HELMET: "head0015",
    HEAD_GSG9_HELMET_2: "head0016",
    HEAD_GSG9_HELMET_3: "head0017",
    HEAD_OPFOR_SCARF: "head0018",
    HEAD_OPFOR_HELMET: "head0019",
    HEAD_OPFOR_HELMET_2: "head0020",
    HEAD_OPFOR_BERET: "head0021",
    HEAD_OPFOR_SHADES: "head0022",
    HEAD_OPFOR_COMMANDER: "head0023",
    HEAD_RU_MASK: "head0024",
    HEAD_RU_HAT: "head0025",
    HEAD_RU_SCARF: "head0026",
    HEAD_RU_TOQUE: "head0027",
    HEAD_RU_BERET: "head0028",
    HEAD_RU_CAP: "head0029",
    HEAD_RU_RECON: "head0030",
    HEAD_RU_HELMET: "head0031",
    HEAD_MILITIA_RADIO: "head0032",
    HEAD_MILITIA_BAND: "head0033",
    HEAD_MILITIA_BANDANA: "head0034",
    HEAD_MILITIA_CAP: "head0035",
    HEAD_MILITIA_SNIPER: "head0036",
    HEAD_JUGGERNAUT_HELMET: "head0037",
    HEAD_RIOT_HELMET: "head0055",
    HEAD_RIOT_HELMET_VISOR_UP: "head0056",
    HEAD_UN_BERET: "head0057",
    HEAD_UN_HELMET: "head0058",
    HEAD_NIGHTVISION: "head0059",
    HEAD_ALTYN_HELMET: "head0060",
    HEAD_ALTYN_HELMET_VISOR_UP: "head0061",
    HEAD_HOOD: "head0062",
    HEAD_BALLISTIC_MASK_BLACK: "head0045",
    HEAD_BALLISTIC_MASK_WHITE: "head0046",
    BODY_DINOGEN: "body0000",
    BODY_MILITIA: "body0001",    
    BODY_DINOGEN_RIG: "body0003",
    BODY_DINOGEN_HEAVY: "body0006",
    BODY_MILITIA_RIG: "body0004",
    BODY_MILITIA_HEAVY: "body0007",
    BODY_JUGGERNAUT: "body0002",
    BODY_SHIRTLESS: "body0005",
    BODY_SHIRTLESS_TAN: "body0008",
    BODY_SHIRTLESS_DARK: "body0009",
    BODY_ZOMBIE: "body0010",
    BODY_ZOMBIE_2: "body0011",
    BODY_ZOMBIE_3: "body0012",
    LEGS_BOOTS: "boots",
    LEGS_SHORTS: "shorts",
    LEGS_BAREFOOT: "barefoot",
    LEGS_JUGGERNAUT: "juggernaut"
};
const AvatarPresets = {
    JUGGERNAUT: "juggernaut",
    COMMANDER: "commander",
    DINOGEN: "dinogen",
    DINOGEN_HEAVY: "dinogen_heavy",
    DINOGEN_RANDOM: "dinogen_random",
    MILITIA: "militia",
    SHIRTLESS: "shirtless",
    PETERSON: "peterson",
    LIAM: "liam",
    BROCK: "brock",
    ZOMBIE: "zombie",
    ZOMBIE_JUGGERNAUT: "zombie_juggernaut",
    BIGFOOT: "bigfoot",
    SHOPKEEPER: "shopkeeper"
};
const Faction = {
    DINOGEN: "dinogen",
    MILITIA: "militia",
    DINOSAURS: "dinosaurs"
};

class GameInstance
{

    settings = this.getDefaultSettings();

    getDefaultSettings()
    {
        return {
            intermissionTimer: 15,
            maxBatchItems: 50,
            maxWorldSize: 10240,
            maxPlayerMoney: 100000,
            maxScenarioObjects: 2000,
            maxPickups: 12,
            maxCrates: 8,
            maxPawns: 75,
            maxDroppedWeapons: 12,
            maxSpawners: 64,
            maxVehicles: 64,
            maxSurvivalEnemies: 12,
            maxSurvivalCars: 4,
            maxSurvivalTanks: 1,
            maxSurvivalTurrets: 16,
            maxSurvivalHelicopters: 4,
            maxSurvivalDinosaurs: 8,
            maxFlames: 60,
            maxFlamesPerPlayer: 40,
            maxTurretsPerPlayer: 4,
            maxFlashTime: 6,
            maxStunTime: 6,
            vehicleExplosionDamage: 0
        };
    }

    init(_data, _onEventFunc)
    {
        this.log("Initializing game instance");
        if (this.bGameEnded)
        {
            console.warn("Game already ended");
            return;
        }
        try
        {
            this.settings = this.getDefaultSettings();
            this.data = _data.data;
            this.lobbyId = _data.lobbyId;
            this.onEventFunc = _onEventFunc;
            this.batchData = [];
            var defaultTickRate = 60;
            var fps = _data.settings.tickRate != null ? Math.min(_data.settings.tickRate, 60) : defaultTickRate;
            var settings = {
                fps: fps,
                restitution: 0.1,
                updateTimerMax: Math.round(fps / (_data.settings.updateRate != null ? _data.settings.updateRate : 60))
            };
            if (this.data.p2)
            {
                this.p2 = this.data.p2;
            }
            else if (typeof p2 !== "undefined")
            {
                this.p2 = p2;
            }
            else
            {
                console.error("Missing p2 reference!");
            }
            if (typeof GPU !== "undefined")
            {
                //this.gpu = new GPU();
            }
            this.game = {
                bPaused: false,
                bPerformanceMode: false,
                bMultiplayer: _data.bMultiplayer,
                bRanked: true,
                bSurvival: false,
                bScenario: false,
                bOpenWorld: _data.gameModeId == GameMode.OPEN_WORLD,
                bFriendlyFire: _data.settings.bFriendlyFire != null ? _data.settings.bFriendlyFire : true,
                settings: settings,
                frameRate: 1 / 30,
                timestepMult: settings.fps / 60,
                fpsMult: settings.fps / 60,
                gameSettings: this.clone(_data.settings),
                gameModeId: _data.gameModeId,
                mapId: _data.mapId,
                mapData: null,
                state: MatchState.STATE_PRE_GAME,
                players: [],
                scenario: _data.scenario ? this.clone(_data.scenario) : null,
                cinematic: null,
                actionQueue: [],
                supportItems: [],
                triggers: null,
                gameModeData: {
                    id: _data.gameModeId,
                    timeLimit: _data.settings.timeLimit ? _data.settings.timeLimit * 60 : null,
                    respawnTime: _data.settings.respawnTime ? _data.settings.respawnTime : 5,
                    bUseRoundThreshold: _data.settings.bUseRoundThreshold == true,
                    numRounds: _data.settings.numRounds != null ? _data.settings.numRounds : null,
                    bAllowClassSelection: true,
                    bSpawnProtection: _data.settings.bSpawnProtection !== false,
                    bMapVehicles: _data.settings.bMapVehicles == true,
                    bMapObjects: _data.settings.bMapObjects != null ? _data.settings.bMapObjects : true,
                    bMapWeapons: _data.settings.bMapWeapons != null ? _data.settings.bMapWeapons : true,
                    vehicleRespawnTime: _data.settings.vehicleRespawnTime != null ? _data.settings.vehicleRespawnTime : 60,
                    weaponRespawnTime: _data.settings.weaponRespawnTime != null ? _data.settings.weaponRespawnTime : 60,
                    bAllowRespawns: true,
                    bAllowRevives: false,
                    bHardcore: _data.settings.bHardcore == true,
                    bUnlimitedAmmo: _data.settings.bUnlimitedAmmo == true,
                    botFaction: _data.settings.botFaction ? _data.settings.botFaction : "all",
                    allowFactions: _data.settings.allowFactions ? _data.settings.allowFactions : "all",
                    factions: [Faction.DINOGEN, Faction.MILITIA],
                    vars: {}
                },
                lobbyId: _data.lobbyId,
                preGameTimer: _data.settings.preGameTimer != null ? _data.settings.preGameTimer : 10,
                gameTimer: 0,
                interval: null,
                timer_game: null,
                timer_preGame: null,
                world: new this.p2.World({
                    gravity: [0, 0],
                    broadphase: new this.p2.NaiveBroadphase()
                }),
                objects: {},
                types: {},
                spawners: [],
                toRemove: [],
                objectsToUpdate: null,
                updateTimer: 1,
                mapNodes: null,
                nodes: null,
                nodeObjects: {},
                nodeThreshold: 50,
                nodeTicker: 0,
                nodeTickerMax: settings.fps * 3,
                callbacks: this.data.callbacks
            }
            this.game.world.islandSplit = false;
            this.game.world.applyGravity = false;
            this.game.world.applySpringForces = false;
            this.game.nodeTicker = this.game.nodeTickerMax;
            this.game.world.sleepMode = this.p2.World.BODY_SLEEPING;
            this.game.world.defaultContactMaterial.friction = 0.5;
            this.game.world.on("beginContact", (_event) =>
            {
                this.onBeginContact(_event);
            });
            this.game.world.solver.tolerance = this.game.gameSettings.tolerance ? this.game.gameSettings.tolerance : (this.game.bMultiplayer ? 0.1 : 0.9);
            this.game.world.solver.iterations = this.game.gameSettings.iterations ? this.game.gameSettings.iterations : (this.game.bMultiplayer ? 2 : 1);
            this.game.world.solver.frictionIterations = 0;

            if (!this.game.bMultiplayer)
            {
                this.settings.maxTurretsPerPlayer = 8;
            }

            var keys = Object.keys(this.settings);
            for (var i = 0; i < keys.length; i++)
            {
                let key = keys[i];
                let val = this.game.gameSettings[key];
                if (val != null)
                {
                    let minVal = 0;
                    let maxVal = 1000000;
                    switch (key)
                    {
                        case "maxSurvivalEnemies":
                            minVal = 1;
                            break;
                        case "maxPawns":
                            minVal = 1;
                            maxVal = 200;
                            break;
                        case "maxWorldSize":
                            minVal = maxVal = 10240;
                            break;
                    }
                    this.settings[key] = Math.min(maxVal, Math.max(minVal, val));
                    this.scenarioLog("Override " + key + ": " + this.settings[key]);
                }
            }

            var map = this.getCurrentMapData();
            var groundMask = CollisionGroups.PAWN | CollisionGroups.HELICOPTER | CollisionGroups.OBJECT | CollisionGroups.PROJECTILE | CollisionGroups.FLAME;

            var leftBody = new this.p2.Body({
                angle: (3 * Math.PI) / 2
            });
            leftBody.data = {
                id: "bounds_l",
                type: ObjectType.GROUND,
                bBounds: true,
                bSkipServerUpdate: true
            };
            leftBody.addShape(new this.p2.Plane({
                collisionGroup: CollisionGroups.BOUNDS,
                collisionMask: groundMask
            }));
            this.addWorldBody(leftBody);

            var rightBody = new this.p2.Body({
                angle: Math.PI / 2,
                position: [this.getMapWidth(), 0]
            });
            rightBody.data = {
                id: "bounds_r",
                type: ObjectType.GROUND,
                bBounds: true,
                bSkipServerUpdate: true
            };
            rightBody.addShape(new this.p2.Plane({
                collisionGroup: CollisionGroups.BOUNDS,
                collisionMask: groundMask
            }));
            this.addWorldBody(rightBody);

            var topBody = new this.p2.Body({
                angle: 0,
                position: [0, 0]
            });
            topBody.data = {
                id: "bounds_t",
                type: ObjectType.GROUND,
                bBounds: true,
                bSkipServerUpdate: true
            };
            topBody.addShape(new this.p2.Plane({
                collisionGroup: CollisionGroups.BOUNDS,
                collisionMask: groundMask
            }));
            this.addWorldBody(topBody);

            var bottomBody = new this.p2.Body({
                angle: this.ToRad(180),
                position: [0, this.getMapHeight()]
            });
            bottomBody.data = {
                id: "bounds_b",
                type: ObjectType.GROUND,
                bBounds: true,
                bSkipServerUpdate: true
            };
            bottomBody.addShape(new this.p2.Plane({
                collisionGroup: CollisionGroups.BOUNDS,
                collisionMask: groundMask
            }));
            this.addWorldBody(bottomBody);

            this.game.gameModeData.scores = [0, 0];
            this.game.gameModeData.scoreLimit = _data.settings.scoreLimit;

            if (this.game.scenario)
            {
                this.game.gameModeData.quests = [];
                this.game.gameModeData.hudElements = {};
            }

            switch (this.game.gameModeId)
            {
                case GameMode.OPEN_WORLD:
                    this.game.bRanked = false;
                    this.game.preGameTimer = 0;
                    this.game.gameModeData.bAllowRespawns = true;
                    this.game.gameModeData.bAllowRevives = true;
                    this.game.gameModeData.bAllowClassSelection = false;
                    this.game.gameModeData.allowFactions = "humans";
                    this.game.gameModeData.factions = [Faction.DINOGEN, Faction.MILITIA];
                    this.game.gameModeData.worldTime = 720;
                    this.game.gameModeData.day = 1;
                    //this.game.gameSettings.bHidePlayerHealth = true;
                    this.game.gameSettings.bUseKillfeed = true;
                    this.settings.maxPickups = 32;
                    this.settings.maxCrates = 32;
                    this.settings.maxDroppedWeapons = 32;
                    this.game.triggers = [];
                    break;
                case GameMode.SCENARIO:
                    this.game.bRanked = false;
                    this.game.bScenario = true;
                    this.game.gameModeData.bMapObjects = true;
                    this.game.gameModeData.bAllowRespawns = this.game.gameSettings.bAllowRespawns == true;
                    this.game.gameModeData.bAllowRevives = this.game.gameSettings.bAllowRevives == true;
                    break;
                case GameMode.FREE_FOR_ALL:
                    this.game.gameModeData.factions = null;
                    break;
                case GameMode.HUMANS_VS_DINOSAURS:
                    this.game.gameModeData.allowFactions = "humans_dinosaurs";
                    break;
                case GameMode.TYRANT:
                case GameMode.RAPTOR_HUNT:
                case GameMode.HUMANS_VS_DINOSAURS:
                    this.game.gameModeData.factions = [Faction.DINOGEN, Faction.DINOSAURS];
                    break;
                case GameMode.DOMINATION:
                    this.game.gameModeData.flags = [];
                    for (var i = 0; i < 3; i++)
                    {
                        this.game.gameModeData.flags.push(null);
                        if (!map.flags[this.game.gameModeId])
                        {
                            map.flags[this.game.gameModeId] = [];
                        }
                        var flag = this.createFlag(map.flags[this.game.gameModeId][i], {
                            flagType: GameMode.DOMINATION,
                            num: i
                        });
                        flag.mass = 0;
                    }
                    break;
                case GameMode.CONQUEST:
                    this.game.gameModeData.flags = [];
                    for (var i = 0; i < 5; i++)
                    {
                        this.game.gameModeData.flags.push(null);
                        if (!map.flags[this.game.gameModeId])
                        {
                            map.flags[this.game.gameModeId] = [];
                        }
                        var flag = this.createFlag(map.flags[this.game.gameModeId][i], {
                            flagType: GameMode.DOMINATION,
                            num: i
                        });
                        flag.mass = 0;
                    }
                    break;
                case GameMode.CAPTURE_THE_FLAG:
                    this.game.gameModeData.flags = [];
                    for (var i = 0; i < 2; i++)
                    {
                        this.game.gameModeData.flags.push(i);
                        if (!map.flags[this.game.gameModeId])
                        {
                            map.flags[this.game.gameModeId] = [];
                        }
                        this.createFlag(map.flags[this.game.gameModeId][i], {
                            flagType: GameMode.CAPTURE_THE_FLAG,
                            num: i,
                            team: i
                        });
                    }
                    break;
                case GameMode.DESTRUCTION:
                    this.game.gameModeData.bombs = [0, 0, 1, 1];
                    this.game.gameModeData.scoreLimit = 2;
                    this.game.gameModeData.allowFactions = "all";
                    break;
                case GameMode.EVOLUTION:
                    this.game.gameModeData.factions = [Faction.DINOGEN, Faction.DINOSAURS];
                    this.game.gameModeData.dinoIndex = 0;
                    this.game.gameModeData.dinoKills = 0;
                    this.game.gameModeData.dinos = [
                        { id: Dinosaur.COMPY, kills: 3 },
                        { id: Dinosaur.DILO, kills: 5 },
                        { id: Dinosaur.PACHY, kills: 5 },
                        { id: Dinosaur.RAPTOR, kills: 5 },
                        { id: Dinosaur.NEEDLER, kills: 5 },
                        { id: Dinosaur.STEGOSAURUS, kills: 6 },
                        { id: Dinosaur.CARNOTAURUS, kills: 6 },
                        { id: Dinosaur.ALLOSAURUS, kills: 8 },
                        { id: Dinosaur.SPINOSAURUS, kills: 8 }
                    ];
                    if (_data.settings.bReverse)
                    {
                        this.game.gameModeData.dinos.reverse();
                    }
                    this.game.gameModeData.dino = this.game.gameModeData.dinos[0].id;
                    this.game.gameModeData.dinoKillsMax = this.game.gameModeData.dinos[0].kills;
                    break;
                case GameMode.EXTRACTION:
                    this.game.gameModeData.allowFactions = "humans_dinosaurs";
                    this.game.gameModeData.factions = [Faction.DINOGEN, Faction.DINOSAURS];
                    this.game.gameModeData.numAirdrops = Math.max(1, this.game.gameModeData.scoreLimit);
                    this.game.gameModeData.numTotalAirdrops = this.game.gameModeData.numAirdrops;
                    this.game.gameModeData.numObjectives = 0;
                    this.game.gameModeData.airdropTimerMax = Math.min(60, Math.round(this.game.gameModeData.timeLimit / (this.game.gameModeData.numAirdrops + 1)));
                    this.game.gameModeData.bAllowRevives = true;
                    this.game.gameModeData.respawnTeam = 1;
                    break;
                case GameMode.ASSASSINATION:
                    this.game.gameModeData.round = 0;
                    this.game.gameModeData.scoreLimit = this.game.gameModeData.numRounds;
                    this.game.gameModeData.vipTeam = 0;
                    break;
                case GameMode.DINO_RESCUE:
                    this.game.gameModeData.round = 0;
                    this.game.gameModeData.numRounds = this.game.gameModeData.scoreLimit;
                    this.game.gameModeData.rescueTeam = 0;
                    this.game.gameModeData.numHostages = 2;
                    break;
                case GameMode.SURVIVAL_CHAOS:
                case GameMode.SURVIVAL_DINO:
                case GameMode.SURVIVAL_MILITIA:
                case GameMode.SURVIVAL_ZOMBIE:
                case GameMode.SURVIVAL_CHICKEN:
                case GameMode.SURVIVAL_PANDEMONIUM:
                    this.game.preGameTimer = this.game.gameSettings.preGameTimer ? this.game.gameSettings.preGameTimer : 0;
                    this.game.bRanked = false;
                    this.game.bSurvival = true;
                    this.game.bFriendlyFire = false;
                    this.game.gameModeData.bHardcore = false;
                    this.game.gameModeData.bIntermission = true;
                    this.game.gameModeData.scores = null;
                    this.game.gameModeData.bAllowRevives = true;
                    this.game.gameModeData.timeLimit = null;
                    this.game.gameModeData.bHardcore = false;
                    this.game.gameModeData.bMapVehicles = false;
                    this.game.gameModeData.bMapObjects = true;
                    this.game.gameModeData.bMapWeapons = false;
                    this.game.gameModeData.bAllowRespawns = false;
                    this.game.gameModeData.bSpawnProtection = true;
                    this.game.gameModeData.wave = 0;
                    this.game.gameModeData.enemies = 0;
                    this.game.gameModeData.kills = 0;
                    this.game.gameModeData.waveRevives = 0;
                    this.game.gameModeData.allowFactions = "humans";
                    this.game.gameModeData.factions = [Faction.DINOGEN];
                    break;
            }

            this.initMap();

            switch (this.game.gameModeId)
            {
                case GameMode.EXTRACTION:
                    var teamSpawnPos = map.teamSpawns[0];
                    this.createCrate([teamSpawnPos.x + (teamSpawnPos.w * 0.5), teamSpawnPos.y + (teamSpawnPos.h * 0.5)], {
                        id: "classCrate",
                        team: 0,
                        crateType: Crate.CLASS_SELECTOR,
                        itemData: {
                            uses: null,
                            maxUses: null,
                            interactTime: this.game.settings.fps * 1
                        },
                        mass: 0,
                        bDisposable: false
                    });
                    var padding = 1;
                    var turretData = {
                        team: 0,
                        vehicleId: MountedWeapon.SENTRY,
                        bAutomated: true,
                        bRespawn: true
                    };
                    this.createMountedWeapon([teamSpawnPos.x + padding, teamSpawnPos.y + padding], turretData);
                    this.createMountedWeapon([teamSpawnPos.x + teamSpawnPos.w - padding, teamSpawnPos.y + padding], turretData);
                    this.createMountedWeapon([teamSpawnPos.x + teamSpawnPos.w - padding, teamSpawnPos.y + teamSpawnPos.h - padding], turretData);
                    this.createMountedWeapon([teamSpawnPos.x + padding, teamSpawnPos.y + teamSpawnPos.h - padding], turretData);
                    break;

                case GameMode.DINO_RESCUE:
                    this.createTriggerArea({
                        id: "rescueZone",
                        position: this.getRescueZonePosition(),
                        width: 250,
                        height: 250,
                        icon: "item_raptor",
                        team: 0,
                        indicatorData: {
                            labelText: "STR_RESCUE_ZONE",
                            icon: null,
                            bClamp: true
                        }
                    });
                    break;

                case GameMode.SURVIVAL_CHICKEN:
                    this.game.gameSettings.bDisableMoneyDrops = true;
                    break;

                case GameMode.SURVIVAL_PANDEMONIUM:
                    //Spawn random weapons
                    let weapons = [
                        Weapon.TYPE_MELEE,
                        Weapon.TYPE_PISTOL,
                        Weapon.TYPE_MACHINE_PISTOL,
                        Weapon.TYPE_CARBINE,
                        Weapon.TYPE_RIFLE,
                        Weapon.TYPE_DMR,
                        Weapon.TYPE_LMG,
                        Weapon.TYPE_LAUNCHER,
                        Weapon.TYPE_SNIPER,
                        Weapon.TYPE_WEAPON_TACTICAL,
                        Weapon.TYPE_EXPLOSIVE
                    ];
                    for (var i = 0; i < weapons.length; i++)
                    {
                        let wpns = this.getAllWeaponsByType(weapons[i]);
                        let wpn = this.getWeaponData(wpns[this.Random(0, wpns.length - 1)].id);
                        if (wpn.ammo != null)
                        {
                            wpn.ammo *= 5;
                        }
                        this.setRandomWeaponMods(wpn);
                        let pos = this.getRandomSpawnPosition();
                        pos[0] += this.Random(-10, 10);
                        pos[1] += this.Random(-10, 10);
                        this.createDroppedWeapon(pos, {
                            weaponData: wpn,
                            angle: this.RandomAngle()
                        });
                    }
                    break;

                case GameMode.SURVIVAL_CHAOS:
                case GameMode.SURVIVAL_DINO:
                case GameMode.SURVIVAL_MILITIA:
                case GameMode.SURVIVAL_ZOMBIE:
                    if (this.game.gameSettings.bHideDefaultStoreCrate !== true)
                    {
                        this.createCrate(map.storeSpawn, {
                            team: 0,
                            mass: 0,
                            frame: "crate_store",
                            crateType: Crate.STORE,
                            bDisposable: false
                        });
                    }
                    break;

                case GameMode.DESTRUCTION:
                    var bombs = map.bombs[this.game.gameModeId];
                    var bombNum = 0;
                    if (bombs)
                    {
                        for (var i = 0; i < bombs.length; i++)
                        {
                            let points = bombs[i];
                            for (var j = 0; j < points.length; j++)
                            {
                                let pos = points[j];
                                if (pos)
                                {
                                    let platform = this.createObstacle({
                                        position: pos,
                                        angle: 0,
                                        obstacleId: "platform",
                                        bNoBody: true
                                    });
                                    let bombCrate = this.createCrate(pos, {
                                        mass: 0,
                                        team: i,
                                        num: bombNum,
                                        crateType: Crate.BOMB,
                                        bLimitInteractions: true,
                                        itemData: {
                                            interactTime: this.game.settings.fps * 3,
                                            interactTeam: i == 0 ? 1 : 0
                                        }
                                    });
                                }
                                else
                                {
                                    throw new Error("Invalid bomb position at bomb index " + i);
                                }
                                bombNum++;
                            }
                        }
                    }
                    else
                    {
                        console.warn("Invalid bomb spawn points", map.bombs);
                    }
                    break;
            }

            this.game.nodeTicker = 1;

            this.onEvent({
                eventId: GameServer.EVENT_GAME_INIT,
                shared: this.data.shared,
                mapId: this.game.mapId,
                gameModeId: this.game.gameModeId,
                settings: this.game.settings,
                gameSettings: this.game.gameSettings,
                gameModeData: this.game.gameModeData,
                mapData: this.getCurrentMapData(),
                tiles: this.game.tiles
            });

            if (this.game.gameModeData.timeLimit || this.game.scenario || this.game.gameModeId == GameMode.SURVIVAL_PANDEMONIUM || 1)
            {
                this.game.gameTimer = this.game.gameModeData.timeLimit;
                this.game.timer_game = setInterval(() =>
                {
                    this.onGameTimer();
                }, 1000);
            }

            var players = this.clone(_data.players);
            if (this.game.scenario && !this.game.scenario.settings.bAllowGameModeSelection)
            {
                if (_data.settings.bots)
                {
                    console.log("Add", _data.settings.bots, "scenario bots", _data.settings.botSkill);
                    for (var i = 0; i < _data.settings.bots; i++)
                    {
                        var bot = this.getBot(_data.settings.botSkill != null ? _data.settings.botSkill : 1);
                        if (_data.settings.bDeathmatch || this.game.gameModeId == GameMode.FREE_FOR_ALL)
                        {
                            bot.team = players.length + 1;
                        }
                        else if (_data.settings.botTeam == -1)
                        {
                            switch (this.game.gameModeId)
                            {
                                case GameMode.TYRANT:
                                    bot.team = i == 0 ? 1 : 0;
                                    break;
                                default:
                                    bot.team = i % 2 == 0 ? 0 : 1;
                                    break;
                            }
                        }
                        else
                        {
                            bot.team = _data.settings.botTeam != null ? _data.settings.botTeam : 0;
                        }
                        players.push(bot);
                    }
                }
            }
            for (var i = 0; i < players.length; i++)
            {
                var ps = players[i];
                if (ps.bBot || !this.game.bMultiplayer)
                {
                    this.addPlayer(ps);
                }
            }
            
            if (this.game.preGameTimer > 0)
            {
                this.game.timer_preGame = setInterval(() =>
                {
                    this.onPreGameTimer();
                }, 1000);
                this.onEvent({
                    eventId: GameServer.EVENT_GAME_UPDATE,
                    data: this.game.gameModeData
                });
                this.onEvent({
                    eventId: GameServer.EVENT_GAME_PRE_TIMER,
                    timer: this.game.preGameTimer
                });
            }
            else
            {
                if (!this.isGeneratingNodes() || 1)
                {
                    this.game.state = MatchState.STATE_IN_PROGRESS;
                    this.requestEvent({
                        eventId: GameServer.EVENT_GAME_START,
                        timer: this.game.gameTimer
                    });
                }
                this.onEvent({
                    eventId: GameServer.EVENT_GAME_UPDATE,
                    data: this.game.gameModeData
                });
            }

            if (_data.settings.forest)
            {
                this.createForest(_data.settings.forest);
            }
            if (_data.settings.boxes)
            {
                this.createBoxes(_data.settings.boxes);
            }

            if (this.game.bSurvival)
            {
                this.startSurvivalWaveIntermission();
            }
            if (this.game.gameModeData.round != null)
            {
                this.onRoundStart();
            }

            clearInterval(this.game.interval);
            this.game.interval = setInterval(() =>
            {
                this.tick();
            }, 1000 / this.game.settings.fps);
            this.bInit = true;
        }
        catch (e)
        {
            this.onGameError(e);
        }
    }

    destroy()
    {
        this.log("Destroy game");
        var game = this.game;
        if (game)
        {
            var world = game.world;
            if (world)
            {
                world.time = 0;
                world.fixedStepTime = 0;
                if (world.solver && world.solver.equations.length)
                {
                    world.solver.removeAllEquations();
                }
                var cs = world.constraints;
                for (var i = cs.length - 1; i >= 0; i--)
                {
                    world.removeConstraint(cs[i]);
                }
                var bodies = world.bodies;
                for (var i = bodies.length - 1; i >= 0; i--)
                {
                    world.removeBody(bodies[i]);
                }
                var springs = world.springs;
                for (var i = springs.length - 1; i >= 0; i--)
                {
                    world.removeSpring(springs[i]);
                }
                var cms = world.contactMaterials;
                for (var i = cms.length - 1; i >= 0; i--)
                {
                    world.removeContactMaterial(cms[i]);
                }
                world.off("beginContact");
            }
            clearInterval(this.game.interval);
            delete this.game.interval;
            this.stopAllTimers();
            while (this.game.players.length > 0)
            {
                this.removePlayer(this.game.players[0].id);
            }
            delete this.game.gameModeData.vars;
            var keys = Object.keys(this.game);
            for (var i = 0; i < keys.length; i++)
            {
                delete this.game[keys[i]];
            }            
            delete this.game;
            delete this.onEndCallback;
            delete this.onEventFunc;
            delete this.batchData;
            delete this.onEndCallback;
            delete this.lobbyId;
            var keys = Object.keys(this.data);
            for (var i = 0; i < keys.length; i++)
            {
                delete this.data[keys[i]];
            }
            delete this.data;
            delete this.gpu;
            delete this.p2;
            delete this.bInit;
            delete this.settings;
        }
    }

    setEndCallback(_func)
    {
        this.onEndCallback = _func;
    }

    log(_val)
    {
        console.log("[game.js] " + _val);
    }

    scenarioLog(_val, _fill)
    {        
        if (this.game.gameSettings.bDebug)
        {
            console.log(_val);
            this.triggerCallback("chat", {
                messageText: _val,
                playerText: "Debug",
                fill: _fill,
                date: Date.now()
            });
        }
    }

    endGame()
    {
        if (this.bGameEnded)
        {
            return;
        }
        this.log("End game");
        this.bGameEnded = true;
        this.game.state = MatchState.STATE_POST_GAME;
        this.game.gameModeData.bAllowRespawns = false;
        this.resetPlayerInputs();
        this.stopAllTimers();
        var pawns = this.getPawns();
        for (var i = 0; i < pawns.length; i++)
        {
            var pawn = pawns[i];
            var data = pawn.data;
            if (data.bWantsToFire)
            {
                data.bWantsToFire = false;
            }
            switch (data.type)
            {
                case ObjectType.HELICOPTER:
                case ObjectType.TANK:
                case ObjectType.CAR:
                case ObjectType.MOUNTED_WEAPON:
                    var weapons = data.weapons;
                    if (weapons)
                    {
                        for (var j = 0; j < weapons.length; j++)
                        {
                            var wpn = this.getCurrentVehicleWeapon(pawn, j);
                            if (wpn)
                            {
                                wpn.bWantsToFire = false;
                            }
                        }
                    }
                    break;
                case ObjectType.CHARACTER:
                case ObjectType.DINOSAUR:
                case ObjectType.FLYING_DINOSAUR:
                    data.bWantsToMove = false;
                    data.bWantsToFire = false;
                    this.triggerCharacterWeapon({ playerId: data.id, value: false });
                    this.cancelCharacterReload(pawn);
                    break;

            }
        }
        if (this.onEndCallback)
        {
            this.onEndCallback(this.lobbyId);
        }
    }

    tick()
    {
        try
        {
            this.update();
        }
        catch (e)
        {            
            this.onGameError(e);
        }
    }

    delay(ms)
    {
        return new Promise(resolve => setTimeout(resolve, ms))
    }

    async loop()
    {
        while (this.game)
        {
            this.tick();
            await this.delay(1000 / this.game.settings.fps);
        }
    }

    onGameError(e, _endTimer)
    {
        console.error(e);
        if (!this.game)
        {
            return;
        }
        if (this.game.bMultiplayer)
        {
            this.triggerCallback("chat", {
                locText: "STR_ERROR_RUNTIME_X",
                params: [e.message],
                bError: true
            });
            this.triggerCallback("error", { endTimer: _endTimer } );
        }
        else
        {
            this.onEventFunc({
                eventId: GameServer.EVENT_ERROR,
                error: e
            });
        }
    }

    update()
    {
        if (!this.game)
        {
            clearInterval(this.game.interval);
            this.log("Clear game interval");
            return;
        }
        if (this.game.bPaused)
        {
            this.game.resetCallTime = true;
        }
        else
        {
            for (var i = 0; i < this.game.players.length; i++)
            {
                var ps = this.game.players[i];
                var pawn = this.getObjectById(ps.id);
                if (ps.bBot)
                {
                    //Handle bots                    
                }
                if (this.playerCanRespawn(ps) && !this.game.gameSettings.bDisableRespawnTimer && !ps.bSpectator)
                {
                    if (ps.timer_respawn != null && ps.bWaitingToRespawn)
                    {
                        if (ps.timer_respawn > 0)
                        {
                            ps.timer_respawn--;
                        }
                        else
                        {
                            this.onRespawnTimer(ps.id);
                        }
                    }
                }
                if (ps.multiKillTimer > 0)
                {
                    ps.multiKillTimer--;
                }
                else if (ps.multiKillTimer == 0)
                {
                    this.endMultiKill(ps);
                    ps.multiKillTimer = -1;
                }
                if (ps.avengerTimer > 0)
                {
                    ps.avengerTimer--;
                }
                else
                {
                    ps.avengerTimer = -1;
                }
                if (ps.timer_spawnProtection != null)
                {
                    if (ps.timer_spawnProtection > 0)
                    {
                        ps.timer_spawnProtection--;
                    }
                    else
                    {
                        this.onSpawnProtectionTimer(ps.id);
                    }
                }
                if (!pawn || !pawn.data.health)
                {
                    if (ps.bHasPawn)
                    {
                        ps.bHasPawn = false;
                        if (this.playerCanRespawn(ps))
                        {
                            var bCanRespawn = ps.lives != null ? ps.lives > 0 : true;
                            if (bCanRespawn)
                            {
                                ps.bCanRespawn = false;
                                ps.bWaitingToRespawn = true;
                                if (ps.respawnTimer <= 0)
                                {
                                    if (ps.timer_respawn == null)
                                    {
                                        ps.respawnTimer = this.game.gameModeData.respawnTime + 1;
                                        ps.timer_respawn = this.game.settings.fps;
                                    }
                                    this.onEvent({
                                        eventId: GameServer.EVENT_PLAYER_UPDATE,
                                        playerId: ps.id,
                                        data: {
                                            bCanRespawn: ps.bCanRespawn,
                                            bWaitingToRespawn: ps.bWaitingToRespawn,
                                            bHasPawn: ps.bHasPawn,
                                            respawnTimer: ps.respawnTimer
                                        }
                                    });
                                }
                            }
                        }
                        else
                        {
                            this.onEvent({
                                eventId: GameServer.EVENT_PLAYER_UPDATE,
                                playerId: ps.id,
                                data: {
                                    bHasPawn: ps.bHasPawn
                                }
                            });
                        }
                    }
                }
                else
                {
                    if (!ps.bHasPawn)
                    {
                        ps.bHasPawn = true;
                        if (this.playerCanRespawn(ps))
                        {
                            ps.bWaitingToRespawn = false;
                        }
                        this.onEvent({
                            eventId: GameServer.EVENT_PLAYER_UPDATE,
                            playerId: ps.id,
                            data: {
                                bHasPawn: ps.bHasPawn,
                                bWaitingToRespawn: ps.bWaitingToRespawn
                            }
                        });
                    }
                }
            }

            if (this.game.bSurvival && this.matchInProgress())
            {
                var gameData = this.game.gameModeData;
                if (gameData.waveTimer > 0)
                {
                    gameData.waveTimer--;
                    if (gameData.waveTimer <= 0)
                    {
                        if (gameData.intermissionTimer >= 0)
                        {
                            gameData.intermissionTimer--;
                            this.onEvent({
                                eventId: GameServer.EVENT_GAME_UPDATE,
                                data: {
                                    timer: gameData.intermissionTimer
                                }
                            });
                            if (gameData.intermissionTimer == -1)
                            {
                                this.startSurvivalWave();
                            }
                            else
                            {
                                gameData.waveTimer = this.game.settings.fps;
                            }
                        }
                    }
                }
                else if (gameData.spawnTimer > 0)
                {
                    gameData.spawnTimer--;
                    if (gameData.spawnTimer <= 0)
                    {
                        if (gameData.enemiesSpawned < gameData.numEnemies)
                        {
                            var numOnTeam = this.getNumPawnsOnTeam(1);
                            if (numOnTeam < this.settings.maxSurvivalEnemies)
                            {
                                var wave = this.game.gameModeData.wave;
                                switch (this.game.gameModeId)
                                {
                                    case GameMode.SURVIVAL_CHAOS:
                                        if (wave % 25 == 0)
                                        {
                                            if (gameData.enemiesSpawned == 0)
                                            {
                                                this.spawnSurvivalEnemyDinosaur();
                                                gameData.enemiesSpawned++;
                                            }
                                            else
                                            {
                                                this.spawnSurvivalEnemyVehicle();
                                            }
                                        }
                                        else if (wave == 8)
                                        {
                                            if (gameData.enemiesSpawned <= 2)
                                            {
                                                this.spawnSurvivalEnemyDinosaur();
                                                gameData.enemiesSpawned++;
                                            }
                                            else
                                            {
                                                this.spawnSurvivalEnemyCharacter();
                                                gameData.enemiesSpawned++;
                                            }
                                        }
                                        else if (wave % 5 == 0)
                                        {
                                            let heliThreshold = Math.max(0, Math.min(3, (wave / 5) - 5));
                                            if (wave > 5 && gameData.enemiesSpawned <= heliThreshold)
                                            {
                                                this.spawnSurvivalEnemyVehicle();
                                            }
                                            else if (gameData.enemiesSpawned <= (wave / 5))
                                            {
                                                this.spawnSurvivalEnemyCharacter();
                                                gameData.enemiesSpawned++;
                                            }
                                            else
                                            {
                                                this.spawnSurvivalEnemyDinosaur();
                                                gameData.enemiesSpawned++;
                                            }
                                        }
                                        else
                                        {
                                            if (wave == 18)
                                            {
                                                if (this.Random(1, 5) == 1)
                                                {
                                                    this.spawnSurvivalEnemyCharacter();
                                                    gameData.enemiesSpawned++;
                                                }
                                                else
                                                {
                                                    this.spawnSurvivalEnemyDinosaur();
                                                    gameData.enemiesSpawned++;
                                                }
                                            }
                                            if (wave == 12)
                                            {
                                                if (gameData.enemiesSpawned < 5)
                                                {
                                                    this.spawnSurvivalEnemyTurret();
                                                }
                                                else
                                                {
                                                    this.spawnSurvivalEnemyDinosaur();
                                                    gameData.enemiesSpawned++;
                                                }
                                            }
                                            else if (wave == 3)
                                            {
                                                if (gameData.enemiesSpawned == 0)
                                                {
                                                    this.spawnSurvivalEnemyVehicle();
                                                }
                                                else
                                                {
                                                    this.spawnSurvivalEnemyDinosaur();
                                                    gameData.enemiesSpawned++;
                                                }
                                            }
                                            else if (wave > 5 && this.Random(1, Math.max(5, 30 - wave)) == 1)
                                            {
                                                if (this.getNumHelicoptersOnTeam(0) >= 3)
                                                {
                                                    this.spawnSurvivalEnemyTurret();
                                                }
                                                else if (this.Random(1, (wave < 20 ? 2 : 1)) == 1)
                                                {
                                                    this.spawnSurvivalEnemyVehicle();
                                                }
                                                else
                                                {
                                                    this.spawnSurvivalEnemyTurret();
                                                }
                                            }
                                            else if (wave > 5 && this.Random(1, Math.max(10, 40 - wave)) == 1)
                                            {
                                                this.spawnSurvivalEnemyEgg();
                                            }
                                            else if (this.Random(1, 2) == 1)
                                            {
                                                this.spawnSurvivalEnemyDinosaur();
                                                gameData.enemiesSpawned++;
                                            }
                                            else
                                            {
                                                this.spawnSurvivalEnemyCharacter();
                                                gameData.enemiesSpawned++;
                                            }
                                        }
                                        break;
                                    case GameMode.SURVIVAL_DINO:
                                        if (wave % 5 == 0 && wave > 25 && wave % 25 != 0)
                                        {
                                            this.spawnSurvivalEnemyEgg();
                                        }
                                        else if (wave > 5 && wave % 5 != 0 && this.Random(1, Math.max(10, 50 - wave)) == 1)
                                        {
                                            this.spawnSurvivalEnemyEgg();
                                        }
                                        else
                                        {
                                            this.spawnSurvivalEnemyDinosaur();
                                            gameData.enemiesSpawned++;
                                        }
                                        break;
                                    case GameMode.SURVIVAL_MILITIA:
                                        if (wave % 5 == 0)
                                        {
                                            let heliThreshold = Math.max(0, Math.min(5, (wave / 5) - 5));
                                            if (wave > 5 && gameData.enemiesSpawned <= heliThreshold)
                                            {
                                                this.spawnSurvivalEnemyVehicle();
                                            }
                                            else
                                            {
                                                this.spawnSurvivalEnemyCharacter();
                                                gameData.enemiesSpawned++;
                                            }
                                        }
                                        else
                                        {
                                            if (wave == 12)
                                            {
                                                this.spawnSurvivalEnemyTurret();
                                            }
                                            else if (wave == 3)
                                            {
                                                this.spawnSurvivalEnemyVehicle();
                                            }
                                            else if (wave > 5 && this.Random(1, Math.max(5, 30 - wave)) == 1)
                                            {
                                                if (this.getNumHelicoptersOnTeam(0) >= 3)
                                                {
                                                    this.spawnSurvivalEnemyTurret();
                                                }
                                                else if (this.Random(1, (wave < 20 ? 2 : 1)) == 1)
                                                {
                                                    this.spawnSurvivalEnemyVehicle();
                                                }
                                                else
                                                {
                                                    this.spawnSurvivalEnemyTurret();
                                                    //this.spawnSurvivalEnemyAirdrop();
                                                }
                                            }
                                            else
                                            {
                                                this.spawnSurvivalEnemyCharacter();
                                                gameData.enemiesSpawned++;
                                            }
                                        }
                                        break;
                                    case GameMode.SURVIVAL_ZOMBIE:
                                        if (wave > 25)
                                        {
                                            if (this.Random(1, 10) == 1)
                                            {
                                                this.spawnSurvivalEnemyDinosaur(null, false, [Dinosaur.PTERODACTYL]);
                                                gameData.enemiesSpawned++;
                                            }
                                            else
                                            {
                                                this.spawnSurvivalEnemyZombie();
                                                gameData.enemiesSpawned++;
                                            }
                                        }
                                        else
                                        {
                                            this.spawnSurvivalEnemyZombie();
                                            gameData.enemiesSpawned++;
                                        }
                                        break;
                                    case GameMode.SURVIVAL_CHICKEN:                                        
                                        this.spawnSurvivalEnemyChicken();
                                        gameData.enemiesSpawned++;
                                        break;
                                    case GameMode.SURVIVAL_PANDEMONIUM:
                                        let waveEnemyData = gameData.waveEnemyData;
                                        switch (waveEnemyData.type)
                                        {
                                            case ObjectType.DINOSAUR:
                                                this.spawnSurvivalEnemyDinosaur(null, false, [waveEnemyData.dinoType]);
                                                gameData.enemiesSpawned++;
                                                break;
                                            case ObjectType.CHARACTER:
                                                if (waveEnemyData.bBigfoot)
                                                {
                                                    this.spawnSurvivalEnemyBigfoot();
                                                }
                                                else if (waveEnemyData.bZombie)
                                                {
                                                    this.spawnSurvivalEnemyZombie(waveEnemyData.bJuggernaut);
                                                }
                                                else
                                                {
                                                    this.spawnSurvivalEnemyCharacter(waveEnemyData.bJuggernaut);
                                                }
                                                gameData.enemiesSpawned++;
                                                break;
                                            case ObjectType.HELICOPTER:
                                            case ObjectType.CAR:
                                            case ObjectType.TANK:
                                                this.spawnSurvivalEnemyVehicle([waveEnemyData.vehicleId]);
                                                break;
                                            case ObjectType.MOUNTED_WEAPON:
                                                this.spawnSurvivalEnemyTurret();
                                                break;
                                            default:
                                                console.warn(waveEnemyData.type);
                                                this.spawnSurvivalEnemyZombie();
                                                gameData.enemiesSpawned++;
                                                break;
                                        }
                                        break;
                                }

                            }
                            gameData.spawnTimer = gameData.spawnTimerMax;
                        }
                    }
                }
            }
            
            if (!this.matchHasEnded())
            {
                let supportItems = this.game.supportItems;
                if (supportItems)
                {
                    for (var i = supportItems.length - 1; i >= 0; i--)
                    {
                        let supportItem = supportItems[i];
                        if (!supportItem)
                        {
                            continue;
                        }
                        if (supportItem.explosions)
                        {
                            for (var j = 0; j < supportItem.explosions.length; j++)
                            {
                                let explosion = supportItem.explosions[j];
                                if (explosion.timer > 0)
                                {
                                    explosion.timer--;
                                }
                                else
                                {
                                    let explosionPos = supportItem.position;
                                    this.createExplosion({
                                        eventId: GameServer.EVENT_SPAWN_EXPLOSION,
                                        x: explosionPos[0] + this.Random(-25, 25),
                                        y: explosionPos[1] + this.Random(-25, 25),
                                        radius: supportItem.radius,
                                        damage: supportItem.damage,
                                        playerId: supportItem.playerId,
                                        team: supportItem.team,
                                        causerId: supportItem.playerId,
                                        weaponId: supportItem.id
                                    });
                                    if (explosion.bFire)
                                    {
                                        let napalm = this.getWeaponData("napalm");
                                        napalm.fireDamage = 25; 
                                        napalm.fireTime = 10; 
                                        for (var i = 0; i < 8; i++)
                                        {
                                            let flame = this.createFlame(explosionPos, [this.Random(-400, 400), this.Random(-400, 400)], supportItem.team, supportItem.playerId, napalm, 10, false, 1.5);
                                            flame.angle = this.RandomAngle();
                                        }
                                    }
                                    supportItem.explosions.splice(j, 1);
                                }
                            }
                        }
                        if (supportItem.timer > 0)
                        {
                            supportItem.timer--;
                        }
                        else
                        {
                            switch (supportItem.id == Item.DEADSWITCH)
                            {
                                //...
                            }
                            supportItems.splice(i, 1);
                        }
                    }
                }

                //Update map nodes
                if (this.game.nodesToCheck)
                {
                    let nodesPerTick = this.game.bMultiplayer ? 10 : 100;
                    for (let n = 0; n < nodesPerTick; n++)
                    {                        
                        let node = this.game.nodesToCheck[0];
                        if (node)
                        {
                            this.checkPathNodeAtNode(node[0], node[1]);
                        }
                        if (this.game.nodesToCheck.length > 0)
                        {
                            this.game.nodesToCheck.splice(0, 1);
                        }
                        if (!this.game.nodesToCheck.length)
                        {
                            delete this.game.nodesToCheck;
                            delete this.game.numNodesToCheck;
                            this.onEvent({
                                eventId: GameServer.EVENT_GAME_UPDATE,
                                data: {
                                    bGeneratingNodes: false
                                }
                            });
                            this.dispatchTrigger({ event: "nodesGenerated" });
                            break;
                        }
                        else
                        {
                            this.onEvent({
                                eventId: GameServer.EVENT_GAME_UPDATE,
                                data: {
                                    nodeProgress: 1 - (this.game.nodesToCheck.length / this.game.numNodesToCheck)
                                }
                            });
                        }
                    }
                }
            }

            var flames = [];
            var dropped = [];
            var money = [];
            var arrows = [];
            var vehicles = [];
            var cars = [];
            for (var key in this.game.objects)
            {
                let body = this.game.objects[key];
                if (!body)
                {
                    continue;
                }
                let data = body.data;
                if (!data || data.bPendingRemoval)
                {
                    continue;
                }
                if (data.destroyTimer != null)
                {
                    data.destroyTimer--;
                    if (data.crateType == Crate.STORE)
                    {
                        this.pushObjectDataUpdate(data.id, ["destroyTimer"]);
                    }
                    if (data.destroyTimer <= 0)
                    {
                        this.removeNextStep(body);
                    }
                }
                if (data.bStunned)
                {
                    if (data.stunTimer > 0)
                    {
                        data.stunTimer--;
                    }
                    else
                    {
                        data.bStunned = false;
                        this.onEvent({
                            eventId: GameServer.EVENT_PAWN_ACTION,
                            pawnId: data.id,
                            type: GameServer.PAWN_STUN,
                            bValue: false
                        });
                    }
                }
                if (data.bFlashed)
                {
                    if (data.flashTimer > 0)
                    {
                        data.flashTimer--;
                    }
                    else
                    {
                        data.flashIntensity = null;
                        data.bFlashed = false;
                        this.onEvent({
                            eventId: GameServer.EVENT_PAWN_ACTION,
                            pawnId: data.id,
                            type: GameServer.PAWN_FLASH,
                            bValue: false
                        });
                    }
                }
                if (data.attachToId)
                {
                    let attachToObject = this.getObjectById(data.attachToId);
                    if (attachToObject)
                    {
                        body.position[0] = attachToObject.position[0];
                        body.position[1] = attachToObject.position[1];
                    }
                } 
                if (data.bRegenHealth && data.health > 0)
                {
                    let bRegen = false;
                    let regenThreshold = data.maxHealth * (data.regenThreshold != null ? data.regenThreshold : 1);
                    if (data.health < regenThreshold)
                    {
                        if (data.regenTimer <= 0)
                        {
                            let regenAmount = data.regenAmount ? data.regenAmount : 1;
                            regenAmount = regenAmount / this.game.fpsMult;
                            if (this.isNearHealthBox(body))
                            {
                                regenAmount *= 2;
                            }
                            data.health = Math.min(data.maxHealth, data.health + regenAmount);
                            this.pushObjectDataUpdate(data.id, ["health"]);                            
                            bRegen = true;
                            if (data.damagedBy)
                            {
                                delete data.damagedBy;
                            }
                        }
                        else
                        {
                            data.regenTimer = Math.max(0, data.regenTimer - (this.isNearHealthBox(body) ? 5 : 1));
                        }
                    }
                    this.setDataValue(body, "bRegen", bRegen);
                }
                if (this.isVehicle(body) && !data.bDisabled)
                {
                    vehicles.push(body);
                }
                switch (data.type)
                {
                    case ObjectType.GROUND:
                    case ObjectType.TREE:
                        break;
                    case ObjectType.SPAWNER:
                        this.handleSpawner(body);
                        break;
                    case ObjectType.REVIVER:
                        this.handleReviver(body);
                        break;
                    case ObjectType.DOOR:
                        this.handleDoor(body);
                        break;
                    case ObjectType.SHIELD:
                        this.handleShield(body);
                        break;
                    case ObjectType.CRATE:
                        this.handleCrate(body);
                        break;
                    case ObjectType.FLAME:
                        flames.push(body);
                        this.handleFlame(body);
                        break;
                    case ObjectType.MONEY:
                        money.push(body);
                        this.handleMoney(body);
                        break;
                    case ObjectType.ARROW:
                        arrows.push(body);
                        this.handleArrow(body);
                        break;
                    case ObjectType.EGG:
                        this.handleEgg(body);
                        break;
                    case ObjectType.CHARACTER:
                        this.handlePawn(body);
                        if (data.bBot && this.matchInProgress())
                        {
                            this.handleAICharacter(body);
                        }
                        break;
                    case ObjectType.DINOSAUR:
                    case ObjectType.FLYING_DINOSAUR:
                        this.handleDinosaur(body);
                        if (data.bBot && this.matchInProgress())
                        {
                            this.handleAICharacter(body);
                        }
                        break;
                    case ObjectType.HELICOPTER:
                        this.handleHelicopter(body);
                        break;
                    case ObjectType.TANK:
                        this.handleTank(body);
                        break;
                    case ObjectType.CAR:
                        cars.push(body);
                        this.handleCar(body);
                        break;
                    case ObjectType.MOUNTED_WEAPON:
                        this.handleMountedWeapon(body);
                        break;
                    case ObjectType.ROCKET:
                        this.handleRocket(body);
                        break;
                    case ObjectType.GRENADE:
                        this.handleGrenade(body);
                        break;
                    case ObjectType.EQUIPMENT:
                        this.handleEquipment(body);
                        break;
                    case ObjectType.OBSTACLE:
                        if (data.detonationTimer > 0)
                        {
                            data.detonationTimer--;
                            if (data.detonationTimer <= 0)
                            {
                                this.detonate(body);
                            }
                        }
                        break;
                    case ObjectType.FLAG:
                        if (this.matchInProgress())
                        {
                            switch (data.flagType)
                            {
                                case GameMode.DOMINATION:
                                    this.handleDominationFlag(body);
                                    break;
                                default:
                                    this.handleFlag(body);
                                    break;
                            }
                        }
                        break;
                    case ObjectType.EMITTER:
                        this.handleEmitter(body);
                        break;
                    case ObjectType.TRIGGER_AREA:
                        this.handleTriggerArea(body);
                        break;
                    case ObjectType.DROPPED_WEAPON:
                        if (!data.bPersistent)
                        {
                            dropped.push(body);
                        }
                        if (this.isOutOfMap(body))
                        {
                            this.removeNextStep(body);
                        }
                        break;
                    default:
                        if (this.isOutOfMap(body))
                        {
                            this.removeNextStep(body);
                        }
                        break;
                }
                if (!data.bSkipServerUpdate)
                {
                    if (!this.game.objectsToUpdate)
                    {
                        this.game.objectsToUpdate = {};
                    }
                    let toUpdate = this.game.objectsToUpdate;
                    let id = data.id;
                    if (!toUpdate[id])
                    {
                        toUpdate[id] = [];
                    }
                    let arr = toUpdate[id];
                    let objData = {}; //this.clone(data);
                    objData.id = id;
                    if (!body.previousPosition || Math.round(body.position[0]) != Math.round(body.previousPosition[0]) || Math.round(body.position[1]) != Math.round(body.previousPosition[1]))
                    {
                        if (this.CheckValidArray(body.position))
                        {
                            objData.position = this.RoundNumberArray(body.position);
                        }
                    }
                    if (this.CheckValidArray(body.velocity) && (body.velocity[0] != 0 || body.velocity[1] != 0)) //body.mass != Number.MAX_VALUE
                    {
                        objData.velocity = this.RoundNumberArray(body.velocity);
                    }
                    if (!body.previousAngle || body.previousAngle != body.angle)
                    {
                        objData.rotation = body.angle;
                    }
                    if (data.bWantsToMove != null)
                    {
                        objData.bWantsToMove = data.bWantsToMove;
                    }
                    if (data.lookPos != null)
                    {
                        objData.lookPos = data.lookPos;
                    }
                    if (data.desiredAimRotation != null)
                    {
                        objData.desiredAimRotation = data.desiredAimRotation;
                    }
                    if (data.destroyTimer != null)
                    {
                        objData.destroyTimer = data.destroyTimer;
                    }
                    let keys = Object.keys(objData);
                    if (keys.length > 1)
                    {
                        arr.push(objData);
                    }
                }                
            }

            //console.log("Updating", Object.keys(this.game.objectsToUpdate).length);

            if (flames.length > this.settings.maxFlames)
            {
                this.removeNextStep(flames[0]);
            }            
            if (dropped.length > this.settings.maxDroppedWeapons)
            {
                this.removeNextStep(dropped[0]);
            }
            if (money.length > this.settings.maxPickups)
            {
                this.removeNextStep(money[0]);
            }
            else if (arrows.length > this.settings.maxPickups)
            {
                this.removeNextStep(arrows[0]);
            }
            if (vehicles.length > this.settings.maxVehicles)
            {
                for (var i = 0; i < vehicles.length; i++)
                {
                    let veh = vehicles[i];
                    if (!veh.data.bPendingRemoval && !this.vehicleHasOccupant(veh))
                    {
                        console.log("Remove vehicle", i, veh.data.type, this.settings.maxVehicles);
                        this.removeNextStep(veh);
                        break;
                    }
                }
            }
            if (this.game.actionQueue)
            {
                for (var i = 0; i < this.game.actionQueue.length; i++)
                {
                    let delayItem = this.game.actionQueue[i];
                    let action = delayItem.action;
                    if (action.delay > 0)
                    {
                        if (delayItem.delayTimer > 0)
                        {
                            delayItem.delayTimer--;
                        }
                        else
                        {
                            delete action.delay;
                            action.delay = delayItem.delay;
                            this.executeTriggerAction(action, delayItem.params);
                            this.game.actionQueue.splice(i, 1);
                        }
                    }
                }
            }
            this.handleCinematic();
            this.dispatchTrigger({
                event: "gameTick"
            });
            if (this.game.updateTimer == 1)
            {
                if (this.game.objectsToUpdate)
                {
                    var ids = Object.keys(this.game.objectsToUpdate);
                    var tmp = {};
                    var numIds = ids.length;
                    for (i = 0; i < numIds; i++)
                    {
                        let curObjectId = ids[i];
                        if (!curObjectId)
                        {
                            continue;
                        }
                        let objectUpdates = this.game.objectsToUpdate[curObjectId];
                        if (!objectUpdates)
                        {
                            continue;
                        }
                        //Save last object data for next batch update
                        let curData = objectUpdates[objectUpdates.length - 1];
                        if (!curData)
                        {
                            continue;
                        }
                        tmp[curObjectId] = curData.data;

                        //Check duplicate keys in object data
                        if (objectUpdates.length == this.game.settings.updateTimerMax)
                        {
                            var newArr = [];
                            for (var j = 0; j < objectUpdates.length; j++)
                            {
                                let curUpdate = objectUpdates[j];
                                let targetData = null;
                                let newUpdate = null;
                                if (j > 0)
                                {
                                    targetData = objectUpdates[j - 1].data;
                                }
                                else
                                {
                                    //Should check against tmp object's last element
                                    let prevObjectData = this.game.prevObjectData;
                                    if (prevObjectData)
                                    {
                                        targetData = prevObjectData[curUpdate.id];
                                    }
                                }
                                if (targetData)
                                {
                                    let newData = null; //this.removeDuplicateKeys(curUpdate.data, targetData);
                                    if (newData)
                                    {
                                        let newUpdate = this.clone(curUpdate);
                                        newUpdate.data = newData;
                                        newArr.push(newUpdate);
                                    }
                                }
                                if (!newUpdate)
                                {
                                    this.optimize(curUpdate);
                                    newArr.push(curUpdate);
                                }
                            }
                            if (newArr && newArr.length > 0)
                            {
                                this.game.objectsToUpdate[curObjectId] = newArr;
                            }
                        }
                    }
                    this.onEvent({
                        eventId: GameServer.EVENT_OBJECT_UPDATE,
                        objects: this.game.objectsToUpdate
                    });
                    this.game.prevObjectData = tmp;
                    delete this.game.objectsToUpdate;
                }
                this.game.updateTimer = this.game.settings.updateTimerMax;
            }
            else
            {
                this.game.updateTimer--;
            }      

            var world = this.game.world;
            var timeSinceLastCall = 0;
            var timeMilliseconds = Date.now();
            var maxSubSteps = Math.max(1, this.game.gameSettings.maxSubSteps ? this.game.gameSettings.maxSubSteps : (this.game.bMultiplayer ? 4 : 1));
            if (this.game.resetCallTime)
            {
                timeSinceLastCall = 0;
                this.game.resetCallTime = false;
            }
            else
            {
                if (timeMilliseconds !== undefined && this.game.lastTimeMilliseconds !== undefined)
                {
                    timeSinceLastCall = (timeMilliseconds - this.game.lastTimeMilliseconds) / 1000;
                }
            }
            if (this.game.bMultiplayer && timeSinceLastCall > 1)
            {
                console.warn("timeSinceLastCall:", timeSinceLastCall);
                this.onGameError(new Error("Game tick timeout"), 0);
                return;
            }
            world.step(this.game.frameRate, timeSinceLastCall, maxSubSteps);
            this.game.lastTimeMilliseconds = timeMilliseconds;            
            if (this.matchInProgress() && !this.game.nodeBodies && !this.game.gameSettings.tickRate && timeSinceLastCall > 0)
            {
                if (!this.game.msTracker)
                {
                    this.game.msTracker = [];
                }
                if (this.game.msTracker.length < (this.game.settings.fps * 2))
                {
                    this.game.msTracker.push(timeSinceLastCall);
                }
                else
                {
                    var avg = 0;
                    for (var i = 0; i < this.game.msTracker.length; i++)
                    {
                        avg += this.game.msTracker[i];
                    }
                    avg = avg / this.game.msTracker.length; 
                    var bestTime = 1000 / this.game.settings.fps / 1000;
                    var maxTime = bestTime * 1.35;
                    if (avg > maxTime)
                    {
                        this.setTickRate(30);
                    }
                    else
                    {
                        //this.setTickRate(60);
                    }
                    this.game.msTracker = [];
                }
            }

            while (this.game.toRemove.length > 0)
            {
                var toRemove = this.game.toRemove[0];
                if (toRemove && toRemove.data)
                {
                    var removeId = toRemove.data.id;
                    this.removeObject(toRemove);
                    this.onRemove(removeId);
                }
                this.game.toRemove.splice(0, 1);
            }
        }
        this.sendBatchData();
    }

    setTickRate(_val)
    {
        var prev = this.game.settings.fps;
        var fps = _val != null ? Math.min(Math.max(1, _val), 60) : 60;
        this.game.settings.fps = fps;
        this.game.settings.updateTimerMax = Math.ceil(fps / (this.game.settings.updateRate != null ? this.game.settings.updateRate : 60));
        this.game.timestepMult = fps / 60;
        this.game.fpsMult = fps / 60;
        if (prev != fps)
        {
            console.log("New tick rate:", fps);
            clearInterval(this.game.interval);
            this.game.interval = setInterval(() => { this.tick(); }, 1000 / this.game.settings.fps);
            this.onTickRateChanged(fps / prev);
            this.onEvent({
                eventId: GameServer.EVENT_GAME_UPDATE,
                data: {
                    tickRate: fps
                }
            });
            this.triggerCallback("chat", {
                messageText: "Tick rate set to " + fps,
                bServer: true
            });
        }
    }

    onRemove(_id)
    {
        this.dispatchTrigger({ event: "objectRemoved", objectId: _id });
        switch (this.game.gameModeId)
        {
            case GameMode.EVOLUTION:
                if (this.game.gameModeData.bEvolve)
                {
                    delete this.game.gameModeData.bEvolve;
                    var ps = this.getPlayerById(_id);
                    if (ps && ps.team == 1)
                    {
                        this.respawnPlayer(ps.id, { position: this.game.gameModeData.dinoPos });
                        if (ps.respawnData)
                        {
                            delete ps.respawnData.position;
                        }
                    }
                }
                break;
        }
    }

    isOutOfMap(_body, _bCheckWalls)
    {
        if (_body)
        {
            var map = this.getCurrentMapData();
            if (map)
            {                
                if (_body.position[0] < 0 || _body.position[0] > this.getMapWidth() || _body.position[1] > this.getMapHeight() || isNaN(_body.position[0]) || isNaN(_body.position[1]))
                {
                    return true;
                }
                if (_bCheckWalls && this.bodyIsInWall(_body))
                {
                    return true;
                }
            }
        }
        return false;
    }

    isOutOfHelicopterArea(_body)
    {
        if (_body)
        {
            var map = this.getCurrentMapData();
            if (map)
            {
                if (_body.position[0] < 0 || _body.position[0] > this.getMapWidth() || _body.position[1] > this.getMapHeight() || isNaN(_body.position[0]) || isNaN(_body.position[1]))
                {
                    return true;
                }
            }
        }
        return false;
    }

    removeDuplicateKeys(_source, _target)
    {
        if (_source && _target)
        {
            var newData = {};
            var sourceKeys = Object.keys(_source);
            for (var i = 0; i < sourceKeys.length; i++)
            {
                var sourceKey = sourceKeys[i];
                var sourceValue = _source[sourceKey];
                if (typeof sourceValue === "boolean")
                {
                    sourceValue = sourceValue ? 1 : 0;
                }
                else if (typeof sourceValue === "number" && sourceValue % 1 != 0)
                {
                    sourceValue = this.RoundDecimal(sourceValue);
                }
                switch (sourceKey)
                {
                    default:
                        var target = _target[sourceKey];
                        if (typeof target === "boolean")
                        {
                            target = target ? 1 : 0;
                        }
                        if (target !== sourceValue)
                        {
                            newData[sourceKey] = sourceValue;
                        }
                        break;
                }
            }
            if (newData)
            {
                return newData;
            }
        }
        else
        {
            console.warn("removeDuplicateKeys: Invalid source or target reference");
        }
        return null;
    }

    updateNodesForBody(_body)
    {
        var arr = this.getNodesForObject(_body);
        var numChanged = 0;
        var numNodes = arr.length;
        for (let i = 0; i < numNodes; i++)
        {
            let pos = arr[i];
            let res = this.checkPathNodeAtNode(pos[0], pos[1], true);
            if (res)
            {
                numChanged++;
            }
        }
    }

    addDirtyNodeObject(_body)
    {          
        this.checkDirtyNodeObject(_body.data.id);
        if (this.game.nodes)
        {
            this.updateNodesForBody(_body);
        }
    }

    checkDirtyNodeObject(_id)
    {
        let arr = this.game.nodeObjects[_id];
        if (arr)
        {            
            var numChanged = 0;
            for (var j = 0; j < arr.length; j++)
            {
                let pos = arr[j];
                var res = this.checkPathNodeAtNode(pos[0], pos[1]);
                if (res)
                {
                    numChanged++;
                }
            }
            if (numChanged > 0)
            {
                this.updateGraph();
            }
        }
    }

    removeDirtyNodeObject(_id)
    {
        this.checkDirtyNodeObject(_id);
    }

    checkDirtyNodeObjects()
    {
        for (var i = 0; i < this.game.dirtyNodeObjects.length; i++)
        {
            let id = this.game.dirtyNodeObjects[i];
            let arr = this.game.nodeObjects[id];
            if (arr)
            {
                for (var j = 0; j < arr.length; j++)
                {
                    let pos = arr[j];
                    var res = this.checkPathNodeAtNode(pos[0], pos[1]);
                    if (res)
                    {
                        numChanged++;
                    }
                    numChecked++;
                }
                if (numChanged > 0)
                {
                    this.updateGraph();
                }
            }      
        }
    }

    checkPathNodeAtNode(x, y, _bSkip)
    {
        var nodes = this.game.nodes; 
        try
        {
            var prev = nodes[x][y];
        }
        catch (e)
        {
            //console.log("Invalid node at", x, y, nodes);
            return false;
        }
        var threshold = this.game.nodeThreshold;
        var pos = [x * threshold, y * threshold];
        if (this.game.mapNodes.length > 0 && this.game.mapNodes[x] && this.game.mapNodes[x][y] == 0)
        {
            nodes[x][y] = 0; //Static wall that can never be accessible, predefined in map file
        }
        else if (nodes[x][y] === 0 && _bSkip)
        {
            //Already checked this node
        }
        else
        {
            let bodiesToCheck = this.getNodeBodies(pos);
            nodes[x][y] = 1;
            let padding = this.game.nodeThreshold * 0.25;
            let arr = [pos];
            /*
            let arr = [
                pos,
                [pos[0] - padding, pos[1] - padding],
                [pos[0] + padding, pos[1] - padding],
                [pos[0] + padding, pos[1] + padding]
                [pos[0] - padding, pos[1] - padding]
            ];
            */
            mainLoop: for (let c = 0; c < arr.length; c ++)
            {
                if (nodes[x][y] == 0)
                {
                    break;
                }
                let curPos = arr[c];
                let bodies = this.game.world.hitTest(curPos, bodiesToCheck, 1);
                if (bodies)
                {
                    let numBodies = bodies.length;
                    bodyLoop: for (let i = 0; i < numBodies; i++)
                    {
                        let body = bodies[i];
                        if (body && body.data && !body.data.bBounds && !body.data.bPendingRemoval && !body.data.bNoBody && body.shapes.length)
                        {
                            let data = body.data;
                            switch (data.type)
                            {
                                case ObjectType.GROUND:
                                    nodes[x][y] = 0;
                                    if (data.spriteId)
                                    {
                                        if (!this.game.mapNodes[x])
                                        {
                                            this.game.mapNodes[x] = [];
                                        }
                                        this.game.mapNodes[x][y] = 0;
                                    }
                                    break;
                                case ObjectType.OBSTACLE:
                                case ObjectType.MOUNTED_WEAPON:
                                    nodes[x][y] = 0;
                                    break;
                                case ObjectType.CRATE:
                                    if (body.mass == Number.MAX_VALUE || data.crateType == Crate.BOMB)
                                    {
                                        nodes[x][y] = 0;
                                    }
                                    break;
                                case ObjectType.CAR:
                                case ObjectType.TANK:
                                case ObjectType.HELICOPTER:
                                    if (body.mass == Number.MAX_VALUE || data.bDisabled)
                                    {
                                        nodes[x][y] = 0;
                                    }
                                    break;
                                case ObjectType.DOOR:
                                    if (data.bDisabled && data.bClosed)
                                    {
                                        nodes[x][y] = 0;
                                    }
                                    break;
                            }
                            if (nodes[x][y] == 0 || data.type == ObjectType.DOOR)
                            {
                                if (data.id)
                                {
                                    if (!this.game.nodeObjects[data.id])
                                    {
                                        this.game.nodeObjects[data.id] = [];
                                    }
                                    let pos = [x, y];
                                    let arr = this.game.nodeObjects[data.id];
                                    let bAdd = true;
                                    arrLoop: for (let j = 0; j < arr.length; j++)
                                    {
                                        let cur = arr[j];
                                        if (cur[0] == pos[0] && cur[1] == pos[1])
                                        {
                                            bAdd = false;
                                            break arrLoop;
                                        }
                                    }
                                    if (bAdd)
                                    {
                                        arr.push(pos);
                                    }
                                }
                                else
                                {
                                    console.warn("Missing id", data.type);
                                }
                                break mainLoop;
                            }
                        }
                    }
                }
            }
        }
        return nodes[x][y] != prev;
    }

    generateCurrentNode()
    {
        if (!this.game.nodeBodies)
        {
            return;
        }
        try
        {
            var object = this.game.nodeBodies[this.game.nodeBodyIndex];
            var arr = this.getNodesForObject(object);
            var numChanged = 0;
            var numNodes = arr.length;
            for (let j = 0; j < numNodes; j++)
            {
                let pos = arr[j];
                let res = this.checkPathNodeAtNode(pos[0], pos[1], true);
                if (res)
                {
                    numChanged++;
                }
            }
            this.game.nodeBodyIndex++;
            if (this.game.nodeBodyIndex > this.game.nodeBodies.length - 1)
            {
                console.log("Map node generation complete");
                this.onEvent({
                    eventId: GameServer.EVENT_GAME_UPDATE,
                    data: {
                        bGeneratingNodes: false
                    }
                });
                delete this.game.nodeBodies;
                delete this.game.nodeBodyIndex;
                this.updateGraph();
            }
        }
        catch (e)
        {
            this.onGameError(e);
        }
    }

    generateMapNodes()
    {
        this.log("generateMapNodes");  
        var map = this.getCurrentMapData();
        if (!this.game.mapNodes)
        {
            if (this.game.scenario && this.game.scenario.nodes)
            {
                this.game.mapNodes = this.clone(this.game.scenario.nodes);
            }
            else
            {
                this.game.mapNodes = map.ai.nodes ? this.clone(map.ai.nodes) : [];
            }
        }
        var bInitNodes = this.bInit || this.game.scenario || this.game.bGeneratingMap;
        if (!this.game.nodes)
        {
            this.game.nodes = bInitNodes ? [] : this.clone(this.game.mapNodes);
        }
        if (bInitNodes)
        {
            this.initNodes();
        }
        this.game.nodesToCheck = [];
        var num = 0;
        var numChanged = 0;
        var objects = this.getTypes([
            ObjectType.GROUND,
            ObjectType.OBSTACLE,
            ObjectType.MOUNTED_WEAPON,
            ObjectType.CRATE,
            ObjectType.CAR,
            ObjectType.TANK,
            ObjectType.HELICOPTER,
            ObjectType.DOOR
        ]);
        for (var i = 0; i < objects.length; i ++)
        {
            let body = objects[i];
            let data = body.data;
            if (body.data && !body.data.bPendingRemoval && !data.bNoBody && body.shapes.length)
            {                
                let bAdd = false;
                switch (data.type)
                {
                    case ObjectType.GROUND:
                        if (data.spriteId || data.shape)
                        {
                            bAdd = true;
                        }
                        break;
                    case ObjectType.OBSTACLE:
                        bAdd = true;
                        break;
                    case ObjectType.MOUNTED_WEAPON:
                        bAdd = true;
                        break;
                    case ObjectType.CRATE:
                    case ObjectType.CAR:
                    case ObjectType.TANK:
                    case ObjectType.HELICOPTER:
                        if (body.mass == Number.MAX_VALUE || data.bDisabled)
                        {
                            bAdd = true;
                        }
                        break;
                    case ObjectType.DOOR:
                        bAdd = true;
                        break;
                    default:
                        bAdd = false;
                        break;
                }
                if (bAdd)
                {
                    let nodes = this.getNodesForObject(body);
                    for (let j = 0; j < nodes.length; j ++)
                    {
                        let node = nodes[j];
                        try
                        {
                            if (this.nodeExists(node))
                            {
                                continue;
                            }
                            let nodeVal = this.game.nodes[node[0]][node[1]];
                            if (nodeVal != 0)
                            {
                                this.game.nodesToCheck.push(node);
                                /*
                                let res = this.checkPathNodeAtNode(node[0], node[1]);
                                if (res) numChanged++;
                                */
                                num++;
                            }
                        }
                        catch (e)
                        {
                            //this.log("Invalid node: " + node);
                        }
                    }
                }
            }
        }
        this.game.numNodesToCheck = this.game.nodesToCheck.length;
        this.onEvent({
            eventId: GameServer.EVENT_GAME_UPDATE,
            data: {
                bGeneratingNodes: true,
                nodeProgress: 0
            }
        });
        this.dispatchTrigger({ event: "nodesGenerating" });
        this.onNodesGenerated();
    }    

    nodeExists(_node)
    {
        if (this.game.nodesToCheck)
        {
            for (var i = 0; i < this.game.nodesToCheck.length; i++)
            {
                let node = this.game.nodesToCheck[i];
                if (node[0] == _node[0] && node[1] == _node[1])
                {
                    return true;
                }
            }
        }
        return false;
    }

    initNodes()
    {
        console.log("Init nodes...");
        var nodes = this.game.nodes;
        var threshold = this.game.nodeThreshold;
        var numX = Math.floor(this.getMapWidth() / threshold);
        var numY = Math.floor(this.getMapHeight() / threshold);
        for (let y = 0; y < numY; y++)
        {
            for (let x = 0; x < numX; x++)
            {
                if (!nodes[x]) nodes[x] = [];
                if (nodes[x][y] == null) nodes[x][y] = 1;
            }
        }   
    }

    getNodesForObject(_body)
    {
        if (!_body)
        {
            return [];
        }
        var arr = [];
        var threshold = this.game.nodeThreshold;
        var aabb = _body.getAABB();
        if (aabb)
        {
            var maxX = Math.ceil(this.getMapWidth() / threshold);
            var maxY = Math.ceil(this.getMapHeight() / threshold);
            var padding = 0;
            var topLeftNode = [Math.floor((aabb.lowerBound[0] - padding) / threshold), Math.floor((aabb.lowerBound[1] - padding) / threshold)];
            var bottomRightNode = [Math.ceil((aabb.upperBound[0] + padding) / threshold), Math.ceil((aabb.upperBound[1] + padding) / threshold)];
            for (var x = topLeftNode[0] - 1; x < bottomRightNode[0] + 1; x++)
            {
                for (var y = topLeftNode[1] - 1; y < bottomRightNode[1] + 1; y++)
                {
                    if (x >= 0 && x <= maxX && y >= 0 && y <= maxY)
                    {
                        arr.push([x, y]);
                    }                    
                }
            }
        }
        return arr;
    }

    getAIBestDominationFlag(_body)
    {
        var data = _body.data;
        var flags = this.getFlags();
        var curFlag = null;
        var dist = Number.MAX_VALUE;
        var bFlag = false;
        for (var i = 0; i < flags.length; i++)
        {
            var flag = flags[i];
            if (flag.data.team != data.team)
            {
                var flagDist = this.Dist(_body.position[0], _body.position[1], flag.position[0], flag.position[1]);
                if (flagDist < dist)
                {
                    bFlag = true;
                    curFlag = flag;
                    dist = flagDist;
                }
            }
        }
        if (!bFlag)
        {
            return flags[this.Random(0, flags.length - 1)];
        }
        return curFlag;
    }

    setLocalPlayerCamera(_camera)
    {
        if (!this.game.bMultiplayer)
        {
            var player = this.getObjectById("player");
            var scale = _camera.scale;
            var cameraBoundsLeft = _camera.x;
            var cameraBoundsRight = _camera.x + (_camera.width / scale);
            var cameraBoundsTop = _camera.y;
            var cameraBoundsBottom = _camera.y + (_camera.height / scale);
            var objects = this.getTypes([
                ObjectType.OBSTACLE
            ]);
            for (var i = 0; i < objects.length; i++)
            {
                let body = objects[i];
                let data = body ? body.data : null;                  
                if (data && !data.bNoBody && !data.bPendingRemoval && body.shapes.length)
                {
                    let pos = body.position;
                    let playerDist = player ? this.DistBodies(player, body) : Number.MAX_VALUE;
                    switch (data.type)
                    {
                        case ObjectType.GROUND:
                            if (playerDist > 2000 && (pos[0] < cameraBoundsLeft || pos[0] > cameraBoundsRight || pos[1] < cameraBoundsTop || pos[1] > cameraBoundsBottom))
                            {
                                this.removeBodyFromWorld(body);
                            }
                            else
                            {
                                this.addBodyToWorld(body);
                            }
                        case ObjectType.OBSTACLE:
                            if (!body.data.bBlockLOS && playerDist > 1000 && (pos[0] < cameraBoundsLeft || pos[0] > cameraBoundsRight || pos[1] < cameraBoundsTop || pos[1] > cameraBoundsBottom))
                            {
                                this.removeBodyFromWorld(body);
                            }
                            else
                            {
                                this.addBodyToWorld(body);
                            }
                            break;
                    }
                }
            }
        }
    }

    removeBodyFromWorld(_body)
    {
        if (_body && _body.world)
        {
            this.game.world.removeBody(_body);
            return true;
        }
        return false;
    }

    addBodyToWorld(_body)
    {
        if (_body && !_body.world)
        {
            this.game.world.addBody(_body);
            return true;
        }
        return false;
    }

    randomizeAStarNodes(_nodes)
    {
        var nodes = this.clone(_nodes);
        for (var i = 0; i < nodes.length; i++)
        {
            var row = nodes[i];
            for (var j = 0; j < row.length; j++)
            {
                var cur = row[j];
                if (cur == 1)
                {
                    row[j] = this.Random(1, 10);
                }
            }
        }
        return nodes;
    }

    updateGraph()
    {
        /*
        try
        {
            var Graph = this.data.astarGraph;
            this.game.graph = new Graph(this.game.nodes);
        }
        catch (e)
        {
            console.warn(e);
        }
        */
    }

    getAStarPath(_nodes, _startX, _startY, _endX, _endY)
    {       
        var path = []; 
        var result;
        if (_nodes && _nodes.length > 0)
        {
            var threshold = this.game.nodeThreshold;
            try
            {
                var Graph = this.data.astarGraph;
                var graph = this.game.graph ? this.game.graph : (new Graph(_nodes)); //this.game.graph;
                var startPosX = Math.round(_startX / threshold);
                var startPosY = Math.round(_startY / threshold);
                var endPosX = Math.round(_endX / threshold);
                var endPosY = Math.round(_endY / threshold);
                var start = this.getNearestValidNode(_nodes, { x: startPosX, y: startPosY });
                var end = this.getNearestValidNode(_nodes, { x: endPosX, y: endPosY });
                var startNode = graph.grid[start.x][start.y];
                var endNode = graph.grid[end.x][end.y];
                result = this.data.astar.search(graph, startNode, endNode, { heuristic: this.data.astar.heuristics.diagonal });
            }
            catch (e)
            {
                result = null;
                //console.warn(e);
            }
            if (result)
            {
                for (var i = 0; i < result.length; i++)
                {
                    var cur = result[i];
                    path.push({ data: { position: [cur.x * threshold, cur.y * threshold] } });
                }
            }
        }
        else
        {
            //console.warn("Invalid nodes", _nodes);
        }
        path.push({
            data: {
                position: [_endX, _endY]
            }
        });
        return path;
    }

    getNearestValidPosition(_pos)
    {
        var threshold = this.game.nodeThreshold;
        var startPosX = Math.round(_pos[0] / threshold);
        var startPosY = Math.round(_pos[1] / threshold);
        var node = this.getNearestValidNode(this.game.nodes, { x: startPosX, y: startPosY });
        if (node)
        {
            return [node.x * threshold, node.y * threshold];
        }
        return _pos;
    }

    getNearestValidNode(_nodes, _pos)
    {
        try
        {
            _pos.x = Math.min(_nodes.length - 1, Math.max(0, _pos.x));
            _pos.y = Math.min(_nodes[0].length - 1, Math.max(0, _pos.y));
            if (_nodes[_pos.x][_pos.y] == 0)
            {
                for (var i = 1; i < 10; i++)
                {
                    var nodesToTry = [
                        { x: _pos.x, y: _pos.y + i },
                        { x: _pos.x, y: _pos.y - i },
                        { x: _pos.x + i, y: _pos.y },
                        { x: _pos.x + i, y: _pos.y + i },
                        { x: _pos.x - i, y: _pos.y },
                        { x: _pos.x - i, y: _pos.y - i },
                        { x: _pos.x + i, y: _pos.y - i },
                        { x: _pos.x - i, y: _pos.y + i }
                    ];
                    for (var j = 0; j < nodesToTry.length; j++)
                    {
                        var cur = nodesToTry[j];
                        if (_nodes[cur.x] != null && _nodes[cur.x][cur.y] != 0)
                        {
                            _pos.x = cur.x;
                            _pos.y = cur.y;
                            return _pos;
                        }
                    }
                }
            }
        }
        catch (e)
        {
            console.warn(e);
        }
        return _pos;
    }

    getAIPath(_start, _destination, _body)
    {
        if (_body && _body.data.type == ObjectType.FLYING_DINOSAUR)
        {
            return [
                {
                    data: {
                        position: _destination
                    }
                }
            ]
        }
        return this.getAStarPath(this.game.nodes, _start[0], _start[1], _destination[0], _destination[1]);
    }

    initMap()
    {
        var map = this.getCurrentMapData();
        if (this.game.mapId == Map.GENERATED)
        {
            this.generateOpenWorldMap();
        }
        if (this.game.gameSettings.bAllowMapSelection)
        {
            this.game.gameSettings.bUseDefaultMapObjects = true;
        }
        if (!this.game.scenario || this.game.gameSettings.bUseDefaultMapObjects)
        {
            var objects = this.clone(map.objects);            
        }
        else
        {
            objects = [];            
        }      
        if (this.game.scenario)
        {
            if (this.game.gameSettings.bDisableTriggers)
            {
                this.game.scenario.triggers = [];
            }
            if (this.game.scenario.objects && !this.game.gameSettings.bUseDefaultMapObjects)
            {
                var scenarioObjects = this.game.scenario.objects;
                console.log("Scenario objects:", scenarioObjects.length);
                if (scenarioObjects.length > this.settings.maxScenarioObjects)
                {
                    console.warn("Exceeded max scenario objects:", scenarioObjects.length);
                    this.scenarioLog("[WARNING] Exceeded max scenario objects: " + scenarioObjects.length + "/" + this.settings.maxScenarioObjects, Colours.RED_STRING);
                }
                for (var i = Math.min(this.settings.maxScenarioObjects, scenarioObjects.length) - 1; i >= 0; i--)
                {
                    let object = scenarioObjects[i];
                    if (object.position)
                    {
                        if (object.position[0] > this.settings.maxWorldSize || object.position[0] < -this.settings.maxWorldSize || object.position[1] > this.settings.maxWorldSize || object.position[1] < -this.settings.maxWorldSize)
                        {
                            scenarioObjects.splice(i, 1);
                        }
                    }
                }
                objects = objects.concat(scenarioObjects);
            }
        }
        for (var i = 0; i < objects.length; i++)
        {
            this.checkSpecialStringsInObject(objects[i]);
            this.createObject(objects[i]);
        }        
    }    

    isSpecialString(_str)
    {
        if (_str && typeof _str === "string")
        {
            var startIndex = _str.indexOf("{");
            if (startIndex >= 0)
            {
                var endIndex = _str.indexOf("}");
                if (endIndex >= startIndex)
                {
                    return true;
                }
            }
            return _str.charAt(0) == "{" && _str.charAt(_str.length - 1) == "}";
        }
        return false;
    }

    checkSpecialString(_str)
    {
        if (!_str || typeof _str !== "string")
        {
            return _str;
        }
        var res = _str;
        if (this.isSpecialString(_str))
        {
            let str = _str.slice(1, -1);            
            let split = str.split(":");
            if (split[1] != null)
            {
                let index = str.indexOf("{");
                if (index >= 0)
                {
                    let tmp = str.slice(index);
                    split[1] = this.checkSpecialString(tmp);
                }
                switch (split[0])
                {
                    case "random":                        
                        res = this.Random(parseInt(split[1]), parseInt(split[2]));
                        break;
                    case "randomMods":
                        var mods = this.getAllModsForWeapon(split[1]);
                        res = mods;
                        break;
                    case "special":
                        switch (split[1])
                        {
                            case "randomPlayerId":
                                res = this.game.players[this.Random(0, this.game.players.length - 1)].id;
                                break;
                            case "numPlayers":
                                res = this.game.players.length;
                                break;
                            case "lastLivingPlayerTeam":
                                var aliveTeams = [];
                                for (var i = 0; i < this.game.players.length; i++)
                                {
                                    var ps = this.game.players[i];
                                    var pawn = this.getObjectById(ps.id);
                                    if (pawn && aliveTeams.indexOf(ps.team) == -1)
                                    {
                                        aliveTeams.push(ps.team);
                                    }
                                }
                                res = aliveTeams.length == 1 ? aliveTeams[0] : null;
                                break;
                            case "lastLivingPlayerId":
                                var aliveIds = [];
                                for (var i = 0; i < this.game.players.length; i++)
                                {
                                    var ps = this.game.players[i];
                                    var pawn = this.getObjectById(ps.id);
                                    if (pawn)
                                    {
                                        aliveIds.push(ps.id);
                                    }
                                }
                                res = aliveIds.length == 1 ? aliveIds[0] : null;
                                break;
                            case "randomBoolean":
                                res = this.RandomBoolean();
                                break;
                            case "randomRotation":
                                res = this.Random(-180, 180);
                                break;
                            case "randomAngle":
                                res = this.RandomAngle();
                                break;
                            case "randomWeaponId":
                                res = this.getRandomWeapon().id;
                                break;
                            case "randomFirearmId":
                                res = this.getRandomFirearm().id;
                                break;
                            case "randomEquipmentId":
                                res = this.getRandomEquipment().id;
                                break;
                            case "randomGrenadeId":
                                res = this.getRandomGrenade().id;
                                break;
                            case "randomMeleeId":
                                res = this.getRandomMelee().id;
                                break;
                            case "randomDinoId":
                                res = this.getRandomDinosaur();
                                break;
                            case "randomBotSkill":
                                res = this.Random(BotSkill.SKILL_EASY, BotSkill.SKILL_INSANE);
                                break;
                            case "uniqueId":
                                res = this.getRandomUniqueId();
                                break;
                            default:
                                console.warn("Unsupported", split);
                                break;
                        }
                        break;
                    case "data":
                    case "objectData":
                        var obj = this.getObjectById(split[1]);
                        if (obj && obj.data)
                        {
                            res = obj.data[split[2]];
                        }
                        break;
                    case "x":
                        var obj = this.getObjectById(split[1]);
                        if (obj)
                        {
                            res = obj.position[0];
                        }
                        break;
                    case "y":
                        var obj = this.getObjectById(split[1]);
                        if (obj)
                        {
                            res = obj.position[1];
                        }
                        break;
                    case "teamSpawn":
                        if (split[1] != null)
                        {
                            var map = this.getCurrentMapData();
                            res = map.teamSpawns[parseInt(plit[1])];
                        }
                        break;
                    case "position":
                        switch (split[1])
                        {
                            case "topLeft":
                                res = [0, 0];
                                break;
                            case "topRight":
                                res = [this.getMapWidth(), 0];
                                break;
                            case "bottomLeft":
                                res = [0, this.getMapHeight()];
                                break;
                            case "bottomRight":
                                res = [this.getMapWidth(), this.getMapHeight()];
                                break;
                            case "random":
                                res = this.getBestSpawnPosition(-1);
                                break;
                            default:
                                var obj = this.getObjectById(split[1]);
                                if (obj)
                                {
                                    res = [obj.position[0], obj.position[1]];
                                }
                                break;
                        }
                        break;
                    case "angle":
                        var obj = this.getObjectById(split[1]);
                        if (obj)
                        {
                            res = obj.angle;
                        }
                        break;
                    case "setting":
                        res = this.game.gameSettings[split[1]];
                        break;
                    case "var":                        
                        if (this.game.gameModeData.vars)
                        {
                            res = this.game.gameModeData.vars[split[1]];
                        }
                        break;
                    case "gameData":
                        res = this.game.gameModeData[split[1]];
                        break;
                    case "game":
                        res = this.game[split[1]];
                        break;
                    case "playerData":
                        var ps = this.getPlayerById(split[1]);
                        if (ps)
                        {
                            res = ps[split[2]];
                        }
                        break;
                    case "playerId":
                        var ps = this.game.players[parseInt(split[1])];
                        if (ps)
                        {
                            res = ps.id;
                        }
                        else
                        {
                            this.scenarioLog("[playerId] No player at index " + split[1], Colours.RED_STRING);
                        }
                        break;
                    case "playerIndex":
                        var ps = this.getPlayerById(split[1]);
                        if (ps)
                        {
                            res = this.game.players.indexOf(ps);
                        }
                        else
                        {
                            this.scenarioLog("[playerIndex] No player with id " + split[1], Colours.RED_STRING);
                        }
                        break;
                    case "playerTeam":
                        var ps = this.getPlayerById(split[1]);
                        if (ps)
                        {
                            res = ps.team;
                        }
                        else
                        {
                            this.scenarioLog("[playerTeam] No player with id " + split[1], Colours.RED_STRING);
                        }
                        break;
                    case "playerName":
                        var ps = this.getPlayerById(split[1]);
                        if (ps)
                        {
                            res = ps.name;
                        }
                        else
                        {
                            this.scenarioLog("[playerName] No player with id " + split[1], Colours.RED_STRING);
                        }
                        break;
                    case "playerLevel":
                        var ps = this.getPlayerById(split[1]);
                        if (ps)
                        {
                            res = ps.level;
                        }
                        else
                        {
                            this.scenarioLog("[playerLevel] No player with id " + split[1], Colours.RED_STRING);
                        }
                        break;
                    default:
                        console.warn("Unsupported", split);
                        break;
                }
            }
        }
        else if (res === "false")
        {
            res = false;
        }
        return res;
    }

    createObject(_data)
    {
        if (!_data)
        {
            console.warn("Invalid createObject data!");
            return null;
        }
        _data = this.clone(_data);
        _data.id = _data.id ? _data.id : this.getRandomUniqueId();
        if (!_data.position)
        {
            _data.position = this.getBestSpawnPosition(_data.team);
        }
        if (_data.chance != null)
        {
            if (Math.random() > _data.chance)
            {
                return null;
            }
        }
        var obj = this.getObjectById(_data.id);
        if (obj)
        {
            this.log("Object already exists: " + _data.id);
            _data.id = this.getRandomUniqueId();           
        }
        var map = this.getCurrentMapData();
        var res = null;
        switch (_data.type)
        {
            case ObjectType.SPAWNER:
                if (_data.objectType)
                {
                    _data.type = _data.objectType;
                }
                this.createSpawner(_data.position, {
                    id: _data.id,
                    timerMax: Math.round(this.game.settings.fps * _data.timer),
                    numObjects: _data.numObjects,
                    totalObjects: _data.totalObjects,
                    randomX: _data.randomX,
                    randomY: _data.randomY,
                    objectId: _data.objectId,
                    data: _data
                });
                break;
            case "flagCTF":
                if (!map.flags[GameMode.CAPTURE_THE_FLAG])
                {
                    map.flags[GameMode.CAPTURE_THE_FLAG] = [];
                }
                map.flags[GameMode.CAPTURE_THE_FLAG][_data.team] = _data.position;
                console.log(map.flags);
                var flag = this.getFlagCTF(_data.team);
                if (flag)
                {
                    this.setObjectPosition(flag, _data.position);
                }
                break;
            case "flagDomination":
                if (!map.flags[GameMode.DOMINATION])
                {
                    map.flags[GameMode.DOMINATION] = [];
                }
                map.flags[GameMode.DOMINATION][_data.num] = _data.position;
                flag = this.getFlagDomination(_data.num);
                if (flag)
                {
                    this.setObjectPosition(flag, _data.position);
                }
                break;
            case "bombSpawn":
                if (!map.bombs[GameMode.DESTRUCTION])
                {
                    map.bombs[GameMode.DESTRUCTION] = [[0, 0], [0, 0]];
                }
                map.bombs[GameMode.DESTRUCTION][_data.team][_data.num] = _data.position;
                var bomb = this.getBomb(_data.team, _data.num); //this.getObjectById("bomb_" + _data.team + "_" + _data.num);
                if (bomb)
                {
                    console.log("Move bomb");
                    this.setObjectPosition(bomb, _data.position);
                }
                break;
            case "spawnPoint":
                if (_data.bStore)
                {
                    map.storeSpawn = _data.position;
                    var storeCrate = this.getStoreCrate();
                    if (storeCrate)
                    {
                        this.setObjectPosition(storeCrate, _data.position);
                    }
                }
                else
                {
                    if (!map.spawns || this.game.settings.bOverrideSpawnPoints)
                    {
                        map.spawns = [];
                    }
                    map.spawns.push(_data.position);
                }
                break;
            case "teamSpawn":
                if (_data.team != null)
                {
                    if (!map.teamSpawns)
                    {
                        map.teamSpawns = [];
                    }
                    map.teamSpawns[_data.team] = {
                        x: _data.position[0],
                        y: _data.position[1],
                        w: _data.width ? _data.width : 100,
                        h: _data.height ? _data.height : 100
                    };
                }
                else
                {
                    this.scenarioLog("Invalid teamSpawn team: " + _data);
                }
                break;
            case "trigger":
                console.log(_data);
                this.checkTriggerAndExecuteById(_data.triggerId, _data);
                break;            
            case "event":
                this.dispatchTrigger({ event: _data.eventId });
                break;
            case "polygon":
                this.createPolygon(_data);
                break;
            case ObjectType.GROUND:
                var body = new this.p2.Body({
                    mass: 0,
                    position: _data.position,
                    angle: _data.rotation != null ? this.ToRad(_data.rotation) : 0
                });
                body.allowSleep = true;
                body.data = {
                    id: _data.id,
                    type: _data.type,
                    material: _data.material,
                    bSkipServerUpdate: true
                };
                body.addShape(new this.p2.Box({
                    width: _data.width,
                    height: _data.height,
                    collisionGroup: CollisionGroups.GROUND,
                    collisionMask: groundMask
                }));
                this.addWorldBody(body);
                break;

            case ObjectType.SPAWN_POINT:
                //res = this.createEmitter(_data);
                break;

            case ObjectType.EMITTER:
                res = this.createEmitter(_data);
                break;

            case ObjectType.TEXT:
                res = this.createText(_data);
                break;

            case ObjectType.ICON:
                res = this.createIcon(_data);
                break;

            case ObjectType.TRIGGER_AREA:
                res = this.createTriggerArea(_data);
                break;

            case ObjectType.HELICOPTER:
                if (_data.bRespawn)
                {
                    if (this.game.gameModeData.bMapVehicles !== false || this.game.scenario)
                    {
                        this.createSpawner(_data.position, {
                            type: _data.type,
                            timerMax: Math.max(1, this.game.settings.fps * this.game.gameModeData.vehicleRespawnTime),
                            data: _data
                        });
                    }
                }
                else
                {
                    res = this.createHelicopter(_data.position, _data);
                }
                break;

            case ObjectType.TANK:
                if (_data.bRespawn)
                {
                    if (this.game.gameModeData.bMapVehicles !== false || this.game.scenario)
                    {
                        this.createSpawner(_data.position, {
                            type: _data.type,
                            timerMax: Math.max(1, this.game.settings.fps * this.game.gameModeData.vehicleRespawnTime),
                            data: _data
                        });
                    }
                }
                else
                {
                    res = this.createTank(_data.position, _data);
                }
                break;

            case ObjectType.CAR:
                if (_data.bRespawn)
                {
                    if (this.game.gameModeData.bMapVehicles !== false || this.game.scenario)
                    {
                        this.createSpawner(_data.position, {
                            type: _data.type,
                            timerMax: this.game.settings.fps * this.game.gameModeData.vehicleRespawnTime,
                            data: _data
                        });
                    }
                }
                else
                {
                    res = this.createCar(_data.position, _data);
                    if (_data.characters)
                    {
                        for (var i = 0; i < _data.characters.length; i++)
                        {
                            let cur = _data.characters[i];
                            let char = this.createCharacter(cur);
                            if (char)
                            {
                                this.executeInteractable(res, char.data.id);
                                if (this.game.bSurvival)
                                {
                                    this.game.gameModeData.enemiesSpawned++;
                                }
                            }
                        }
                    }
                }
                break;

            case ObjectType.MOUNTED_WEAPON:
                if (_data.bRespawn)
                {
                    if (this.game.gameModeData.bMapWeapons !== false || this.game.scenario)
                    {
                        this.createSpawner(_data.position, {
                            type: _data.type,
                            timerMax: this.game.settings.fps * this.game.gameModeData.vehicleRespawnTime,
                            data: _data
                        });
                    }
                }
                else
                {
                    res = this.createMountedWeapon(_data.position, _data);
                }
                break;

            case ObjectType.DROPPED_WEAPON:
                if (_data.bRespawn)
                {
                    if ((this.game.gameModeData.bMapWeapons !== false && !this.game.bSurvival) || this.game.scenario)
                    {
                        this.createSpawner(_data.position, {
                            type: _data.type,
                            timerMax: this.game.settings.fps * this.game.gameModeData.weaponRespawnTime,
                            data: _data
                        });
                    }
                }
                else
                {
                    res = this.createDroppedWeapon(_data.position, _data);
                }
                break;

            case ObjectType.OBSTACLE:
                if (this.game.gameModeData.bMapObjects !== false || this.game.bScenario)
                {
                    res = this.createObstacle(_data);
                }
                break;

            case ObjectType.EQUIPMENT:
                res = this.createEquipment(_data.position, _data);
                break;

            case ObjectType.DUMMY:
                if (_data.bRespawn)
                {
                    this.createSpawner(_data.position, {
                        type: _data.type,
                        timerMax: Math.max(1, this.game.settings.fps),
                        data: _data
                    });
                }
                else
                {
                    res = this.createDummy(_data);
                }
                break;

            case ObjectType.TREE:
                res = this.createTree(_data);
                break;

            case ObjectType.DOOR:
                res = this.createDoor(_data);
                break;

            case ObjectType.CRATE:
                res = this.createCrate(_data.position, _data);
                break;

            case ObjectType.LEVER:
                res = this.createLever(_data.position, _data);
                break;

            case ObjectType.WINDOW:
                res = this.createWindow(_data);
                break;

            case ObjectType.CHARACTER:
                res = this.createCharacter(_data);
                break;

            case ObjectType.DINOSAUR:
            case ObjectType.FLYING_DINOSAUR:
                if (_data.bSurvival)
                {
                    res = this.spawnSurvivalEnemyDinosaur(_data.position, true);
                }
                else
                {
                    res = this.createDinosaur(_data);
                }
                break;

            case ObjectType.MONEY:
                res = this.createMoney(_data.position, _data);
                break;

            case ObjectType.ARROW:
                res = this.createArrow(_data.position, _data);
                break;

            case ObjectType.EGG:
                res = this.createEgg(_data.position, _data);
                break;

            default:
                console.warn("Unhandled createObject", _data.type);
                break;
        }
        if (res)
        {
            if (_data.bRandomVelocity)
            {
                res.applyImpulse([this.Random(-500, 500), this.Random(-500, 500)], [0, 0]);
                res.angularVelocity = this.Random(-20, 20);
            }
            if (_data.bDisabled != null)
            {
                this.setDataValue(res, "bDisabled", _data.bDisabled == true);
            }
            var data = res.data;
            this.optimizeKeys(data);            
        }
        return res;
    }

    applyAABBBuoyancyForces(body, planePosition, k, c)
    {
        var p2 = this.p2;
        for (var i = 0; i < body.shapes.length; i++)
        {
            var shape = body.shapes[i];
            // Get shape world transform
            body.vectorToWorldFrame(shapePosition, shape.position);
            p2.vec2.add(shapePosition, shapePosition, body.position);
            shapeAngle = shape.angle + body.angle;
            // Get shape AABB
            shape.computeAABB(aabb, shapePosition, shapeAngle);
            var areaUnderWater;
            if (aabb.upperBound[1] < planePosition[1])
            {
                // Fully submerged
                p2.vec2.copy(centerOfBouyancy, shapePosition);
                areaUnderWater = shape.area;
            }
            else if (aabb.lowerBound[1] < planePosition[1])
            {
                // Partially submerged
                var width = aabb.upperBound[0] - aabb.lowerBound[0];
                var height = 0 - aabb.lowerBound[1];
                areaUnderWater = width * height;
                p2.vec2.set(centerOfBouyancy, aabb.lowerBound[0] + width / 2, aabb.lowerBound[1] + height / 2);
            }
            else
            {
                continue;
            }
            // Compute lift force
            p2.vec2.subtract(liftForce, planePosition, centerOfBouyancy);
            p2.vec2.scale(liftForce, liftForce, areaUnderWater * k);
            liftForce[0] = 0;
            // Make center of bouycancy relative to the body
            p2.vec2.subtract(centerOfBouyancy, centerOfBouyancy, body.position);
            // Viscous force
            body.getVelocityAtPoint(v, centerOfBouyancy);
            p2.vec2.scale(viscousForce, v, -c);
            // Apply forces
            body.applyForce(viscousForce, centerOfBouyancy);
            body.applyForce(liftForce, centerOfBouyancy);
        }
    }

    vehicleHasOccupant(_body)
    {
        if (_body && _body.data)
        {
            var data = _body.data;
            if (data.bAutomated)
            {
                return true;
            }
            var seats = data.seats;
            if (seats)
            {
                for (var i = 0; i < seats.length; i++)
                {
                    if (seats[i].pawnId)
                    {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    canExitVehicle(_body)
    {
        if (!_body)
        {
            return false;
        }
        return !_body.data.vehicleCooldown && !_body.data.seatTimer;
    }

    canEnterVehicle(_body, _vehicle)
    {
        if (!_body || !_vehicle)
        {
            return false;
        }
        if (!_body.data.type == ObjectType.CHARACTER)
        {
            return false;
        }
        if (_vehicle.data.bAutomated)
        {
            return false;
        }
        if (this.vehicleHasOccupant(_vehicle))
        {
            var seats = _vehicle.data.seats;
            if (seats)
            {
                for (var i = 0; i < seats.length; i++)
                {
                    var seat = seats[i];
                    if (seat.pawnId)
                    {
                        var pawn = this.getObjectById(seat.pawnId);
                        if (pawn && pawn.data.team != _body.data.team)
                        {
                            return false;
                        }
                    }
                }
            }
        }
        return !_body.data.vehicleCooldown;
    }

    enterVehicle(_pawn, _vehicle, _seatIndex)
    {
        if (!_pawn || !_vehicle || !_vehicle.data.health)
        {
            return;
        }
        var seats = _vehicle.data.seats;
        if (seats)
        {
            this.setDataValue(_vehicle, "team", _pawn.data.team);
            switch (_vehicle.data.type)
            {
                case ObjectType.HELICOPTER:
                    if (!_vehicle.data.bAutomated)
                    {
                        _vehicle.shapes[0].collisionMask = CollisionGroups.HELICOPTER | CollisionGroups.PROJECTILE | CollisionGroups.BOUNDS;
                        _vehicle.damping = 0.5;
                        _vehicle.angularDamping = 0.8;
                    }
                    break;
            }
            _pawn.data.seatIndex = _seatIndex;
            var seatData = seats[_seatIndex];
            seatData.pawnId = _pawn.data.id;
            if (seatData.bInvisible)
            {
                this.setDataValue(_pawn, "bInvisible", true);
            }
            _pawn.velocity = [0, 0];
            _pawn.shapes[0].collisionMask = CollisionGroups.PROJECTILE;
            _pawn.data.bWantsToMove = false;
            _pawn.data.bSprinting = false;
            _pawn.data.controllableId = _vehicle.data.id;
            this.startVehicleCooldown(_pawn);
            _pawn.data.bWantsToFire = false;
            this.cancelCharacterBoltPull(_pawn);
            this.cancelCharacterReload(_pawn);
            this.pushObjectDataUpdate(_vehicle.data.id, ["seats"]);
            this.requestEvent({
                eventId: GameServer.EVENT_PAWN_ACTION,
                pawnId: _pawn.data.id,
                type: GameServer.PAWN_VEHICLE_ENTER,
                vehicleId: _vehicle.data.id,
                scale: _vehicle.data.scale,
                seatIndex: _seatIndex,
                seat: seats[_seatIndex]
            });
        }
        if (this.vehicleHasOccupant(_vehicle))
        {
            this.requestEvent({
                eventId: GameServer.EVENT_PAWN_ACTION,
                pawnId: _vehicle.data.id,
                type: GameServer.PAWN_VEHICLE_ENTER,
                seatIndex: _seatIndex
            });
        }
        this.setPlayerControllable(_pawn.data.id, _vehicle);
    }

    exitVehicle(_char, _bEject)
    {
        if (!_char)
        {
            return;
        }
        var vehicle = this.getObjectById(_char.data.controllableId);
        if (vehicle)
        {
            var seats = vehicle.data.seats;
            if (seats)
            {
                var seat = seats[_char.data.seatIndex];
                if (seat)
                {
                    if (seat.pawnId)
                    {
                        var pawn = this.getObjectById(seat.pawnId);
                        if (pawn)
                        {
                            pawn.data.controllableId = null;
                        }
                        delete seat.pawnId;
                    }
                }
                this.setDataValue(_char, "bInvisible", false);
                _char.angle = 0;
                _char.velocity = [0, 0];
                _char.shapes[0].collisionMask = CollisionGroups.GROUND | CollisionGroups.BOUNDS | CollisionGroups.PROJECTILE | CollisionGroups.OBJECT | CollisionGroups.PAWN;
                this.startVehicleCooldown(_char);
                this.requestEvent({
                    eventId: GameServer.EVENT_PAWN_ACTION,
                    pawnId: _char.data.id,
                    type: GameServer.PAWN_VEHICLE_LEAVE,
                    bEject: _bEject
                });
            }
            this.pushObjectDataUpdate(vehicle.data.id, ["seats"]);
            switch (vehicle.data.type)
            {
                case ObjectType.HELICOPTER:
                    if (!this.vehicleHasOccupant(vehicle))
                    {
                        vehicle.shapes[0].collisionGroup = CollisionGroups.HELICOPTER;
                        vehicle.shapes[0].collisionMask = CollisionGroups.GROUND | CollisionGroups.PROJECTILE | CollisionGroups.OBJECT | CollisionGroups.PAWN | CollisionGroups.BOUNDS;
                        vehicle.damping = 0.95;
                        vehicle.angularDamping = 0.95;
                    }
                    break;
                case ObjectType.MOUNTED_WEAPON:
                    if (this.game.bSurvival && vehicle.data.team != 0)
                    {
                        this.killPawn(vehicle.data.id);
                    }
                    break;
                case ObjectType.CAR:
                    if (this.game.bSurvival)
                    {

                    }
                    break;
            }
            if (!this.vehicleHasOccupant(vehicle))
            {
                this.requestEvent({
                    eventId: GameServer.EVENT_PAWN_ACTION,
                    pawnId: vehicle.data.id,
                    type: GameServer.PAWN_VEHICLE_LEAVE
                });
                this.setDataValue(vehicle, "team", -1);
            }
        }
    }

    startVehicleCooldown(_body)
    {
        if (_body)
        {
            var data = _body.data;
            data.vehicleCooldown = Math.round(this.game.settings.fps * (data.bBot ? 3 : 0.5));
        }
    }

    triggerCountermeasure(_char)
    {
        if (_char.data.seatTimer)
        {
            return;
        }
        var vehicle = this.getObjectById(_char.data.controllableId);
        if (vehicle)
        {
            if (!vehicle.data.bCountermeasureCooldown)
            {
                var cm = vehicle.data.countermeasure;
                var cooldown = 60;
                switch (cm)
                {
                    case "ejection_seat":
                        cooldown = 10;
                        this.clearPlayerControllable(_char.data.id, true);
                        if (_char.data.bBot)
                        {
                            _char.velocity = [0, this.getSharedData(ObjectType.CHARACTER).ejectionVelocity];
                        }
                        break;
                    case "ecm":
                        this.setDataValue(vehicle, "bECM", true);
                        vehicle.data.ecmTimer = this.game.settings.fps * 15;
                        break;
                    case "flares":
                        cooldown = 30;
                        for (var i = 0; i < 5; i++)
                        {
                            this.createRocket(vehicle.position, {
                                rocketType: Rocket.DEFAULT,
                                team: vehicle.data.team,
                                playerId: vehicle.data.id,
                                causerId: vehicle.data.id,
                                angle: this.ToRad(-90) + this.ToRad(this.Random(-45, 45)),
                                weaponId: "rocket_flare",
                                damage: 0,
                                radius: 100
                            });
                        }
                        break;
                }
                this.setDataValue(vehicle, "bCountermeasureCooldown", true);
                vehicle.data.countermeasureCooldownTimer = this.game.settings.fps * cooldown;
                this.requestEvent({
                    eventId: GameServer.EVENT_PAWN_ACTION,
                    pawnId: vehicle.data.id,
                    type: GameServer.PAWN_VEHICLE_UPDATE,
                    bUseCountermeasure: true,
                    cooldown: vehicle.data.countermeasureCooldownTimer
                });
            }
        }
    }

    getCurrentMapData() 
    {
        if (!this.game.mapData)
        {
            this.game.mapData = this.clone(this.getMapData(this.game.mapId));
        }
        var map = this.game.mapData;
        if (!map.spawns)
        {
            map.spawns = [];
        }
        if (!map.flags)
        {
            map.flags = {
                capture_the_flag: [
                    [0, 0],
                    [0, 0]
                ],
                domination: [
                    [0, 0],
                    [0, 0],
                    [0, 0]
                ]
            };
        }
        if (!map.bombs)
        {
            map.bombs = {
                destruction: [
                    [
                        [0, 0],
                        [0, 0]
                    ],
                    [
                        [0, 0],
                        [0, 0]
                    ]
                ]
            };
        }
        if (!map.ai)
        {
            map.ai = {
                nodes: []
            }
        }
        return map;
    }

    getMapWidth()
    {
        var bCustomMap = this.game.mapId == Map.CUSTOM;// || this.game.mapId == Map.GENERATED;
        var val = bCustomMap ? 0 : this.getCurrentMapData().width;
        if (this.game.gameSettings.width)
        {
            val = Math.max(val, this.game.gameSettings.width);
        }
        return Math.min(this.settings.maxWorldSize, val);
    }

    getMapHeight()
    {
        var bCustomMap = this.game.mapId == Map.CUSTOM;// || this.game.mapId == Map.GENERATED;
        var val = bCustomMap ? 0 : this.getCurrentMapData().height;
        if (this.game.gameSettings.height)
        {
            val = Math.max(val, this.game.gameSettings.height);
        }
        return Math.min(this.settings.maxWorldSize, val);
    }

    getCharacterSpeedMultiplier(_body)
    {
        var data = _body.data;
        var mult = (data.speedMultiplier != null ? data.speedMultiplier : 1) * (data.baseSpeedMultiplier != null ? data.baseSpeedMultiplier : 1);
        if (isNaN(mult))
        {
            console.warn("Invalid character speed multiplier", mult);
            mult = 1;
        }
        if (data.bStoppingPower)
        {
            mult *= 0.5;
        }        
        return mult;
    }

    handleAIPawn(_body)
    {
        var data = _body.data;
        if (!_body.ai)
        {
            _body.ai = this.initPawnAI(_body, data.botSkill);
        }
        var ai = _body.ai;
        if (ai.ticker > 0)
        {
            ai.ticker--;
        }
        else
        {
            ai.tickerMax = Math.round(this.game.settings.fps * (_body.world ? (this.isDinosaur(_body) ? 0.25 : 0.5) : 3));
            ai.ticker = ai.tickerMax;
        }

        if (!this.matchInProgress())
        {
            if (data.lookPos && this.Random(1, 100) == 1)
            {
                //Randomly look around at pre game
                data.lookPos[0] += this.Random(-20, 20);
                data.lookPos[1] += this.Random(-20, 20);
            }
            return;
        }

        if (data.bFlashed || data.bStunned)
        {
            data.bWantsToFire = false;
        }
        if (ai.enemy && !ai.enemy.data)
        {
            delete ai.enemy;
        }
        if (ai.ticker == 0)
        {
            switch (ai.botSkill)
            {
                case BotSkill.SKILL_GOD:
                    ai.enemyDistMax = 3000;
                    ai.offsetX = 0;
                    ai.offsetY = 0;
                    break;
                case BotSkill.SKILL_INSANE:
                    ai.enemyDistMax = 800;
                    ai.offsetX = this.Random(-40, 40);
                    ai.offsetY = this.Random(-40, 40);
                    break;
                case BotSkill.SKILL_HARD:
                    ai.enemyDistMax = 600;
                    ai.offsetX = this.Random(-50, 50);
                    ai.offsetY = this.Random(-50, 50);
                    break;
                case BotSkill.SKILL_NORMAL:
                    ai.enemyDistMax = 500;
                    ai.offsetX = this.Random(-60, 60);
                    ai.offsetY = this.Random(-60, 60);
                    break;
                default:
                    ai.enemyDistMax = 400;
                    ai.offsetX = this.Random(-80, 80);
                    ai.offsetY = this.Random(-80, 80);
                    break;
            }
            //Handle hostages
            if (data.bHostage)
            {
                var rescueZone = this.getRescueZonePosition();
                var distToZone = this.Dist(_body.position[0], _body.position[1], rescueZone[0], rescueZone[1]);
                if (distToZone <= 100)
                {
                    this.rescueHostage(_body, ai.followTargetId);
                }
                if (ai.followTargetId)
                {
                    var follow = this.getObjectById(ai.followTargetId);
                    if (!follow)
                    {
                        delete ai.followTargetId; //Rescuer killed
                    }
                    else if (follow.data.controllableId)
                    {
                        delete ai.followTargetId; //Rescuer in vehicle
                    }
                    else if (this.Dist(follow.position[0], follow.position[1], _body.position[0], _body.position[1]) > 500)
                    {
                        delete ai.followTargetId; //Rescuer too far away
                    }
                }
                if (!ai.followTargetId)
                {
                    var rescuerTeam = this.game.gameModeData.rescueTeam != null ? this.game.gameModeData.rescueTeam : 0;
                    var pawns = this.getCharactersAndDinosaurs();
                    for (var i = 0; i < pawns.length; i++)
                    {
                        let p = pawns[i];
                        if (!p.data.bHostage)
                        {
                            var dist = this.Dist(p.position[0], p.position[1], _body.position[0], _body.position[1]);
                            if (dist < 100)
                            {
                                if (p.data.team == rescuerTeam)
                                {
                                    ai.followTargetId = p.data.id;
                                    this.onEvent({
                                        eventId: GameServer.EVENT_GAME_UPDATE,
                                        data: {
                                            bHostageFollowing: 1,
                                            playerId: p.data.id,
                                            hostageId: data.id
                                        }
                                    });
                                    if (p.data.bBot)
                                    {
                                        this.setPawnRequest(p, Commands.REQUEST_FOLLOW);
                                    }
                                    break;
                                }
                            }
                        }
                    }
                }
            }
            var enemySettings = {};
            if (data.controllableId)
            {
                var veh = this.getObjectById(data.controllableId);
                var wpn = this.getCurrentVehicleWeapon(veh, data.seatIndex);
                if (wpn && veh.data.vehicleId == MountedWeapon.BGM71)
                {
                    enemySettings.bLOS = false;
                }
            }
            if (data.bIgnoreOutOfSight != null)
            {
                if (!(veh && veh.data.type == ObjectType.HELICOPTER))
                {
                    enemySettings.bIgnoreOutOfSight = data.bIgnoreOutOfSight;
                }
            }
            if (enemySettings.bIgnoreOutOfSight || data.bIgnoreOutOfSight)
            {
                enemySettings.maxRange = data.maxRange ? data.maxRange : ((this.game.scenario ? 1000 : 1500) + (ai.botSkill * 250));
            }
            var curItem = this.getCurrentCharacterInventoryItem(_body);
            if (curItem && curItem.range < 200)
            {
                enemySettings.pawnTypes = [
                    ObjectType.CHARACTER,
                    ObjectType.DINOSAUR,                    
                    ObjectType.MOUNTED_WEAPON,
                    ObjectType.TANK,
                    ObjectType.CAR,
                    ObjectType.EGG
                ];
                if (data.type == ObjectType.FLYING_DINOSAUR)
                {
                    enemySettings.pawnTypes.push(ObjectType.HELICOPTER);
                }
                else if (data.type != ObjectType.DINOSAUR || this.game.bOpenWorld)
                {
                    enemySettings.pawnTypes.push(ObjectType.FLYING_DINOSAUR);
                }
            }     
            var enemy = null;
            if (!data.bIgnoreEnemies && !data.bStunned && !data.bFlashed)
            {
                var ally = this.getNearestFriendlyPawn(_body, { maxRange: 100 });
                if (ally && ally.ai && (!ally.ai.bIgnoreOutOfSight || ally.ai.bEnemyLOS) && ally.ai.enemy && ally.ai.enemy.data)
                {
                    enemy = ally.ai.enemy; //Target same enemy as nearby ally
                }
                else
                {
                    enemy = this.getNearestEnemyPawn(_body, enemySettings); //Enemy for pawn
                }
            }
            data.lockOnTargetId = enemy ? enemy.data.id : null;
            if (enemy)
            {
                var bHadEnemy = ai.enemy != null;
                var bHadEnemyLOS = ai.bEnemyLOS == true;
                ai.enemy = enemy;
                ai.bEnemyLOS = (ai.botSkill >= BotSkill.SKILL_INSANE || !this.isInSmoke(_body)) && this.checkLineOfSight(_body.position, enemy.position, true, enemy, true);
                if (veh && veh.data.type == ObjectType.HELICOPTER)
                {
                    ai.bEnemyLOS = true;
                }
                if (this.game.bSurvival && data.type == ObjectType.CHARACTER && data.team == 1 && ai.bEnemyLOS && !bHadEnemyLOS)
                {
                    this.requestEvent({
                        eventId: GameServer.EVENT_PAWN_ACTION,
                        pawnId: data.id,
                        type: GameServer.PAWN_INVESTIGATE,
                        value: "enemy",
                        enemyId: enemy.data.id
                    });
                }
                ai.enemyDist = this.Dist(enemy.position[0], enemy.position[1], _body.position[0], _body.position[1]);
                if (ai.enemyDist)
                {
                    let mult = Math.max(0, ai.enemyDist < 50 ? 0 : (0.5 - (ai.botSkill * 0.1)));
                    ai.enemyDistMult = Math.max(mult, ai.enemyDist / ai.enemyDistMax);
                }
                else
                {
                    ai.enemyDistMult = 1;
                }
                if (enemy.data.bECM)
                {
                    data.lockOnTargetId = null;
                }
                if (data.type == ObjectType.CHARACTER && (enemy.data.dinoType == Dinosaur.TREX || enemy.data.bJuggernaut))
                {
                    if (ai.bEnemyLOS && this.Random(1, Math.round(ai.enemyDist / 50)) == 1)
                    {
                        this.setPawnRequest(_body, Commands.REQUEST_SUPPORT);
                    }
                }
                this.emitAISound(enemy.position, _body.position, 1000, enemy.data.team);
                delete ai.investigatePos;
                //delete ai.wanderArea;
                if (ai.bInvestigate && !bHadEnemy)
                {
                    this.requestEvent({
                        eventId: GameServer.EVENT_PAWN_ACTION,
                        pawnId: data.id,
                        type: GameServer.PAWN_INVESTIGATE,
                        value: "enemy",
                        enemyId: enemy.data.id
                    });
                }
            }
            else
            {
                if (ai.enemy && !ai.enemy.data.bPendingRemoval)
                {
                    //Just lost sight
                    if (ai.bInvestigate)
                    {
                        this.emitAISound(ai.enemy.position, _body.position, 1000, 999);
                        this.setAIInvestigatePos(_body, ai.enemy.position);
                        this.requestEvent({
                            eventId: GameServer.EVENT_PAWN_ACTION,
                            pawnId: data.id,
                            type: GameServer.PAWN_INVESTIGATE,
                            value: "enemyLost"
                        });
                    }
                }
                delete ai.enemy;
                delete ai.bEnemyLOS;
                delete ai.enemyDist;                
                if (data.lookPos && this.Random(1, 10) == 1)
                {
                    //Randomly look around if no enemy
                    data.lookPos[0] = _body.position[0] + this.Random(-100, 100);
                    data.lookPos[1] = _body.position[1] + this.Random(-100, 100);
                }                
            }
            if (ai.actionTicker > 0)
            {
                ai.actionTicker--;
            }
            else
            {
                ai.actionTicker = ai.actionTickerMax;
            }
            if (ai.pathTicker > 0)
            {
                ai.pathTicker--;
            }
            else
            {
                if (ai.moveToPos)
                {
                    var moveDist = this.Dist(_body.position[0], _body.position[1], ai.moveToPos[0], ai.moveToPos[1]);
                    if (this.game.bSurvival || moveDist > ai.destThreshold)
                    {
                        if (!ai.path || !ai.lastMovePos || this.DistPositions(ai.lastMovePos, ai.moveToPos) > ai.destThreshold)
                        {
                            ai.path = this.getAIPath([_body.position[0], _body.position[1]], ai.moveToPos, _body);
                            ai.lastMovePos = this.clone(ai.moveToPos);
                        }
                        if (ai.path.length == 0)
                        {
                            //console.warn("Empty path");
                        }
                        else if (ai.path.length == 1)
                        {
                            ai.bShortPath = true;
                        }
                        else
                        {
                            delete ai.bShortPath;
                        }
                    }
                }
                else
                {
                    if (ai.wanderArea && !ai.enemy)
                    {
                        if (ai.wanderTicker > 0)
                        {
                            ai.wanderTicker--;
                        }
                        else
                        {
                            ai.wanderTicker = this.Random(1, ai.wanderTickerMax);
                            this.setAIInvestigatePos(_body, [ai.wanderArea.x + this.Random(-ai.wanderArea.width, ai.wanderArea.width), ai.wanderArea.y + this.Random(-ai.wanderArea.height, ai.wanderArea.height)]);
                        }
                    }
                }
                var pathTickerMax = 0;
                if (data.type == ObjectType.CHARACTER)
                {
                    if (this.hasMeleeEquipped(_body))
                    {
                        pathTickerMax = 0;
                    }
                    else if (data.controllableId)
                    {
                        pathTickerMax = 3;
                    }
                    else
                    {
                        switch (ai.botSkill)
                        {
                            case BotSkill.SKILL_NORMAL:
                            case BotSkill.SKILL_HARD:
                                pathTickerMax = 2;
                                break;
                            case BotSkill.SKILL_INSANE:
                            case BotSkill.SKILL_GOD:
                                pathTickerMax = 1;
                                break;
                            default:
                                pathTickerMax = 3;
                                break;
                        }
                    }
                }
                ai.pathTicker = pathTickerMax;
            }
        }
    }

    setAICamp(_body, _bVal, _pos)
    {
        var ai = _body.ai;
        if (ai)
        {
            if (_bVal)
            {
                ai.bCamp = true;
                ai.campPos = _pos;
                delete ai.desiredItemId;
                delete ai.bWantsItem;
                delete ai.returnPos;
                delete ai.investigatePos;
                delete ai.followTargetId;
            }
            else
            {
                delete ai.bCamp;
                delete ai.campPos;
            }
        }
    }

    setAIDestination(_body, _pos, _triggerId)
    {
        var ai = _body.ai;
        if (ai)
        {
            ai.destination = _pos;
            ai.onDestinationTriggerId = _triggerId;
        }
    }

    setAIObjectiveItemId(_body, _itemId)
    {
        var ai = _body.ai;
        if (ai)
        {
            ai.objectiveItemId = _itemId;
            var item = this.getObjectById(_itemId);
            if (item)
            {
                ai.desiredItemId = _itemId;
                ai.bWantsItem = true;
            }
        }
    }

    setAIFollowTargetId(_body, _targetId)
    {
        var ai = _body.ai;
        if (ai)
        {
            if (_targetId)
            {
                ai.followTargetId = _targetId;
            }
            else
            {
                delete ai.followTargetId;
            }
        }
    }

    setAIInteract(_body, _bVal)
    {
        var ai = _body.ai;
        if (ai)
        {
            ai.bInteract = _bVal;
        }
    }

    setAIInvestigate(_body, _bVal)
    {
        var ai = _body.ai;
        if (ai)
        {
            ai.bInvestigate = _bVal;
        }
    }

    setAIInvestigate(_body, _bVal)
    {
        var ai = _body.ai;
        if (ai)
        {
            ai.bInvestigate = _bVal;
        }
    }

    setAIWanderArea(_body, _areaSize)
    {
        var ai = _body.ai;
        if (_areaSize)
        {
            ai.wanderArea = {
                x: _body.position[0] - (_areaSize * 0.5),
                y: _body.position[1] - (_areaSize * 0.5),
                width: _areaSize,
                height: _areaSize
            };
            this.setAIInvestigatePos(_body, [_body.position[0] + this.Random(-_areaSize, _areaSize), _body.position[1] + this.Random(-_areaSize, _areaSize)]);
        }
        else
        {
            delete ai.wanderArea;
        }
    }

    setAIInvestigatePos(_body, _position)
    {
        var ai = _body.ai;
        if (ai)
        {
            if (this.isValidArray(_position))
            {
                if (!ai.returnPos)
                {
                    ai.returnPos = this.clone(_body.position);
                }
                ai.investigatePos = _position;
            }
        }
    }

    handleAICharacter(_body)
    {        
        this.handleAIPawn(_body);
        if (!this.matchInProgress())
        {
            return;
        }
        var data = _body.data;
        var ai = _body.ai;
        if (data.bStunned || data.bFlashed)
        {
            return;
        }
        if (!ai)
        {
            return;
        }
        if (ai.actionTicker == 0)
        {
            ai.actionTicker = -1;            
            if (data.type == ObjectType.CHARACTER)
            {
                if (this.game.bSurvival && this.game.gameModeData.bIntermission && data.controllableId && data.team == 0 && data.bCanInteract && this.getPlayerById(data.id))
                {
                    this.clearPlayerControllable(data.id);
                }
                var ps = this.getPlayerById(data.id);
                if (ps)
                {
                    //Handle bot
                    if (ps.items && ps.items.length > 0)
                    {
                        this.useItem(ps.id);
                    }
                }
                else
                {
                    if (data.pawnItems && data.pawnItems.length > 0)
                    {
                        this.useItem(data.id);
                    }
                }
                if (data.health < data.maxHealth * 0.25 && !(this.game.bSurvival && data.team != 0) && this.isTeamGameMode())
                {
                    this.setPawnRequest(_body, Commands.REQUEST_SUPPORT);
                }
                else if (this.needsAmmo(_body) && this.Random(1, 5) == 1)
                {
                    this.setPawnRequest(_body, Commands.REQUEST_AMMO);
                }
                if (ai.bInteract && data.bCanInteract && !data.bHasFlag)
                {
                    delete ai.bRepair;
                    var objectiveItem = ai.objectiveItemId ? this.getObjectById(ai.objectiveItemId) : null;
                    if (!objectiveItem && !ai.bEnemyLOS)
                    {
                        var blowtorchIndex = this.getCharacterInventoryItemIndex(_body, "blowtorch");
                        if (blowtorchIndex >= 0)
                        {
                            var repairableObject = this.getNearbyRepairableObject(_body);
                            if (repairableObject)
                            {
                                desiredItem = repairableObject;
                                ai.bRepair = true;
                            }
                        }
                    }
                    if (!repairableObject)
                    {
                        desiredItem = objectiveItem ? objectiveItem : this.getDesiredInteractable(_body, data.maxRange);
                    }
                    if (!data.controllableId)
                    {
                        delete ai.desiredItemId;
                        delete ai.bWantsItem;
                        delete ai.bWantsVehicle;
                        delete ai.desiredVehicleId;
                        if (desiredItem)
                        {
                            ai.desiredItemId = desiredItem.data.id;
                            ai.bWantsItem = true;
                        }
                        else
                        {
                            ai.bWantsVehicle = this.Random(1, 8) == 1 && (this.getAvailableVehicles(_body).length > 0);
                            ai.desiredVehicleId = null;
                        }
                    }
                }
                if (data.controllableId)
                {
                    if (desiredItem && desiredItem.type == ObjectType.REVIVER)
                    {
                        this.clearPlayerControllable(data.id);
                    }
                    switch (this.game.gameModeId)
                    {
                        case GameMode.EXTRACTION:
                            if (this.getObjectById("extractZone"))
                            {
                                this.clearPlayerControllable(data.id);
                            }
                            break;
                    }
                }
            }
        }

        if (ai.ticker == 0)
        {
            if (this.characterHasEquipment(_body, "ammo_box"))
            {
                var supportRequest = this.getNearbyRequest(_body, Commands.REQUEST_AMMO);
                if (supportRequest)
                {
                    this.useCharacterEquipment(_body, "equipment", supportRequest.position[0], supportRequest.position[1]);
                }
            }            
        }       

        //Handle inventory
        if (ai.bRepair && this.hasItemInInventory(_body, "blowtorch"))
        {
            var bestIndex = this.getCharacterInventoryItemIndex(_body, "blowtorch");
            if (bestIndex != data.currentInventoryIndex)
            {
                this.requestEvent({
                    eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                    pawnId: data.id,
                    type: GameServer.INV_CURRENT_INVENTORY_INDEX,
                    value: bestIndex
                });
            }
        }
        else if (this.hasInventoryAmmo(_body))
        {
            bestIndex = this.getBestInventoryIndex(_body, ai.enemy, ai.enemyDist);
            if (bestIndex != data.currentInventoryIndex)
            {
                this.requestEvent({
                    eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                    pawnId: data.id,
                    type: GameServer.INV_CURRENT_INVENTORY_INDEX,
                    value: bestIndex
                });
            }
        }
        else
        {
            bestIndex = Character.INDEX_MELEE;
            if (bestIndex != data.currentInventoryIndex)
            {
                this.requestEvent({
                    eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                    pawnId: data.id,
                    type: GameServer.INV_CURRENT_INVENTORY_INDEX,
                    value: bestIndex
                });
            }
        }

        //Handle equipment
       
        var equipment = data.equipment;
        if (equipment && equipment.ammo > 0)
        {
            switch (equipment.id)
            {
                case "ammo_box":
                    break;
                case "claymore":
                case "betty":
                    if (ai.enemy && !ai.bEnemyLOS && Math.random() > 0.9)
                    {
                        if (this.game.bSurvival && data.team == 1 && this.getMines(1).length >= 10)
                        {
                            break;
                        }
                        this.useCharacterEquipment(_body, "equipment", ai.enemy.position[0], ai.enemy.position[1]);
                    }
                    break;
                case "juice":
                    if (ai.enemy && Math.random() > 0.9)
                    {
                        this.useCharacterEquipment(_body, "equipment", ai.enemy.position[0], ai.enemy.position[1]);
                    }
                    break;
                case "stim":
                    if (data.health <= (data.maxHealth * 0.5))
                    {
                        this.useCharacterEquipment(_body, "equipment", _body.position[0], _body.position[1]);
                    }
                    break;
                case "jammer":
                case "sensor":
                    if (ai.enemy && ai.enemyDist < equipment.radius && Math.random() > 0.9)
                    {
                        this.useCharacterEquipment(_body, "equipment", ai.enemy.position[0], ai.enemy.position[1]);
                    }
                    break;
                default:
                    if (ai.enemy && ai.enemyDist < 750)
                    {
                        this.useCharacterEquipment(_body, "equipment", ai.enemy.position[0], ai.enemy.position[1]);
                    }
                    break;
            }
        }

        //Handle grenade
        var grenade = data.grenade;
        if (grenade && grenade.ammo > 0)
        {
            switch (grenade.id)
            {
                default:
                    if (ai.enemy && ai.bEnemyLOS && ai.enemyDist > 250 && ai.enemyDist < 1000 && Math.random() > 0.999)
                    {
                        this.useCharacterEquipment(_body, "grenade", ai.enemy.position[0], ai.enemy.position[1]);
                    }
                    break;
            }
        }

        //console.log(ai.moveToPos, [_body.position[0], _body.position[1]]);

        delete data.moveAngle;
        if (ai.path)
        {
            var node = ai.path[0];
            if (node && node.data)
            {
                data.moveAngle = this.Angle(_body.position[0], _body.position[1], node.data.position[0], node.data.position[1]);
                var endNode = ai.path[ai.path.length - 1];
                if (ai.ticker % 10 == 0)
                {
                    if (this.checkLineOfSight(_body.position, endNode.data.position, true, null, true))
                    {
                        var bWithinEndNode = true;
                    }
                }
                if (bWithinEndNode)
                {
                    ai.path = [endNode];
                }
                else
                {
                    var nodeThreshold = this.isDinosaur(_body) ? 20 : 32;
                    if (ai.path.length <= 1 && ai.destThreshold)
                    {
                        nodeThreshold = ai.destThreshold;
                    }
                    else if (this.isDinosaur(_body))
                    {
                        nodeThreshold = Math.round(nodeThreshold * Math.max(1, _body.mass + 1));
                    }
                    var vehicle = this.getObjectById(data.controllableId);
                    var bodyToUse = vehicle ? vehicle : _body;
                    var nodeDist = this.Dist(node.data.position[0], node.data.position[1], bodyToUse.position[0], bodyToUse.position[1]);
                    if (nodeDist < nodeThreshold)
                    {
                        //Node reached
                        ai.path.splice(0, 1);
                        if (ai.path.length == 0)
                        {
                            //Destination reached                            
                            if (!data.controllableId)
                            {
                                delete data.moveAngle;
                            }
                            data.bWantsToMove = false;
                            if (ai.destination)
                            {
                                if (ai.onDestinationTriggerId)
                                {
                                    this.executeTriggerById(ai.onDestinationTriggerId);
                                    delete ai.onDestinationTriggerId;
                                }
                                delete ai.destination;
                            }
                            if (!ai.bCamp)
                            {
                                if (ai.investigatePos)
                                {
                                    delete ai.investigatePos;
                                    delete ai.investigatePriority;
                                    if (!ai.enemy && !ai.wanderArea)
                                    {
                                        //Bot has reached investigate position, but no enemy found
                                        let checkAreaRange = 250;
                                        this.setAIInvestigatePos(_body, this.getNearestValidPosition([_body.position[0] + this.Random(-checkAreaRange, checkAreaRange), _body.position[1] + this.Random(-checkAreaRange, checkAreaRange)]));
                                    }
                                }
                                if (ai.returnPos)
                                {
                                    delete ai.returnPos;
                                }
                            }
                            if (ai.bPatrol && ai.patrolPoints)
                            {
                                ai.patrolPoints.push(ai.patrolPoints.shift());
                            }
                        }
                    }
                }
            }
            if (ai.path.length == 0)
            {
                //
            }
            else
            {
                var item = this.getCurrentCharacterInventoryItem(_body);
                if (ai.enemy && !ai.desiredItemId)
                {
                    if (!ai.enemy.data.shieldId && (ai.bEnemyLOS || ai.enemy.data.type == ObjectType.HELICOPTER))
                    {
                        let useRange = item.dropRange ? (item.range * Math.max(0.5, Math.min(1, (ai.botSkill / BotSkill.SKILL_GOD)))) : item.range;
                        if (ai.enemyDist < (useRange * 0.2) && !data.controllableId)
                        {
                            //Move back from enemy
                            if (this.getObjectById(ai.followTargetId))
                            {
                                if (ai.followTargetDist > 600)
                                {
                                    //delete data.moveAngle;
                                }
                                else
                                {
                                    data.moveAngle += this.ToRad(180);
                                }
                            }
                            else
                            {
                                data.moveAngle += this.ToRad(180);
                            }
                        }
                        else if (ai.enemyDist < (useRange * 0.25))
                        {
                            delete data.moveAngle; //Stop moving
                        }
                    }
                }
            }
        }
        let curInteractable = this.getObjectById(data.interactableId);
        if (curInteractable)
        {
            data.lookPos = [curInteractable.position[0], curInteractable.position[1]];
        }
        else if (ai.enemy && ai.enemy.data)
        {
            data.lookPos = [ai.enemy.position[0], ai.enemy.position[1]];
            if (ai.offsetX && ai.enemyDistMult)
            {
                if (data.type == ObjectType.DINOSAUR)
                {
                    switch (data.dinoType)
                    {
                        case Dinosaur.DILO:
                        case Dinosaur.NEEDLER:
                            //TODO Add offset
                            break;
                    }                    
                }
                data.lookPos[0] += ai.offsetX * ai.enemyDistMult;
                data.lookPos[1] += ai.offsetY * ai.enemyDistMult;
            }
            if (!data.controllableId && data.melee)
            {
                if (ai.enemy.data.type == ObjectType.CHARACTER && ai.enemyDist < data.melee.range && !ai.bFireCooldown)
                {
                    this.triggerCharacterMeleeAttack(_body);
                }
            }
        }
        else if (ai.investigatePos)
        {
            data.lookPos = [ai.investigatePos[0], ai.investigatePos[1]];
        }
        else if (ai.moveToPos)
        {
            data.lookPos = this.clone(ai.moveToPos);
        }
        if (this.game.cinematic && data.cinematicLookPos)
        {
            data.lookPos = data.cinematicLookPos;
        }
        ai.destThreshold = 50;
        if (data.controllableId)
        {
            if (ai.distanceTimer > 0)
            {
                ai.distanceTimer--;
            }
            else
            {
                //console.log("Check distance");                
                if (this.game.bSurvival && data.team == 0 && data.bCanInteract)
                {
                    if (this.Random(1, 10) == 1)
                    {
                        this.clearPlayerControllable(data.id);
                    }
                }
                ai.bHasNotMoved = ai.lastPos ? (this.DistPositions(ai.lastPos, _body.position) < 50) : false;
                ai.lastPos = [_body.position[0], _body.position[1]];
                ai.distanceTimer = ai.distanceTimerMax;
            }
        }
        if (data.controllableId)
        {
            ai.desiredVehicleId = null;
            var desiredVehicle = this.getObjectById(data.controllableId);
            if (desiredVehicle && desiredVehicle.data.seats)
            {
                if (desiredVehicle.data.seats.length > 1 && data.seatIndex != 0)
                {
                    if (!desiredVehicle.data.seats[0].pawnId && !desiredVehicle.data.bAutomated)
                    {
                        this.switchSeats(_body);
                    }
                }
            }
        }
        else
        {   
            var prevCommand = ai.currentCommand;
            var supportRequest = ai.bInteract && this.getNearbyRequest(_body, Commands.REQUEST_SUPPORT, 1000, data.playerId);
            if (!supportRequest) var followRequest = ai.bInteract && this.getNearbyRequest(_body, Commands.REQUEST_FOLLOW, 1000, data.playerId);
            if (!followRequest) var holdRequest = this.getNearbyRequest(_body, Commands.HOLD, 500, data.playerId);
            //if (!holdRequest) var repairRequest = this.getNearbyRequest(_body, Commands.REQUEST_REPAIR, 500);
            if (supportRequest)
            {
                ai.currentCommand = Commands.REQUEST_SUPPORT;
                ai.destThreshold = 100;
                ai.moveToPos = supportRequest.position;
                ai.desiredVehicleId = null;
                if (ai.bHold)
                {
                    delete ai.bCamp;
                    delete ai.bHold;
                }
            }
            else if (followRequest)
            {
                ai.currentCommand = Commands.REQUEST_FOLLOW;
                ai.destThreshold = 100;
                ai.moveToPos = followRequest.position;
                ai.desiredVehicleId = null;
                if (ai.bHold)
                {
                    delete ai.bCamp;
                    delete ai.bHold;
                }
            }
            else if (holdRequest)
            {
                ai.currentCommand = Commands.HOLD;
                ai.bCamp = true;
                ai.bHold = true;
                ai.campPos = [_body.position[0], _body.position[1]];
            }
            else if (!ai.bHold)
            {
                delete ai.currentCommand;
            }
            if (ai.currentCommand && ai.currentCommand != prevCommand)
            {
                this.onEvent({
                    eventId: GameServer.EVENT_PAWN_ACTION,
                    pawnId: _body.data.id,
                    type: GameServer.PAWN_VOX,
                    voxType: ai.currentCommand == Commands.HOLD ? "affirmative_hold" : "affirmative"
                });
            }
            if (!followRequest && !supportRequest)
            {
                if (ai.destination)
                {
                    ai.moveToPos = ai.destination;
                }
                else if (ai.objectiveItemId)
                {
                    var objectiveItem = this.getObjectById(ai.objectiveItemId);
                    if (objectiveItem)
                    {
                        ai.moveToPos = objectiveItem.position;
                    }
                }
                else if (ai.followTargetId && this.getObjectById(ai.followTargetId))
                {
                    ai.destThreshold = data.bHostage ? 50 : 200;
                    var followTarget = this.getObjectById(ai.followTargetId);
                    if (followTarget)
                    {
                        ai.moveToPos = followTarget.position;
                        ai.followTargetDist = this.DistBodies(followTarget, _body);
                    }
                }
                else if (ai.desiredItemId)
                {
                    var desiredItem = this.getObjectById(ai.desiredItemId);
                    if (!desiredItem)
                    {
                        ai.desiredItemId = null;
                        ai.moveToPos = null;
                    }
                    else
                    {
                        ai.desiredItemId = desiredItem.data.id;
                        ai.moveToPos = this.clone(desiredItem.position);
                    }
                }
                else if (ai.desiredVehicleId)
                {
                    var desiredVehicle = this.getObjectById(ai.desiredVehicleId);
                    if (!desiredVehicle || !this.hasAvailableSeat(desiredVehicle))
                    {
                        ai.desiredVehicleId = null;
                        ai.moveToPos = null;
                    }
                    else
                    {
                        ai.desiredVehicleId = desiredVehicle.data.id;
                        ai.moveToPos = this.clone(desiredVehicle.position);
                    }
                }
                else
                {
                    ai.moveToPos = null;
                    ai.desiredVehicleId = null;
                    if (this.isDinosaur(_body) && data.playerId)
                    {
                        if (!ai.enemy)
                        {
                            let playerOwner = this.getObjectById(data.playerId);
                            if (playerOwner)
                            {
                                ai.destThreshold = 200;
                                ai.moveToPos = playerOwner.position;
                            }
                        }
                    }                   
                    
                    if (ai.bWantsItem)
                    {
                        //TODO
                    }
                    else if (ai.bWantsVehicle)
                    {
                        desiredVehicle = this.getNearbyVehicle(_body);
                        if (desiredVehicle)
                        {
                            ai.desiredVehicleId = desiredVehicle.data.id;
                        }
                    }
                    if (data.team == 0)
                    {
                        switch (this.game.gameModeId)
                        {
                            case GameMode.EVOLUTION:
                                var turrets = this.getAutomatedTurrets();
                                turrets.sort((a, b) =>
                                {
                                    var distA = this.DistBodies(_body, a);
                                    var distB = this.DistBodies(_body, b);
                                    if (distA < distB) return -1;
                                    if (distA > distB) return 1;
                                    return 0;
                                });
                                if (turrets[0])
                                {
                                    ai.destThreshold = 200;
                                    ai.moveToPos = turrets[0].position;
                                }
                                break;

                            case GameMode.EXTRACTION:
                                var extractZone = this.getObjectById("extractZone");
                                if (extractZone)
                                {
                                    if (data.controllableId)
                                    {
                                        this.clearPlayerControllable(data.id);
                                    }
                                    ai.bWantsVehicle = false;
                                    ai.destThreshold = 50;
                                    ai.moveToPos = extractZone.position;
                                }
                                else
                                {
                                    var objectiveCrate = this.getNearestObjectiveCrate(_body);
                                    if (objectiveCrate)
                                    {
                                        ai.destThreshold = 50;
                                        ai.moveToPos = objectiveCrate.position;
                                    }
                                    else
                                    {
                                        var turrets = this.getAutomatedTurrets();
                                        turrets.sort((a, b) =>
                                        {
                                            var distA = this.DistBodies(_body, a);
                                            var distB = this.DistBodies(_body, b);
                                            if (distA < distB) return -1;
                                            if (distA > distB) return 1;
                                            return 0;
                                        });
                                        if (turrets[0])
                                        {
                                            ai.destThreshold = 200;
                                            ai.moveToPos = turrets[0].position;
                                        }
                                    }
                                }
                                break;
                        }
                    }
                }
            }
            if (ai.bCamp)
            {
                ai.moveToPos = ai.campPos;
            }
        }

        if (!ai.moveToPos)
        {
            switch (this.game.gameModeId)
            {
                case GameMode.HEADQUARTERS:
                case GameMode.DOMINATION:
                case GameMode.CONQUEST:
                    ai.bPreferObjective = this.Random(1, 5) > 1;
                    if (ai.bPreferObjective)
                    {
                        var flag = this.getAIBestDominationFlag(_body);
                        if (flag)
                        {
                            ai.destThreshold = 100;
                            ai.moveToPos = flag.position;
                        }
                    }
                    else if (ai.enemy)
                    {
                        ai.moveToPos = ai.enemy.position;
                    }
                    break;
                case GameMode.DESTRUCTION:
                    ai.bPreferObjective = data.type == ObjectType.CHARACTER;
                    if (ai.bPreferObjective)
                    {
                        var bombs = this.getAIBestBombCrate(_body);
                        var bestBomb = bombs[0];
                        if (bestBomb)
                        {
                            ai.destThreshold = (bestBomb.data.bBombPlanted && bestBomb.data.team != data.team) || bestBomb.data.currentPawnId ? 200 : 30;
                            ai.moveToPos = bestBomb.position;
                        }
                        else if (ai.enemy)
                        {
                            ai.moveToPos = ai.enemy.position;
                        }
                    }
                    else if (ai.enemy)
                    {
                        ai.moveToPos = ai.enemy.position;
                    }
                    break;
                case GameMode.CAPTURE_THE_FLAG:
                    ai.bPreferObjective = this.Random(1, 5) > 1;
                    if (ai.bPreferObjective || data.bHasFlag)
                    {
                        var enemyFlag = this.getFlagCTF(data.team == 0 ? 1 : 0);
                        var homeFlag = this.getFlagCTF(data.team);
                        if (homeFlag && enemyFlag)
                        {
                            if (enemyFlag.data.carrierId == data.id)
                            {
                                data.bHasFlag = true;
                                //ai.activityTimer = 0;
                                ai.moveToPos = homeFlag.position;
                            }
                            else
                            {
                                delete data.bHasFlag;
                                if (homeFlag.data.bAwayFromHome)
                                {
                                    var distToHomeFlag = this.Dist(homeFlag.position[0], homeFlag.position[1], _body.position[0], _body.position[1]);
                                    var distToEnemyFlag = this.Dist(enemyFlag.position[0], enemyFlag.position[1], _body.position[0], _body.position[1]);
                                    if (distToHomeFlag < distToEnemyFlag)
                                    {
                                        ai.moveToPos = homeFlag.position;
                                    }
                                    else
                                    {
                                        ai.moveToPos = enemyFlag.position;
                                        if (enemyFlag.data.carrierId)
                                        {
                                            ai.destThreshold = 200;
                                        }
                                    }
                                }
                                else
                                {
                                    ai.moveToPos = enemyFlag.position;
                                    if (enemyFlag.data.carrierId)
                                    {
                                        //ai.destThreshold = 200;
                                    }
                                }
                            }
                        }                        
                    }
                    else if (ai.enemy)
                    {
                        ai.moveToPos = ai.enemy.position;
                    }
                    break;
                case GameMode.DINO_RESCUE:
                    if (!data.bHostage)
                    {
                        ai.bPreferObjective = this.Random(1, 5) > 1;
                        var hostage = ai.bPreferObjective ? this.getNearestHostage(_body) : null;
                        if (hostage)
                        {
                            ai.moveToPos = hostage.position;
                            if (data.team == this.game.gameModeData.rescueTeam)
                            {
                                ai.destThreshold = 50;
                                if (this.isGuidingHostage(_body))
                                {
                                    ai.moveToPos = this.getRescueZonePosition();
                                }
                            }
                            else
                            {
                                ai.destThreshold = 200;
                            }
                        }
                        else
                        {
                            if (ai.enemy)
                            {
                                ai.moveToPos = ai.enemy.position;
                            }
                        }
                    }
                    else if (ai.enemy)
                    {
                        ai.moveToPos = ai.enemy.position;
                    }
                    break;
                default:
                    ai.bPreferObjective = false;
                    //var bombs = this.getAIBestBombCrate(_body);
                    var bestBomb = null; //bombs[0];    
                    if (ai.bWantsItem)
                    {
                        //...
                    }
                    else if (ai.enemy)
                    {
                        ai.moveToPos = ai.enemy.position;
                    }
                    else if (bestBomb)
                    {
                        ai.destThreshold = (bestBomb.data.bBombPlanted && bestBomb.data.team != data.team) || bestBomb.data.currentPawnId ? 200 : 30;
                        ai.moveToPos = bestBomb.position;
                    }
                    else if (ai.investigatePos)
                    {
                        ai.moveToPos = ai.investigatePos;
                    }
                    else if (ai.returnPos)
                    {
                        ai.moveToPos = ai.returnPos;
                    }
                    break;
            }
        }

        var item = this.getCurrentCharacterInventoryItem(_body);
        if (data.bCanLunge)
        {
            let itemRange = item ? (item.lungeRange ? item.lungeRange : item.range) : 1000;
            this.setDataValue(_body, "bLunge", ai.enemyDist < 50 || (ai.bEnemyLOS && (ai.enemyDist < itemRange * (ai.botSkill + 1))));
        }
        var bOverlaps = false;
        if (ai.enemy)
        {
            var aabb = _body.getAABB();
            var enemyAABB = ai.enemy.getAABB();
            if (aabb && enemyAABB)
            {
                bOverlaps = aabb.overlaps(enemyAABB);
            }
        }
        var aiWeaponRange = Math.min(item.range, 3000); //Max AI range
        var bTriggerFire = ((ai.enemyDist < aiWeaponRange || bOverlaps) && ai.enemyDist < ai.lookRange && ai.bEnemyLOS && (!data.bStunned && !data.bFlashed));
        if (this.getCurrentCharacterInventoryItem(_body).id == "blowtorch" && this.getTouchingRepairableObject(_body))
        {
            bTriggerFire = true;
        }
        this.triggerCharacterWeapon({
            eventId: GameServer.EVENT_PLAYER_TRIGGER_WEAPON,
            playerId: data.id,
            value: bTriggerFire, //&& this.hasInventoryAmmo(_body)
            worldPosition: data.lookPos
        });
        data.bWantsToMove = data.moveAngle != null;
        if (ai.bFireCooldown)
        {
            if (ai.fireCooldownTimer > 0)
            {
                ai.fireCooldownTimer--;
            }
            else
            {
                ai.bFireCooldown = false;
                ai.fireCooldownTimer = ai.fireCooldownTimerMax;
            }
        }
        else
        {
            if (ai.fireBurstTimer > 0)
            {
                ai.fireBurstTimer--;
            }
            else
            {
                ai.bFireCooldown = true;
                ai.fireBurstTimer = ai.fireBurstTimerMax;
            }
        }
        var curWeapon = data.inventory[data.currentInventoryIndex];        
        if (curWeapon.fireMode != Weapon.MODE_SEMI)
        {
            ai.semiCooldownTimer = 0;
        }
        else if (curWeapon.fireMode == Weapon.MODE_SEMI && ai.semiCooldownTimerMax > 0)
        {
            if (ai.semiCooldownTimer <= 0)
            {
                ai.semiCooldownTimer = ai.semiCooldownTimerMax;
            }
            else
            {
                ai.semiCooldownTimer--;
            }
        }
        if (data.bWantsToFire)
        {
            var curWeapon = data.inventory[data.currentInventoryIndex];
            if (!ai.bFireCooldown)
            {
                data.bWantsToFire = data.bWantsToFire && ai.semiCooldownTimer == 0;
                if (data.bWantsToFire)
                {
                    data.weapon.bFireHandler = true;
                }
            }
            else
            {
                data.bWantsToFire = false;
            }
        }
        else
        {
            data.bWantsToFire = false;
        }

        if (data.type == ObjectType.CHARACTER)
        {
            var bWantsToSprint = !data.bWantsToFire && data.bWantsToMove && this.characterCanSprint(_body);
            if (ai.botSkill >= BotSkill.SKILL_HARD)
            {
                this.setDataValue(_body, "bSprinting", bWantsToSprint);
                this.setDataValue(_body, "bCrouching", !data.bWantsToMove && !data.bSprinting && this.characterCanCrouch(_body) && !data.bZombie);
            }
            else
            {
                this.setDataValue(_body, "bSprinting", bWantsToSprint && ai.enemyDist > 2000);
            }
        }

        //Bot is in a vehicle
        if (data.controllableId)
        {
            var controllable = this.getObjectById(data.controllableId);
            if (controllable) //&& !controllable.data.bAutomated
            {
                switch (controllable.data.type)
                {
                    case ObjectType.TANK:
                    case ObjectType.HELICOPTER:
                    case ObjectType.CAR:
                    case ObjectType.MOUNTED_WEAPON:
                        if (data.seatIndex == 0)
                        {
                            if (ai.followTargetId)
                            {
                                if (this.getObjectById(ai.followTargetId))
                                {
                                    if (ai.followTargetDist > 600 || controllable.data.type != ObjectType.MOUNTED_WEAPON)
                                    {
                                        this.clearPlayerControllable(data.id);
                                    }
                                }
                            }
                            if (!this.game.bSurvival || data.team == 0)
                            {
                                var vehicleRequest = this.getNearbyRequest(_body, Commands.REQUEST_VEHICLE, controllable.data.type == ObjectType.MOUNTED_WEAPON ? 400 : 1500);
                            }
                            if (vehicleRequest)
                            {
                                if (this.hasAvailableSeat(controllable) && vehicleRequest.dist > 100)
                                {
                                    var desiredPos = vehicleRequest.position;
                                }
                                else
                                {
                                    this.clearPlayerControllable(data.id);
                                }
                            }
                            else if (ai.enemy)
                            {
                                switch (ai.enemy.data.type)
                                {
                                    case ObjectType.HELICOPTER:
                                        desiredPos = [ai.enemy.position[0], ai.enemy.position[1]];
                                        break;
                                    default:
                                        if (controllable.data.type == ObjectType.HELICOPTER)
                                        {
                                            desiredPos = [ai.enemy.position[0], ai.enemy.position[1]];
                                        }
                                        else
                                        {
                                            desiredPos = [ai.enemy.position[0], ai.enemy.position[1]];
                                        }
                                        break;
                                }
                                desiredPos[1] = Math.max(0, desiredPos[1]);
                            }
                            if (desiredPos)
                            {
                                var keyInfo = {
                                    up: 0,
                                    down: 0,
                                    left: 0,
                                    right: 0
                                };
                                var dist = this.Dist(desiredPos[0], desiredPos[1], controllable.position[0], controllable.position[1]);
                                switch (controllable.data.type)
                                {
                                    case ObjectType.CAR:
                                        var threshold = 30;
                                        break;
                                    case ObjectType.TANK:
                                        threshold = 100;
                                        break;
                                    default:
                                        threshold = 500;
                                        break;
                                }
                                if (controllable.data.type == ObjectType.HELICOPTER)
                                {
                                    if (dist > threshold)
                                    {
                                        if (desiredPos[0] < controllable.position[0])
                                        {
                                            keyInfo[Control.LEFT] = true;
                                        }
                                        else if (desiredPos[0] > controllable.position[0])
                                        {
                                            keyInfo[Control.RIGHT] = true;
                                        }
                                        if (desiredPos[1] < controllable.position[1])
                                        {
                                            keyInfo[Control.UP] = true;
                                        }
                                        else if (desiredPos[1] > controllable.position[1])
                                        {
                                            keyInfo[Control.DOWN] = true;
                                        }
                                    }
                                    else
                                    {
                                        if (desiredPos[0] < controllable.position[0])
                                        {
                                            keyInfo[Control.RIGHT] = true;
                                        }
                                        else if (desiredPos[0] > controllable.position[0])
                                        {
                                            keyInfo[Control.LEFT] = true;
                                        }
                                    }
                                }
                                else
                                {
                                    if (data.moveAngle != null)
                                    {
                                        if (dist > threshold && !ai.bHasNotMoved)
                                        {
                                            keyInfo[Control.UP] = true;
                                        }
                                        else
                                        {
                                            keyInfo[Control.DOWN] = true;
                                        }
                                        if (controllable.mass > 0)
                                        {
                                            if ((controllable.angle - data.moveAngle > 0) && !ai.bHasNotMoved)
                                            {
                                                keyInfo[Control.LEFT] = true;
                                            }
                                            else
                                            {
                                                keyInfo[Control.RIGHT] = true;
                                            }
                                            controllable.angle -= (controllable.angle - data.moveAngle) * 0.01;
                                        }
                                    }
                                }
                                if (Object.keys(keyInfo).length > 0)
                                {
                                    this.requestEvent({
                                        eventId: GameServer.EVENT_PLAYER_INPUT,
                                        playerId: data.id,
                                        keyInfo: keyInfo
                                    });
                                }
                            }
                        }
                        if (controllable.data.weapons)
                        {
                            var weapon = this.getCurrentVehicleWeapon(controllable, data.seatIndex); //controllable.data.weapons[data.seatIndex];
                            if (weapon && weapon.weaponData && weapon.weaponData.damage > 0)
                            {
                                if (controllable.data.vehicleId == MountedWeapon.BGM71 || controllable.data.type == ObjectType.HELICOPTER)
                                {
                                    ai.bEnemyLOS = !this.isInSmoke(_body);
                                }
                                weapon.bWantsToFire = ai.bEnemyLOS && ai.enemyDist < ai.lookRange;
                                if (weapon.weaponData.bRequireLock && !this.isVehicle(ai.enemy) && ai.botSkill < BotSkill.SKILL_INSANE)
                                {
                                    //weapon.bWantsToFire = false;
                                }      
                                var muzzle = this.getVehicleMuzzlePosition(controllable, data.seatIndex);
                                var weaponAimSpeed = ai.botSkill >= BotSkill.SKILL_INSANE ? 1 : 0.1;                                
                                if (ai.enemy)
                                {                  
                                    var aim = [ai.enemy.position[0], ai.enemy.position[1]];
                                    if (ai.offsetX && ai.offsetY)
                                    {
                                        if (controllable.data.type == ObjectType.TANK)
                                        {
                                            aim[0] += (ai.offsetX * ai.enemyDistMult) * 0.1;
                                            aim[1] += (ai.offsetY * ai.enemyDistMult) * 0.1;
                                        }
                                        else if (controllable.data.type == ObjectType.MOUNTED_WEAPON)
                                        {
                                            aim[0] += (ai.offsetX * ai.enemyDistMult) * 0.9;
                                            aim[1] += (ai.offsetY * ai.enemyDistMult) * 0.9;
                                        }
                                        else
                                        {
                                            aim[0] += (ai.offsetX * ai.enemyDistMult);
                                            aim[1] += (ai.offsetY * ai.enemyDistMult);
                                        }
                                    }
                                    var rad = this.Angle(muzzle[0], muzzle[1], aim[0], aim[1]);
                                    if (isNaN(rad))
                                    {
                                        console.warn(aim, ai.offsetX, ai.offsetY, ai.enemyDistMult);
                                    }
                                    this.setVehicleWeaponAimRotation(controllable, data.seatIndex, weapon, rad, weaponAimSpeed);
                                }
                                else if (data.lookPos)
                                {
                                    rad = this.Angle(muzzle[0], muzzle[1], data.lookPos[0], data.lookPos[1]);
                                    this.setVehicleWeaponAimRotation(controllable, data.seatIndex, weapon, rad, weaponAimSpeed);
                                }
                            }
                        }
                        break;
                }
                if (this.canExitVehicle(_body))
                {
                    if (controllable.data.type == ObjectType.CAR)
                    {
                        if (ai.enemyDist < 100 && Math.abs(this.getTotalVelocity(controllable) < 50))
                        {
                            //this.clearPlayerControllable(data.id);
                        }
                    }
                }
            }
        }
        else if (ai.bInteract)
        {
            if (data.bCanInteract && !data.bInteracting && ai.ticker == 0)
            {
                var interactable = this.getTouchingInteractable(_body);
                if (interactable)
                {
                    this.startInteraction(_body, interactable);
                }
            }
        }

        if (data.lookPos)
        {
            var aimRad = this.Angle(_body.position[0], _body.position[1], data.lookPos[0], data.lookPos[1]);
            if (!isNaN(aimRad))
            {
                data.desiredAimRotation = aimRad;                
            }
            else
            {
                console.warn("PROBLEM!", _body.data.id, _body.position, data.lookPos);
            }
        }
    }

    getBestSurvivalSpawnPosition(_team, _body)
    {
        var chars = this.getCharactersOnTeam(0);
        if (chars.length > 0)
        {
            return chars[this.Random(0, chars.length - 1)].position;
        }
        return this.getBestSpawnPosition(_team, _body);
    }

    getRandomSpawnPosition()
    {
        var map = this.getCurrentMapData();
        var spawns = map.spawns;
        if (!spawns || !spawns.length)
        {
            return this.getRandomOpenNodePosition();
        }
        return spawns[this.Random(0, spawns.length - 1)];
    }

    getRandomOpenNodePosition()
    {
        if (this.game.nodes)
        {
            var arr = [];
            for (var i = 0; i < this.game.nodes.length; i++)
            {
                let nodes = this.game.nodes[i];
                for (var j = 0; j < nodes.length; j++)
                {
                    let node = nodes[j];
                    if (node != 0)
                    {
                        arr.push([j * this.game.nodeThreshold, i * this.game.nodeThreshold]);
                    }
                }
            }
            if (arr.length > 0)
            {
                return arr[this.Random(0, arr.length - 1)];
            }
        }
        return [this.Random(0, this.getMapWidth()), this.Random(0, this.getMapHeight())];
    }

    getBestSpawnPosition(_team, _body)
    {
        try
        {
            var map = this.getCurrentMapData();
            var spawns = map.spawns;
            if (!spawns || !spawns.length)
            {
                return this.getRandomOpenNodePosition(); //[this.Random(0, this.getMapWidth()), this.Random(0, this.getMapHeight())];
            }
            if (this.getCharacters().length == 0)
            {
                return spawns[this.Random(0, spawns.length - 1)];
            }
            var bestSpawns = [];
            var objects = this.getTypes([
                ObjectType.CHARACTER,
                ObjectType.DINOSAUR,
                ObjectType.CAR,
                ObjectType.TANK,
                ObjectType.HELICOPTER,
                ObjectType.MOUNTED_WEAPON,
                ObjectType.FLAG
            ]);
            for (var i = 0; i < spawns.length; i++)
            {
                let curSpawn = spawns[i];
                let danger = 0;
                let flags = 0;
                let enemies = 0;
                for (var j = 0; j < objects.length; j++)
                {
                    let cur = objects[j];
                    if (cur && cur == _body)
                    {
                        continue;
                    }
                    if (this.isVehicle(cur) && !cur.data.bAutomated)
                    {
                        continue;
                    }
                    let curDist = this.Dist(cur.position[0], cur.position[1], curSpawn[0], curSpawn[1]);
                    let maxDist = this.getMapWidth();
                    if (curDist < maxDist)
                    {
                        var distVal = (curDist / maxDist);
                        if (cur.data.team != _team)
                        {
                            var bLOS = curDist < 500 || (this.game.bSurvival || 1 ? false : this.isInLOS(curSpawn, [cur.position[0], cur.position[1]], cur));
                            if (bLOS)
                            {
                                enemies++;
                            }
                            //Enemy
                            switch (cur.data.type)
                            {
                                case ObjectType.FLAG:
                                    if (this.game.gameModeData.id == GameMode.DOMINATION)
                                    {
                                        danger += distVal * 3;
                                    }
                                    else
                                    {
                                        danger += distVal;
                                    }
                                    break;

                                default:
                                    danger += distVal;
                                    break;
                            }
                        }
                        else
                        {
                            //Ally
                            switch (cur.data.type)
                            {
                                case ObjectType.FLAG:
                                    if (this.game.gameModeData.id == GameMode.DOMINATION)
                                    {
                                        if (curDist < 600)
                                        {
                                            flags++;
                                        }
                                        danger -= distVal * 3;
                                    }
                                    break;

                                default:
                                    danger -= distVal;
                                    break;
                            }
                        }
                    }
                }
                bestSpawns.push({
                    index: i,
                    flags: flags,
                    enemies: enemies,
                    danger: danger
                });
            }
            if (bestSpawns.length == 1)
            {
                var selected = spawns[bestSpawns[0].index];
                var res = [
                    selected[0] + this.Random(-25, 25),
                    selected[1] + this.Random(-25, 25)
                ];
                res[0] = Math.max(0, Math.min(this.getMapWidth(), res[0]));
                res[1] = Math.max(0, Math.min(this.getMapHeight(), res[1]));
            }
            else if (bestSpawns.length >= 2)
            {
                bestSpawns.sort(function (a, b)
                {
                    if (a.flags > b.flags) return -1;
                    if (a.flags < b.flags) return 1;
                    if (a.enemies > b.enemies) return 1;
                    if (a.enemies < b.enemies) return -1;
                    if (a.danger > b.danger) return -1;
                    if (a.danger < b.danger) return 1;
                    return 0;
                });
                bestSpawns = [bestSpawns[0], bestSpawns[1]];
                this.ShuffleArray(bestSpawns);
                var selected = spawns[bestSpawns[0].index];
                var res = [
                    selected[0] + this.Random(-25, 25),
                    selected[1] + this.Random(-25, 25)
                ];
                res[0] = Math.max(0, Math.min(this.getMapWidth(), res[0]));
                res[1] = Math.max(0, Math.min(this.getMapHeight(), res[1]));
                return res;
            }
        }
        catch (e)
        {
            console.warn(e);
        }
        return [this.Random(0, this.getMapWidth()), this.Random(0, this.getMapHeight())];
    }

    isInLOS(_startPos, _endPos, _target)
    {
        var result = this.raycast(_startPos[0], _startPos[1], _endPos[0], _endPos[1], _target);
        if (result)
        {
            if (result.length == 0)
            {
                return false;
            }
            else
            {
                for (var i = 0; i < result.length; i++)
                {
                    var cur = result[i].body;
                    if (result[i].distance < 1000)
                    {
                        switch (cur.data.type)
                        {
                            case ObjectType.GROUND:
                                return false;
                            case ObjectType.CHARACTER:
                                return cur == _target;
                        }
                    }
                }
            }
        }
        return false;
    }

    getBestInventoryIndex(_body, _enemyPawn, _enemyDist)
    {
        var ai = _body.ai;
        var data = _body.data;
        var inventory = data.inventory;
        var bestIndex = data.currentInventoryIndex;
        var bestValue = 0;
        if (data.type == ObjectType.CHARACTER && data.bSwitchToMelee && !data.controllableId)
        {
            if (ai.enemy && !ai.enemy.data.controllableId && !this.isVehicle(ai.enemy) && !ai.bEnemyLOS && _enemyDist > 1000 && data.inventory[Character.INDEX_MELEE])
            {
                return Character.INDEX_MELEE;
            }
        }
        for (var i = 0; i < inventory.length; i++)
        {
            var item = inventory[i];
            if (item)
            {
                var damage = item.damage;
                if (item.type == Weapon.TYPE_LAUNCHER)
                {
                    damage *= 0.5;
                }
                var itemValue = damage * item.magSize;
                if (item.mag > 0 || item.ammo > 0 || data.weapon.bUnlimitedAmmo)
                {
                    if (_enemyPawn && (this.isVehicle(_enemyPawn) || _enemyPawn.data.controllableId || _enemyPawn.data.shieldId))
                    {
                        if (item.bRocket || item.bGrenade)
                        {
                            bestIndex = i;
                        }
                    }
                    else
                    {
                        if (_enemyPawn && _enemyDist < 500 && item.type == Weapon.TYPE_SHOTGUN)
                        {
                            bestIndex = i;
                        }
                        else if (_enemyPawn && _enemyDist < 200 && item.id == "riot_shield")
                        {
                            bestIndex = i;
                        }
                        else if (itemValue > bestValue && !item.bRequireLock)
                        {
                            bestIndex = i;
                            bestValue = itemValue;
                        }
                    }
                }
            }
        }
        return bestIndex;
    }

    updateVehicleWeaponAimRotation(_vehicle, _seatIndex, _weaponIndex, _val)
    {
        try
        {
            if (_vehicle)
            {
                var weapon = _vehicle.data.weapons[_seatIndex][_weaponIndex];
                if (weapon)
                {
                    var seat = _vehicle.data.seats[_seatIndex];
                    if (seat)
                    {
                        var prev = weapon.aimRotation;
                        weapon.aimRotation = _val;
                        if (prev != _val)
                        {
                            this.onEvent({
                                eventId: GameServer.EVENT_PAWN_ACTION,
                                pawnId: _vehicle.data.id,
                                type: GameServer.PAWN_VEHICLE_UPDATE,
                                seatIndex: _seatIndex,
                                weaponIndex: _weaponIndex,
                                aimRotation: weapon.aimRotation
                            });
                        }
                    }
                }
            }
        }
        catch (e)
        {
            console.warn(e);
        }
    }

    setVehicleWeaponAimRotation(_vehicle, _seatIndex, _weapon, _val, _speed, _bForce)
    {
        if (!_vehicle)
        {
            console.warn("Missing vehicle reference");
        }
        if (_weapon)
        {
            var prev = _weapon.aimRotation;
            if (_weapon.aimRotation == null)
            {
                _weapon.aimRotation = 0;
            }
            var val = _val;
            if (isNaN(val))
            {
                val = 0;
            }
            var rad = this.WrapAngle(_weapon.aimRotation - _val, true);
            var mult = (_weapon.aimSpeed ? _weapon.aimSpeed : 1) * (_speed ? _speed : 1);
            if (_bForce)
            {
                mult = 1;
            }
            var radMult = rad * mult;
            if (_weapon.maxRad)
            {
                if (rad > 0)
                {
                    _weapon.aimRotation -= Math.min(_weapon.maxRad, radMult);
                }
                else
                {
                    _weapon.aimRotation -= Math.max(-_weapon.maxRad, radMult);
                }
            }
            else
            {
                _weapon.aimRotation -= radMult;
            }
            if (isNaN(_weapon.aimRotation))
            {
                console.warn(_weapon.aimRotation);
                _weapon.aimRotation = 0;
            }
            if (prev != _weapon.aimRotation)
            {
                if (_vehicle)
                {
                    var seat = _vehicle.data.seats[_seatIndex];
                    var weaponIndex = (seat && seat.weaponIndex != null) ? seat.weaponIndex : 0;
                    this.onEvent({
                        eventId: GameServer.EVENT_PAWN_ACTION,
                        pawnId: _vehicle.data.id,
                        type: GameServer.PAWN_VEHICLE_UPDATE,
                        seatIndex: _seatIndex,
                        weaponIndex: weaponIndex,
                        aimRotation: _weapon.aimRotation
                    });
                }
            }
        }
    }

    needsAmmo(_body)
    {
        if (!_body)
        {
            return false;
        }
        var data = _body.data;
        if (data.weapon.bUnlimitedAmmo)
        {
            return false;
        }
        var inventory = data.inventory;
        for (var i = 0; i < 2; i++)
        {
            let item = inventory[i];
            if (item && !item.bMelee && item.magSize != null && item.ammo != null)
            {
                if (item.ammo < item.magSize)
                {
                    return true;
                }
            }
        }
        return false;
    }

    hasInventoryAmmo(_body)
    {
        if (!_body)
        {
            return false;
        }
        var data = _body.data;
        var inventory = data.inventory;
        for (var i = 0; i < 2; i++)
        {
            let item = inventory[i];
            if (item)
            {
                if (item.mag > 0 || item.ammo > 0)
                {
                    return true;
                }
            }
        }
        if (data.weapon.bUnlimitedAmmo)
        {
            return true;
        }
        return false;
    }

    getNearestFriendlyPawn(_pawn, _settings)
    {
        //var pawns = this.getPawns();
        var pawn = null;
        var bLOS = false;
        var lastDist = Number.MAX_VALUE;
        var pawnTypes = null;
        var scale = undefined;
        var bPlayerOnly = false;
        var bInjured = false;
        if (_settings)
        {
            if (_settings["bLOS"] != null)
            {
                bLOS = _settings["bLOS"];
            }
            if (_settings["maxRange"] != null)
            {
                lastDist = _settings["maxRange"];
            }
            if (_settings["pawnTypes"] != null)
            {
                pawnTypes = _settings["pawnTypes"];
            }
            if (_settings["scale"] != null)
            {
                scale = _settings["scale"];
            }
            if (_settings["bPlayerOnly"] != null)
            {
                bPlayerOnly = _settings["bPlayerOnly"];
            }
            if (_settings["bInjured"] != null)
            {
                bInjured = _settings["bInjured"];
            }
        }
        var pawns = this.getTypes(pawnTypes ? pawnTypes : [
            ObjectType.CHARACTER,
            ObjectType.DINOSAUR,
            ObjectType.FLYING_DINOSAUR,
            ObjectType.HELICOPTER,
            ObjectType.TANK,
            ObjectType.CAR,
            ObjectType.MOUNTED_WEAPON,
            ObjectType.EGG
        ]);
        for (var i = 0; i < pawns.length; i ++)
        {
            let curPawn = pawns[i];
            let data = curPawn.data;
            if (!data || !data.health || data.team != _pawn.data.team)
            {
                continue;
            }
            if (curPawn.data.id == _pawn.data.id)
            {
                continue;
            }
            if (bPlayerOnly && curPawn.data.bBot)
            {
                continue;
            }
            if (bInjured && curPawn.data.health >= curPawn.data.maxHealth)
            {
                continue;
            }
            if (pawnTypes)
            {
                if (pawnTypes.indexOf(curPawn.data.type) < 0)
                {
                    continue;
                }
            }
            if (scale != undefined)
            {
                if (scale > 0)
                {
                    if (curPawn.position[0] < _pawn.position[0])
                    {
                        continue;
                    }
                }
                else if (scale < 0)
                {
                    if (curPawn.position[0] > _pawn.position[0])
                    {
                        continue;
                    }
                }
            }
            if (bLOS)
            {
                if (!this.checkLineOfSight(_pawn.position, curPawn.position))
                {
                    continue;
                }
            }
            if (curPawn.data.type == ObjectType.HELICOPTER)
            {
                if (curPawn.data.bPendingRemoval)
                {
                    continue;
                }
            }
            var dist = this.Dist(_pawn.position[0], _pawn.position[1], curPawn.position[0], curPawn.position[1]);
            if (dist < lastDist)
            {
                lastDist = dist;
                pawn = curPawn;
            }
        }
        return pawn;
    }

    rescueHostage(_hostage, _playerId)
    {
        var ps = this.getPlayerById(_playerId);
        if (ps)
        {
            ps.score++; //TODO
            this.onEvent({
                eventId: GameServer.EVENT_PLAYER_UPDATE,
                playerId: ps.id,
                data: {
                    score: ps.score
                }
            });
        }
        var obj = {
            bHostageRescued: 1,
            playerId: _playerId
        };
        switch (this.game.gameModeId)
        {
            case GameMode.DINO_RESCUE:
                this.game.gameModeData.numHostages--;
                var num = Math.min(this.game.gameModeData.numHostages, this.getHostages().length - 1);
                if (num <= 0)
                {
                    this.winRound(MatchState.END_CONDITION_DINOS_RESCUED, this.game.gameModeData.rescueTeam, 1);
                }
                obj.numHostages = this.game.gameModeData.numHostages;
                break;
        }
        this.onEvent({
            eventId: GameServer.EVENT_GAME_UPDATE,
            data: obj
        });
        this.removeNextStep(_hostage);
    }

    getHostages()
    {
        var arr = [];
        var pawns = this.getPawns(null, true);
        for (var i = 0; i < pawns.length; i++)
        {
            let pawn = pawns[i];
            if (pawn.data.bHostage)
            {
                arr.push(pawn);
            }
        }
        return arr;
    }

    isGuidingHostage(_pawn)
    {
        if (_pawn)
        {
            var hostages = this.getHostages();
            for (var i = 0; i < hostages.length; i++)
            {
                let hostage = hostages[i];
                if (hostage.ai.followTargetId == _pawn.data.id)
                {
                    return true;
                }
            }
        }
        return false;
    }

    getNearestHostage(_pawn)
    {
        var arr = [];
        var pawns = this.getPawns(null, true);
        for (var i = 0; i < pawns.length; i++)
        {
            let pawn = pawns[i];
            if (pawn.data.bHostage)
            {
                arr.push({
                    pawn: pawn,
                    dist: this.Dist(pawn.position[0], pawn.position[1], _pawn.position[0], _pawn.position[1]),
                    bFollowing: pawn.ai.followTargetId != null
                });
            }
        }
        if (arr.length > 0)
        {
            arr.sort(function (a, b)
            {
                if (a.bFollowing && !b.bFollowing) return 1;
                if (!a.bFollowing && b.bFollowing) return -1;
                if (a.dist > b.dist) return 1;
                if (a.dist < b.dist) return -1;
                return 0;
            });
            return arr[0] ? arr[0].pawn : null;
        }
        return null;
    }

    getNearestEnemyPawn(_pawn, _settings)
    {
        if (this.game.cinematic || this.isGeneratingNodes() || !_pawn.world)
        {
            return null;
        }
        var bLOS = true;
        var bPreferDistance = false;
        var bIgnoreOutOfSight = false;
        var bAllTypes = false;
        var pawnTypes = null;
        var scale = undefined;
        var maxRange = this.settings.maxWorldSize;
        var bLockOn = false;
        var priority = null; //this.game.bSurvival ? ObjectType.TANK : null;
        if (_settings)
        {
            if (_settings["bLOS"] != null)
            {
                bLOS = _settings["bLOS"];
            }
            if (_settings["maxRange"] != null)
            {
                maxRange = _settings["maxRange"];
            }
            if (_settings["pawnTypes"] != null)
            {
                pawnTypes = _settings["pawnTypes"];
            }
            if (_settings["scale"] != null)
            {
                scale = _settings["scale"];
            }
            if (_settings["bPreferDistance"] != null)
            {
                bPreferDistance = _settings["bPreferDistance"];
            }
            if (_settings["bIgnoreOutOfSight"] != null)
            {
                bIgnoreOutOfSight = _settings["bIgnoreOutOfSight"];
            }
            if (_settings["bAllTypes"] != null)
            {
                bAllTypes = _settings["bAllTypes"];
            }
            if (_settings.priority)
            {
                priority = _settings.priority;
            }
            if (_settings.bLockOn != undefined)
            {
                bLockOn = _settings.bLockOn;
            }
        }
        var enemies = [];
        var pawns = this.getTypes(pawnTypes ? pawnTypes : [
            ObjectType.CHARACTER,
            ObjectType.DINOSAUR,
            ObjectType.FLYING_DINOSAUR,
            ObjectType.HELICOPTER,
            ObjectType.TANK,
            ObjectType.CAR,
            ObjectType.MOUNTED_WEAPON,
            ObjectType.EGG
        ]);
        pawns.sort((a, b) =>
        {
            let distA = this.DistBodies(a, _pawn);
            let distB = this.DistBodies(b, _pawn);
            if (distA < distB) return -1;
            if (distA > distB) return 1; 
            return 0;
        });
        for (var i = 0; i < pawns.length; i ++)
        {
            let curPawn = pawns[i];
            let data = curPawn.data;
            if (!data || data.bPendingRemoval || data.bUntargetable || data.bInvisible || data.bSpawnProtection || !data.health || data.team == _pawn.data.team)
            {
                continue;
            }
            let bLOS = true;
            let fallback = 0;
            let dist = this.Dist(_pawn.position[0], _pawn.position[1], curPawn.position[0], curPawn.position[1]);
            if (dist > maxRange)
            {
                continue;
            }
            if (pawnTypes)
            {
                if (pawnTypes.indexOf(curPawn.data.type) == -1)
                {
                    if (bAllTypes)
                    {
                        fallback = 1;
                    }
                    else
                    {
                        continue;
                    }
                }
            }
            if (scale != null)
            {
                if (scale > 0)
                {
                    if (curPawn.position[0] < _pawn.position[0])
                    {
                        continue;
                    }
                }
                else if (scale < 0)
                {
                    if (curPawn.position[0] > _pawn.position[0])
                    {
                        continue;
                    }
                }
            }
            if (bLockOn)
            {
                if (curPawn.data.bECM)
                {
                    continue;
                }
            }
            if (this.isCharacter(curPawn))
            {
                if (curPawn.data.controllableId)
                {
                    var veh = this.getObjectById(curPawn.data.controllableId);
                    if (veh)
                    {
                        if (veh.data.type == ObjectType.TANK || veh.data.type == ObjectType.HELICOPTER)
                        {
                            continue;
                        }
                    }
                }
            }
            else if (this.isVehicle(curPawn))
            {
                if (!curPawn.data.health || curPawn.data.bDisabled)
                {
                    continue;
                }
                else if (!this.vehicleHasOccupant(curPawn))
                {
                    if (this.game.bSurvival)
                    {
                        if (_pawn.data.team == 0)
                        {
                            continue;
                        }
                    }
                    else
                    {
                        continue;
                    }
                }
            }
            let bIsInLOS;
            if (bLOS && dist > 100)
            {
                bIsInLOS = this.checkLineOfSight(_pawn.position, curPawn.position, true, _pawn);
                if (!bIsInLOS)
                {
                    if (bIgnoreOutOfSight)
                    {
                        continue;
                    }
                    else
                    {
                        bLOS = false; //Enemy is out of sight, but add to enemies array if no other enemies
                    }
                }
            }
            let enemy = {
                type: curPawn.data.type,
                pawn: curPawn,
                fallback: fallback,
                dist: dist,
                bLOS: bLOS
            };
            enemies.push(enemy);
            if (bLOS && bIsInLOS === true)
            {
                break; //Enemy spotted, stop looping
            }
        }
        if (enemies.length > 0)
        {
            if (priority)
            {
                enemies.sort(function (a, b)
                {        
                    if (a.fallback < b.fallback) return -1;
                    if (a.fallback > b.fallback) return 1;
                    if (a.bLOS < b.bLOS) return 1;
                    if (a.bLOS > b.bLOS) return -1;  
                    if (a.type == priority && b.type != priority) return -1;
                    if (b.type == priority && a.type != priority) return 1;
                    if (a.dist < b.dist) return -1;
                    if (a.dist > b.dist) return 1;                                      
                    return 0;
                });
            }
            else if (bPreferDistance)
            {
                enemies.sort(function (a, b)
                {
                    if (a.fallback < b.fallback) return -1;
                    if (a.fallback > b.fallback) return 1;
                    if (a.dist < b.dist) return -1;
                    if (a.dist > b.dist) return 1;
                    if (a.bLOS < b.bLOS) return 1;
                    if (a.bLOS > b.bLOS) return -1;
                    return 0;
                });
            }
            else
            {
                enemies.sort(function (a, b)
                {
                    if (a.bLOS < b.bLOS) return 1;
                    if (a.bLOS > b.bLOS) return -1;
                    if (a.dist < b.dist) return -1;
                    if (a.dist > b.dist) return 1;
                    return 0;
                });
            }
            return enemies[0].pawn;
        }
        return null;
    }

    setDataValue(_body, _key, _value)
    {
        var data = _body ? _body.data : null;
        if (data)
        {
            if (typeof _value === "number")
            {
                _value = Math.min(99999999, _value);
            }
            if (this.game.bScenario)
            {
                switch (_key)
                {
                    case "id":
                    case "reward":
                        this.log("Access denied: " + _key + "=" + _value);
                        break;
                }
            }
            var prev = data[_key];
            data[_key] = _value;
            if (prev !== data[_key])
            {
                this.pushObjectDataUpdate(data.id, [_key]);
            }
        }
    }

    pushObjectUpdate(_id, _keys)
    {
        var obj = this.getObjectById(_id);
        if (obj)
        {
            var newData = {
                id: _id
            };
            for (var i = 0; i < _keys.length; i++)
            {
                var key = _keys[i];
                newData[key] = obj[key];
            }
            this.onEvent({
                eventId: GameServer.EVENT_OBJECT_UPDATE,
                object: newData
            });
        }
    }

    pushObjectDataUpdate(_id, _keys)
    {
        var obj = this.getObjectById(_id);
        if (obj)
        {
            var newData = {
                id: _id
            };
            for (var i = 0; i < _keys.length; i++)
            {
                var key = _keys[i];
                newData[key] = obj.data[key];
            }
            this.onEvent({
                eventId: GameServer.EVENT_OBJECT_UPDATE,
                object: newData
            });
        }
    }

    checkLineOfSight(_startPos, _endPos, _bObstaclesBlock, _targetBody, _bAllObstacles = false)
    {
        var result = this.raycast(_startPos[0], _startPos[1], _endPos[0], _endPos[1], _targetBody);
        if (result)
        {
            if (result.length == 0)
            {
                return true;
            }
            else
            {
                for (var i = 0; i < result.length; i++)
                {
                    let cur = result[i].body;
                    if (cur === _targetBody)
                    {
                        return true;
                    }
                    if (cur.data)
                    {
                        switch (cur.data.type)
                        {
                            case ObjectType.GROUND:
                                return false;
                            case ObjectType.OBSTACLE:
                                if (_bObstaclesBlock)
                                {
                                    if (cur.data.bBlockLOS || _bAllObstacles)
                                    {
                                        let dist = this.Dist(_startPos[0], _startPos[1], cur.position[0], cur.position[1]);
                                        if (dist > 50)
                                        {
                                            return false;
                                        }
                                    }
                                }
                                break;
                            case ObjectType.DOOR:
                                if (_bObstaclesBlock) return false;
                                if (cur.data.bClosed) return false;
                                break;
                            case ObjectType.CAR:
                            case ObjectType.TANK:
                            case ObjectType.HELICOPTER:
                                if (!this.vehicleHasOccupant(cur) && _bObstaclesBlock)
                                {
                                    let dist = this.Dist(_startPos[0], _startPos[1], cur.position[0], cur.position[1]);
                                    if (dist > 50)
                                    {
                                        return false;
                                    }
                                }
                                break;
                        }
                    }
                }
            }
        }
        return true;
    }

    returnFlagCTF(_body, _playerId)
    {
        if (_body)
        {
            var data = _body.data;
            if (data.flagType != GameMode.CAPTURE_THE_FLAG)
            {
                console.warn(data.flagType);
                return;
            }
            this.setFlagCarrierId(_body, null);
            var map = this.getCurrentMapData();
            var pos = map.flags[this.game.gameModeId][data.team];
            if (pos)
            {
                this.setObjectPosition(_body, pos);
            }
            else
            {
                console.warn("Invalid flag position");
            }
            data.cooldownTimer = 5;
            this.setDataValue(_body, "bAwayFromHome", false);
            if (_playerId)
            {
                this.onFlagReturned(_body, _playerId);
            }
        }
    }

    handleFlag(_body)
    {
        if (this.isOutOfMap(_body))
        {
            this.returnFlagCTF(_body);
        }
        var map = this.getCurrentMapData();
        var data = _body.data;
        if (data.cooldownTimer > 0)
        {
            data.cooldownTimer--;
        }
        else
        {
            delete data.cooldownTimer;
        }
        if (data.carrierId)
        {
            var carrier = this.getObjectById(data["carrierId"]);
            if (carrier)
            {
                if (carrier.data.health)
                {
                    _body.position[0] = carrier.position[0];
                    _body.position[1] = carrier.position[1];
                }
                if (carrier.data.controllableId)
                {
                    this.onFlagDropped(_body, data["carrierId"]);
                    this.setFlagCarrierId(_body, null);
                }
            }
            else
            {
                this.onFlagDropped(_body, data["carrierId"]);
                this.setFlagCarrierId(_body, null);
            }
        }
        if (!data.bAwayFromHome)
        {
            var pos = map.flags[this.game.gameModeId][data.team];
            this.setObjectPosition(_body, pos);
        }
        if (!data.cooldownTimer)
        {
            var pawns = this.getCharactersAndDinosaurs();
            for (var i = 0; i < pawns.length; i++)
            {
                let pawn = pawns[i];
                if (!pawn.data.controllableId)
                {
                    var bOverlap = _body.getAABB().overlaps(pawn.getAABB());
                }
                if (bOverlap)
                {
                    if (pawn.data.team == data.team)
                    {
                        if (!data.carrierId && data.bAwayFromHome)
                        {
                            data.cooldownTimer = 5;
                            this.returnFlagCTF(_body, pawn.data.id);
                        }
                        else if (!data.bAwayFromHome)
                        {
                            let otherFlag = this.getFlagCTF(data.team == 1 ? 0 : 1);
                            if (otherFlag.data.carrierId == pawn.data.id)
                            {
                                this.setFlagCarrierId(otherFlag, null);
                                otherFlag.data.cooldownTimer = 5;
                                let pos = map.flags[this.game.gameModeId][otherFlag.data.team];
                                this.setObjectPosition(otherFlag, pos);
                                this.setDataValue(otherFlag, "bAwayFromHome", false);
                                otherFlag.wakeUp();
                                data.cooldownTimer = 5;
                                this.onFlagCaptured(_body, [pawn.data.id]);
                                return;
                            }
                        }
                    }
                    else
                    {
                        if (!data.carrierId)
                        {
                            this.setFlagCarrierId(_body, pawn.data.id);
                            data.bAwayFromHome = true;
                            this.pushObjectDataUpdate(data.id, ["bAwayFromHome"]);
                            data.cooldownTimer = 5;

                            if (pawn.data.bBot)
                            {
                                this.setPawnRequest(pawn, Commands.REQUEST_COVER);
                            }
                            this.onFlagPickedUp(_body, pawn.data.id);
                        }
                    }
                }
            }
        }
    }

    setFlagCarrierId(_body, _carrierId)
    {
        if (_body)
        {
            this.setDataValue(_body, "carrierId", _carrierId);
            this.pushObjectDataUpdate(_body.data.id, ["carrierId"]);
        }
        else
        {
            console.warn("Invalid flag body", _carrierId);
        }
    }

    onFlagReturned(_flag, _playerId)
    {
        var ps = this.getPlayerById(_playerId);
        if (ps)
        {
            ps["returns"]++;
            this.onEvent({
                eventId: GameServer.EVENT_PLAYER_UPDATE,
                playerId: _playerId,
                data: {
                    returns: ps["returns"]
                }
            });
            this.onEvent({
                eventId: GameServer.EVENT_GAME_UPDATE,
                data: {
                    playerId: _playerId,
                    team: _flag.data.team,
                    bFlagReturned: true
                }
            });
        }
    }

    onFlagDropped(_flag, _playerId)
    {
        _flag.wakeUp();
        this.onEvent({
            eventId: GameServer.EVENT_GAME_UPDATE,
            data: {
                playerId: _playerId,
                team: _flag.data.team,
                bFlagDropped: true
            }
        });
    }

    onFlagPickedUp(_flag, _playerId)
    {
        this.onEvent({
            eventId: GameServer.EVENT_GAME_UPDATE,
            data: {
                playerId: _playerId,
                team: _flag.data.team,
                bFlagPickedUp: true
            }
        });
    }

    handleDominationFlag(_body)
    {
        var data = _body.data;
        var charsTouching;
        var pawns = this.getCharactersAndDinosaurs();
        //var area = this.getSharedData("flagCaptureSize");
        for (var i = 0; i < pawns.length; i++)
        {
            let pawn = pawns[i];
            let bOverlap = _body.getAABB().overlaps(pawn.getAABB());
            if (bOverlap)
            {
                if (!charsTouching)
                {
                    charsTouching = {};
                }
                if (!charsTouching[pawn.data.team])
                {
                    charsTouching[pawn.data.team] = [];
                }
                charsTouching[pawn.data.team].push(pawn.data.id);
            }
        }
        var prevCaptureTimer = this.clone(data.captureTimer);
        var prevTouching = [0, 0];
        if (data.charsTouching)
        {
            prevTouching[0] = data.charsTouching[0] != null ? data.charsTouching[0].length : 0;
            prevTouching[1] = data.charsTouching[1] != null ? data.charsTouching[1].length : 0;
        }
        var bWasBeingCaptured = data["bIsBeingCaptured"];
        var bWasContested = data["bIsContested"];
        var prevCapturingTeam = data["capturingTeam"];
        var prevTeam = data.team;
        data["charsTouching"] = charsTouching;
        data["bIsBeingCaptured"] = false;
        data["bIsContested"] = false;
        data["capturingTeam"] = null;
        if (charsTouching)
        {
            var keys = Object.keys(charsTouching);
            if (keys.length == 1)
            {
                var team = parseInt(keys[0]);
                if (team != data.team)
                {
                    data["bIsBeingCaptured"] = true;
                    data["capturingTeam"] = team;
                    if (data.captureTimer[team] > 0)
                    {
                        data.captureTimer[team] -= Math.min(charsTouching[team].length, 4);

                        for (var i = 0; i < charsTouching[team].length; i++)
                        {
                            var pawn = this.getObjectById(charsTouching[team][i]);
                            if (pawn)
                            {
                                pawn.data["bIsCapturingFlag"] = true;
                            }
                        }
                    }
                    else
                    {
                        data.captureTimer[team] = 0;
                        data.team = team;

                        this.onFlagCaptured(_body, charsTouching[team]);
                    }
                }
            }
            else if (keys.length > 1)
            {
                data["bIsContested"] = true;
            }
        }
        else
        {
            switch (this.game.gameModeId)
            {
                case GameMode.DOMINATION:
                case GameMode.CONQUEST:
                    this.setDataValue(_body, "captureTimerMax", this.game.settings.fps * 10);
                    break;
            }
            for (var i = 0; i < 2; i++)
            {
                if (data.captureTimer[i] < data["captureTimerMax"])
                {
                    data.captureTimer[i] = Math.min(data.captureTimer[i] + 2, data["captureTimerMax"]);
                }
            }
        }
        if (data.team != null)
        {
            if (data["pointTimer"] > 0)
            {
                data["pointTimer"]--;
            }
            else
            {
                this.onFlagPoint(data.team);
                data["pointTimer"] = data["pointTimerMax"];
            }
        }
        var params = [];
        if (data.charsTouching)
        {
            if (prevTouching[0] != (data.charsTouching[0] != null ? data.charsTouching[0].length : 0) || prevTouching[1] != (data.charsTouching[1] != null ? data.charsTouching[1].length : 0))
            {
                params.push("charsTouching");
            }
        }
        if (bWasBeingCaptured != data.bIsBeingCaptured)
        {
            params.push("bIsBeingCaptured");
        }
        if (bWasContested != data.bIsContested)
        {
            params.push("bIsContested");
        }
        if (prevCapturingTeam != data.capturingTeam)
        {
            params.push("capturingTeam");
        }
        if (prevTeam != data.team)
        {
            params.push("team");
        }
        if (prevCaptureTimer[0] != data.captureTimer[0] || prevCaptureTimer[1] != data.captureTimer[1])
        {
            params.push("captureTimer");
        }
        if (params.length > 0)
        {
            this.pushObjectDataUpdate(data.id, params);
        }
    }

    onFlagPoint(_team, _carrierId)
    {
        if (_team != null)
        {
            var scores = this.game.gameModeData.scores;
            scores[_team]++;
            this.onEvent({
                eventId: GameServer.EVENT_GAME_UPDATE,
                data: {
                    scores: scores,
                    pointTeam: _team
                }
            });
            if (scores[_team] >= this.game.gameModeData.scoreLimit)
            {
                this.requestEvent({
                    eventId: GameServer.EVENT_GAME_END,
                    condition: MatchState.END_CONDITION_SCORE,
                    winningTeam: _team,
                    cameraTargetId: _carrierId
                });
            }
        }
        if (_carrierId != null)
        {
            var ps = this.getPlayerStateById(_carrierId);
            if (ps)
            {
                if (ps.score >= 0)
                {
                    ps.score++;
                    this.onEvent({
                        eventId: GameServer.EVENT_PLAYER_UPDATE,
                        playerId: _carrierId,
                        data: {
                            score: ps.score
                        }
                    });
                }
            }
        }
    }

    onFlagCaptured(_flag, _playerIds)
    {
        var team = _flag.data.team;
        if (_playerIds)
        {
            for (var i = 0; i < _playerIds.length; i++)
            {
                var ps = this.getPlayerById(_playerIds[i]);
                if (ps)
                {
                    ps.captures++;
                    this.onEvent({
                        eventId: GameServer.EVENT_PLAYER_UPDATE,
                        playerId: _playerIds[i],
                        data: {
                            captures: ps.captures
                        }
                    });
                }
            }
            this.game.gameModeData.flags[_flag.data.num] = _flag.data.team;
            var eventData = {
                eventId: GameServer.EVENT_GAME_UPDATE,
                data: {
                    flags: this.game.gameModeData.flags,
                    flagCaptured: _flag.data.num,
                    playerIds: _playerIds
                }
            };
            this.onEvent(eventData);
        }
        switch (this.game.gameModeId)
        {
            case GameMode.CAPTURE_THE_FLAG:
                var scores = this.game.gameModeData.scores;
                scores[team]++;
                this.onEvent({
                    eventId: GameServer.EVENT_GAME_UPDATE,
                    data: {
                        scores: scores
                    }
                });
                if (scores[team] >= this.game.gameModeData.scoreLimit)
                {
                    this.requestEvent({
                        eventId: GameServer.EVENT_GAME_END,
                        condition: MatchState.END_CONDITION_SCORE,
                        winningTeam: team,
                        cameraTargetId: _playerIds ? _playerIds[0] : null
                    });
                }
                break;
        }
    }

    resetPlayerInputs()
    {
        for (var i = 0; i < this.game.players.length; i++)
        {
            let ps = this.game.players[i];
            if (ps)
            {
                ps.input = {};
            }
        }
    }

    startCinematic(_data)
    {
        console.log("startCinematic", _data);
        this.resetPlayerInputs();
        this.game.cinematic = {
            id: _data.id,            
            actions: _data.actions,
            index: 0
        };
        this.onEvent({
            eventId: GameServer.EVENT_GAME_UPDATE,
            data: {
                cinematic: this.game.cinematic
            }
        });
        this.dispatchTrigger({
            event: "cinematicStarted",
            cinematicId: this.game.cinematic.id
        });
    }

    handleCinematic()
    {
        var cinematic = this.game.cinematic;
        if (cinematic)
        {
            if (cinematic.timer > 0)
            {
                cinematic.timer--;
            }
            else
            {
                this.loadNextCinematicAction();
            }
        }
    }

    loadNextCinematicAction()
    {
        console.log("loadNextCinematicAction");
        var cinematic = this.game.cinematic;
        if (cinematic)
        {
            var action = cinematic.actions[cinematic.index];
            if (action)
            {
                console.log(action);
                switch (action.type)
                {
                    default:
                        if (action.lookPositions)
                        {
                            for (var i = 0; i < action.lookPositions.length; i++)
                            {
                                let cur = action.lookPositions[i];
                                if (cur.targetId && cur.objectId)
                                {
                                    let target = this.getObjectById(cur.targetId);
                                    if (target)
                                    {
                                        let object = this.getObjectById(cur.objectId);
                                        if (object)
                                        {
                                            target.data.lookPos = object.position;
                                            target.data.cinematicLookPos = object.position;
                                        }
                                    }
                                }
                            }
                        }
                        break;
                }
                if (action.functionId)
                {
                    this.executeScenarioFunction(action.functionId);
                }
                if (action.triggerId)
                {
                    this.executeTriggerById(action.triggerId);
                }
                cinematic.timer = (action.timer ? action.timer : 2) * this.game.settings.fps;
                if (action.text)
                {
                    cinematic.timer += Math.min(60, action.text.length);
                }
                cinematic.timerMax = cinematic.timer;
                this.onEvent({
                    eventId: GameServer.EVENT_GAME_UPDATE,
                    data: {
                        cinematicAction: action
                    }
                });
                cinematic.index++;
            }
            else
            {
                this.endCinematic();
            }
        }
        else
        {
            console.warn("Invalid cinematic");
        }
    }

    endCinematic()
    {
        console.log("endCinematic");
        this.dispatchTrigger({
            event: "cinematicEnded",
            cinematicId: this.game.cinematic.id
        });
        delete this.game.cinematic;
        this.onEvent({
            eventId: GameServer.EVENT_GAME_UPDATE,
            data: {
                bCinematicMode: false
            }
        });
    }

    isNearHealthBox(_body)
    {
        var boxes = this.getEquipment("health_box");
        for (var i = 0; i < boxes.length; i++)
        {
            let box = boxes[i];
            if (!box.data.bJammed && box.data.team == _body.data.team)
            {
                return this.Dist(box.position[0], box.position[1], _body.position[0], _body.position[1]) < box.data.weaponData.radius; // && this.checkLineOfSight(_body.position, box.position, false, box);
            }
        }
        return false;
    }

    handleEquipment(_body)
    {
        if (this.isOutOfMap(_body))
        {
            this.removeNextStep(_body);
            return;
        }
        var data = _body.data;
        var weaponData = data.weaponData;
        if (weaponData.id != "jammer")
        {
            this.setDataValue(_body, "bJammed", this.hasNearbyJammer(_body));
        }
        if (data.bDisabled)
        {
            return;
        }
        switch (weaponData.id)
        {
            case "sensor":
                break;
            case "health_box":
                if (data.bJammed)
                {
                    break;
                }
                break;
            case "trophy":
                if (data.bJammed)
                {
                    break;
                }
                if (data.blockNum > 0)
                {
                    var projectiles = this.getTypes([ObjectType.ROCKET, ObjectType.GRENADE]);
                    for (var i = 0; i < projectiles.length; i ++)
                    {
                        let target = projectiles[i];
                        if (!target.data || target.data.bPendingRemoval)
                        {
                            continue;
                        }
                        if (target.data.team != data.team)
                        {
                            let dist = this.Dist(_body.position[0], _body.position[1], target.position[0], target.position[1]);
                            if (dist <= weaponData.radius)
                            {
                                data.blockNum--;
                                this.requestEvent({
                                    eventId: GameServer.EVENT_PAWN_ACTION,
                                    pawnId: data.id,
                                    type: GameServer.PAWN_TROPHY_HIT,
                                    pos: target.position
                                });
                                this.removeNextStep(target);
                                this.createExplosion({
                                    eventId: GameServer.EVENT_SPAWN_EXPLOSION,
                                    x: target.position[0],
                                    y: target.position[1],
                                    radius: 200,
                                    damage: 0,
                                    playerId: null,
                                    causerId: null,
                                    weaponId: null
                                });
                                break;
                            }
                        }
                    }
                }
                else
                {
                    this.removeNextStep(_body);
                }
                break;

            default:
                if (weaponData.bMine)
                {
                    if (data.bTriggered)
                    {
                        if (data.triggerTimer > 0)
                        {
                            data.triggerTimer--;
                        }
                        else
                        {
                            this.detonate(_body);
                        }
                    }
                    else if (!data.bJammed)
                    {
                        var triggerTargets = this.getTypes([
                            ObjectType.CHARACTER,
                            ObjectType.DINOSAUR,
                            ObjectType.HELICOPTER,
                            ObjectType.TANK,
                            ObjectType.CAR,
                            ObjectType.EGG
                        ]);
                        for (var i = 0; i < triggerTargets.length; i ++)
                        {
                            let pawn = triggerTargets[i];
                            if (!pawn.data || pawn.data.bPendingRemoval)
                            {
                                continue;
                            }
                            if (pawn.data.team != data.team)
                            {
                                if (this.isVehicle(pawn) && !this.vehicleHasOccupant(pawn))
                                {
                                    continue;
                                }
                                if (data.bUseScale)
                                {
                                    if (data.scale == 1 && pawn.position[0] < _body.position[0])
                                    {
                                        continue;
                                    }
                                    else if (data.scale == -1 && pawn.position[0] > _body.position[0])
                                    {
                                        continue;
                                    }
                                }
                                var bOverlap = (this.Dist(pawn.position[0], pawn.position[1], _body.position[0], _body.position[1]) < data.triggerRange) && this.checkLineOfSight(_body.position, pawn.position, false, pawn);
                                if (bOverlap)
                                {
                                    if (!data.triggerType || data.triggerType == pawn.data.type)
                                    {
                                        this.triggerMine(_body, Math.ceil(this.game.settings.fps * 0.5));
                                    }
                                    break;
                                }
                            }
                        }
                    }
                }
                break;
        }
    }

    triggerMine(_body, _timer)
    {
        var data = _body.data;
        if (data.bJammed)
        {
            return;
        }
        data.bTriggered = true;
        data.triggerTimer = _timer;
        this.requestEvent({
            eventId: GameServer.EVENT_PAWN_ACTION,
            pawnId: data.id,
            type: GameServer.PAWN_TRIGGER_MINE
        });
    }

    handleGrenade(_body)
    {
        var data = _body.data;
        if (data.stuckToId)
        {
            var stuckTo = this.getObjectById(data.stuckToId);
            if (!stuckTo)
            {
                if (_body.constraint)
                {
                    this.game.world.removeConstraint(_body.constraint);
                    delete _body.constraint;
                }
            }
        }
        if (data.bDetonationTimerEnabled)
        {
            if (data.detonationTimer > 0)
            {
                data.detonationTimer--;
            }
            else if (data.detonationTimer == 0)
            {
                this.detonate(_body);
            }
        }
        if (data.bImpact)
        {
            data.lifespan++;
        }
        if (data.minTimer > 0)
        {
            data.minTimer--;
            if (data.minTimer <= 0)
            {
                delete data.minTimer;
            }
        }
    }

    handleRocket(_body)
    {
        var data = _body.data;        
        if (data.bAutoLock && !data.enemyId)
        {
            switch (data.vehicleId)
            {
                case MountedWeapon.SENTRY_SAM:
                    var pawnTypes = [ObjectType.HELICOPTER, ObjectType.FLYING_DINOSAUR];
                    break;
            }
            var enemy = this.getNearestEnemyPawn(_body, {
                bIgnoreOutOfSight: false,
                maxRange: 1000,
                pawnTypes: pawnTypes,
                bLOS: true,
                bLockOn: true
            });
            if (enemy)
            {                
                this.setDataValue(_body, "enemyId", enemy.data.id);
            }
        }
        else if (data.enemyId && !data.path)
        {
            var flare = this.getNearbyFlare(_body);
            if (flare)
            {
                this.setDataValue(_body, "enemyId", flare.data.id);
            }
            var enemy = this.getObjectById(data.enemyId);
            if (enemy)
            {
                if (enemy.data.bECM)
                {
                    this.setDataValue(_body, "enemyId", null);
                }
                else if (enemy.data.health || enemy.data.type == ObjectType.ROCKET)
                {
                    var dist = this.DistBodies(enemy, _body);
                    if (dist < 75)
                    {
                        this.detonate(_body);
                        return;
                    }
                    else
                    {
                        var distX = enemy.position[0] - _body.position[0];
                        var distY = enemy.position[1] - _body.position[1];
                        var rad = Math.atan2(distY, distX);
                        var speed = 300 / this.game.fpsMult;
                        var target = this.WrapAngle(_body.angle - rad, true);
                        _body.angle -= target * 0.1;
                        _body.applyForce([Math.cos(_body.angle) * speed, Math.sin(_body.angle) * speed], 0, 0);
                        this.constrainVelocity(_body, 500);
                    }
                }                
            }
            else if (data.bAutoLock)
            {
                this.setDataValue(_body, "enemyId", null);
            }
        }
        else if (data.bControllable)
        {
            var speed = 300;
            _body.applyForce([Math.cos(_body.angle) * speed, Math.sin(_body.angle) * speed], 0, 0);
            this.constrainVelocity(_body, 750);
        }
        if (data.destroyTimer == 0)
        {
            this.detonate(_body);
        }
    }

    handleVehicle(_body)
    {
        var data = _body.data;
        if (this.isOutOfMap(_body) && !this.vehicleHasOccupant(_body))
        {
            this.removeNextStep(_body);
            return;
        }
        if (data.bAutomated && this.matchInProgress())
        {
            if (!_body.ai)
            {
                _body.ai = {
                    ticker: 0,
                    tickerMax: 5
                }
            }
            var ai = _body.ai;
            if (ai.ticker > 0)
            {
                ai.ticker--;
            }
            else
            {
                ai.ticker = ai.tickerMax;
            }
            var seatIndex = 0;
            var weapon = this.getCurrentVehicleWeapon(_body, seatIndex);
            if (data.health && !data.bStunned && !data.bFlashed && !data.bJammed)
            {
                if (data.weapons)
                {
                    for (var i = 0; i < data.weapons[0].length; i++)
                    {
                        weapon = data.weapons[0][i];
                        if (weapon && !weapon.bCooldown)
                        {
                            break;
                        }
                    }
                }
                this.setVehicleWeaponIndex(_body, 0, i);                
                if (weapon && weapon.weaponData && !data.bDisabled)
                {
                    var weaponData = weapon.weaponData;
                    var maxRange = Math.min(weaponData.range, 1000);
                    var enemySettings = {
                        bLOS: true
                    };
                    switch (data.type)
                    {
                        case ObjectType.HELICOPTER:
                            enemySettings.pawnTypes = data.enemyTypes ? data.enemyTypes : [ObjectType.CHARACTER, ObjectType.DINOSAUR, ObjectType.CAR, ObjectType.TANK, ObjectType.EGG];
                            enemySettings.bLOS = false;
                            break;
                        case ObjectType.MOUNTED_WEAPON:
                            enemySettings.maxRange = maxRange;
                            switch (data.vehicleId)
                            {
                                case MountedWeapon.BGM71:
                                    maxRange = data.maxRange ? data.maxRange : 2000;
                                    enemySettings.pawnTypes = null;
                                    enemySettings.bLOS = false;
                                    break;
                                case MountedWeapon.SENTRY_SAM:
                                    maxRange = data.maxRange ? data.maxRange : 2000;
                                    enemySettings.pawnTypes = [ObjectType.HELICOPTER, ObjectType.FLYING_DINOSAUR];
                                    enemySettings.bLOS = false;
                                    break;
                                case MountedWeapon.SENTRY_SNIPER:
                                    maxRange = data.maxRange ? data.maxRange : 4000;
                                    enemySettings.bIgnoreOutOfSight = true;
                                    enemySettings.priority = ObjectType.HELICOPTER;
                                    enemySettings.pawnTypes = [ObjectType.CHARACTER, ObjectType.DINOSAUR, ObjectType.FLYING_DINOSAUR, ObjectType.HELICOPTER, ObjectType.CAR, ObjectType.TANK];
                                    break;
                                case MountedWeapon.SENTRY_RAILGUN:
                                    maxRange = data.maxRange ? data.maxRange : 3500;
                                    enemySettings.bIgnoreOutOfSight = true;
                                    enemySettings.priority = ObjectType.HELICOPTER;
                                    enemySettings.pawnTypes = [ObjectType.CHARACTER, ObjectType.DINOSAUR, ObjectType.FLYING_DINOSAUR, ObjectType.HELICOPTER, ObjectType.CAR, ObjectType.TANK];
                                    break;
                                default:
                                    enemySettings.bIgnoreOutOfSight = true;
                                    enemySettings.pawnTypes = [ObjectType.CHARACTER, ObjectType.DINOSAUR, ObjectType.CAR, ObjectType.TANK];
                                    break;
                            }
                            break;
                    }                    
                    if (ai.ticker == 0)
                    {
                        ai.enemy = this.getNearestEnemyPawn(_body, enemySettings);
                    }
                    var enemy = ai.enemy;
                    if (enemy && enemy.data)
                    {
                        data.enemyId = enemy.data.id;
                        this.setVehicleWeaponAimRotation(_body, seatIndex, weapon, this.Angle(_body.position[0], _body.position[1], enemy.position[0], enemy.position[1]));
                        var enemyDist = this.DistBodies(_body, enemy);
                        if (enemyDist < maxRange)
                        {
                            weapon.bWantsToFire = data.type == ObjectType.HELICOPTER || weaponData.bAutoLock || this.checkLineOfSight(_body.position, enemy.position, false, enemy);
                        }
                        else
                        {
                            weapon.bWantsToFire = false;
                        }
                    }
                    else
                    {
                        delete ai.enemy;
                        delete data.enemyId;
                        weapon.bWantsToFire = false;
                        if (data.type == ObjectType.MOUNTED_WEAPON)
                        {
                            this.updateVehicleWeaponAimRotation(_body, 0, 0, weapon.aimRotation + this.ToRad(1 / this.game.fpsMult));
                        }
                    }
                    if (data.bStunned || data.bFlashed || data.bJammed || data.bDisabled)
                    {
                        weapon.bWantsToFire = false;
                    }
                    this.setDataValue(_body, "bWantsToFire", weapon.bWantsToFire);
                }
                switch (data.type)
                {
                    case ObjectType.CAR:
                    case ObjectType.TANK:
                    case ObjectType.HELICOPTER:
                        var threshold = 100;
                        if (data.bLeaveWhenNoOccupants && !this.hasPawnOccupants(_body))
                        {                            
                            if (!data.destination)
                            {
                                data.destination = [this.RandomBoolean() ? 0 : this.getMapWidth(), this.RandomBoolean() ? 0 : this.getMapHeight()];
                                data.bRemove = true;
                            }
                        }
                        if (data.destination)
                        {
                            var heliPos = data.destination;
                        }
                        else if (enemy && !data.bDisabled)
                        {
                            heliPos = enemy.position;
                        }
                        else
                        {
                            var player = this.getObjectById(data.playerId);
                            if (player)
                            {
                                heliPos = player.position;
                                threshold = 600;
                            }
                        }
                        if (heliPos)
                        {
                            var enemyThreshold = data.enemyThreshold ? data.enemyThreshold : 300;
                            var rad = this.Angle(_body.position[0], _body.position[1], heliPos[0], heliPos[1]);
                            var targetDist = this.Dist(_body.position[0], _body.position[1], heliPos[0], heliPos[1]);
                            var speed = (data.speed * (data.speedMultiplier ? data.speedMultiplier : 1)) * (enemyDist == null || enemyDist > enemyThreshold ? 1 : -1);
                            if (targetDist < (threshold * 2))
                            {
                                _body.velocity[0] *= 0.98;
                                _body.velocity[1] *= 0.98;
                            }
                            if (targetDist > threshold)
                            {
                                _body.applyForce([Math.cos(rad) * speed, Math.sin(rad) * speed]);
                            }
                            else if (data.destination)
                            {
                                data.bDestinationReached = true;
                            }
                        }
                        if (data.bDestinationReached)
                        {
                            if (data.destinationTimer > 0)
                            {
                                data.destinationTimer--;
                            }
                            else
                            {
                                if (data.items && data.items.length > 0)
                                {
                                    if (data.itemTimer > 0)
                                    {
                                        data.itemTimer--;
                                    }
                                    else
                                    {
                                        let item = data.items[0];
                                        let pos = data.destination;
                                        if (item.offset)
                                        {
                                            pos[0] += this.Random(-item.offset, item.offset);
                                            pos[1] += this.Random(-item.offset, item.offset);
                                        }
                                        this.spawnItem(item, pos, data.team);
                                        data.items.splice(0, 1);
                                        data.itemTimer = data.itemTimerMax ? data.itemTimerMax : (5 * this.game.settings.fps);
                                    }
                                }
                                else
                                {
                                    if (data.bRemove)
                                    {
                                        this.removeNextStep(_body);
                                    }
                                    else
                                    {
                                        if (data.defendTimer > 0)
                                        {
                                            data.defendTimer--;
                                        }
                                        else
                                        {
                                            //Helicopter departing map
                                            _body.wakeUp();
                                            data.bRemove = true;
                                            data.bDestinationReached = false;
                                            data.destination = [this.RandomBoolean() ? 0 : this.getMapWidth(), this.RandomBoolean() ? 0 : this.getMapHeight()];
                                            if (data.departSpeedMult != null)
                                            {
                                                data.speedMultiplier = (data.speedMultiplier ? data.speedMultiplier : 1) * data.departSpeedMult;
                                            }
                                            if (this.isOutOfHelicopterArea(_body))
                                            {
                                                this.removeNextStep(_body);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        break;
                }
            }
            else
            {
                if (weapon)
                {
                    weapon.bWantsToFire = false;
                }
                this.setDataValue(_body, "bWantsToFire", false);
            }
        }
        if (data.attachId)
        {
            if (!this.getObjectById(data.attachId))
            {
                this.setDataValue(_body, "attachId", null);
            }
        }
        if (data.attachToId)
        {
            if (!this.getObjectById(data.attachToId))
            {
                this.setDataValue(_body, "attachToId", null);
            }
        }
        if (data.scaleCooldown > 0)
        {
            data.scaleCooldown--;
        }
        if (data.bECM)
        {
            if (data.ecmTimer > 0)
            {
                data.ecmTimer--;
                if (data.ecmTimer <= 0)
                {
                    delete data.ecmTimer;
                    this.setDataValue(_body, "bECM", false);
                }
            }
        }
        if (data.bCountermeasureCooldown)
        {
            if (data.countermeasureCooldownTimer > 0)
            {
                data.countermeasureCooldownTimer--;
                if (data.countermeasureCooldownTimer <= 0)
                {
                    delete data.countermeasureCooldownTimer;
                    this.setDataValue(_body, "bCountermeasureCooldown", false);
                }
            }
        }
        if (data.flares > 0)
        {
            var rocket = this.getIncomingGuidedRocket(_body);
            if (rocket)
            {
                this.ejectFlare(_body, rocket);
                data.flares--;
            }            
        }
        var seats = data.seats;
        if (seats)
        {
            for (var i = 0; i < seats.length; i++)
            {
                var seat = seats[i];
                if (seat.pawnId)
                {
                    var pawn = this.getObjectById(seat.pawnId);
                    if (pawn)
                    {
                        pawn.position = [_body.position[0] + (seat.position[0]), _body.position[1] + seat.position[1]];
                        pawn.angle = _body.angle;
                    }
                    else
                    {
                        delete seat.pawnId;
                    }
                }
            }
        }
        var weapons = data.weapons;
        if (weapons)
        {
            for (var i = 0; i < weapons.length; i++)
            {
                let weaponList = weapons[i];
                for (var j = 0; j < weaponList.length; j++)
                {
                    let weapon = weaponList[j];
                    if (weapon)
                    {
                        if (!seats[i].pawnId && !data.bAutomated)
                        {
                            weapon.bWantsToFire = false;
                            if (i > 0)
                            {
                                switch (data.vehicleId)
                                {
                                    case Tank.ABRAMS:
                                    case Tank.T90:
                                    case Car.LAV25:
                                        //weapon.aimRotation = weapons[0][0].aimRotation;
                                        this.updateVehicleWeaponAimRotation(_body, i, j, weapons[0][0].aimRotation);
                                        break;
                                    default:
                                        //weapon.aimRotation = _body.angle;
                                        this.updateVehicleWeaponAimRotation(_body, i, j, _body.angle);
                                        break;
                                }                                
                            }
                        }

                        if (weapon.bFireDelay)
                        {
                            weapon.fireDelayTimer--;
                            if (weapon.fireDelayTimer == 0)
                            {
                                weapon.bFireDelay = false;
                            }
                        }
                        if (weapon.overheat > 0)
                        {
                            var cooldownNum = weapon.weaponData.cooldownNum ? weapon.weaponData.cooldownNum : 0.5;
                            weapon.overheat -= (weapon.bCooldown ? cooldownNum : weapon.weaponData.overheatCooldownNum != null ? weapon.weaponData.overheatCooldownNum : 1) / this.game.fpsMult;
                            if (weapon.bCooldown)
                            {
                                if (weapon.overheat > 0)
                                {
                                    this.onEvent({
                                        eventId: GameServer.EVENT_PAWN_ACTION,
                                        pawnId: data.id,
                                        type: GameServer.PAWN_VEHICLE_UPDATE,
                                        seatIndex: i,
                                        weaponIndex: j,
                                        bCooldown: weapon.bCooldown,
                                        overheat: weapon.overheat
                                    });
                                }
                                else 
                                {
                                    if (weapon.ammo != null)
                                    {
                                        weapon.ammo = weapon.weaponData.ammoMax;
                                    }
                                    weapon.bCooldown = false;
                                    this.onEvent({
                                        eventId: GameServer.EVENT_PAWN_ACTION,
                                        pawnId: data.id,
                                        type: GameServer.PAWN_WEAPON_COOLDOWN,
                                        index: i,
                                        weaponIndex: j,
                                        value: weapon.bCooldown,
                                        ammo: weapon.ammo
                                    });
                                }
                            }
                        }
                        var bHasAmmo = weapon.ammo != null ? weapon.ammo > 0 : true;
                        var bCanFire = weapon.weaponData != null && this.matchInProgress();
                        if (bCanFire && weapon.weaponData.bRequireLock)
                        {
                            var pawn = this.getObjectById(seats[i].pawnId);
                            bCanFire = bCanFire && pawn && pawn.data.lockOnTargetId;
                        }
                        if (weapon.bWantsToFire && !weapon.bFireDelay && !weapon.bCooldown && bHasAmmo && bCanFire)
                        {
                            var pawnId = seats[i].pawnId;
                            if (!pawnId)
                            {
                                pawnId = data.playerId;
                            }
                            var muzzlePos = this.getVehicleMuzzlePosition(_body, i);
                            var weaponData = weapon.weaponData;
                            var bShotgun = weaponData.type == Weapon.TYPE_SHOTGUN || weaponData.bShotgun;
                            var numBullets = 1;
                            var bShotgun = weaponData.type == Weapon.TYPE_SHOTGUN || weaponData.bShotgun;
                            if (weaponData.id == Dinosaur.NEEDLER)
                            {
                                numBullets = 2;
                            }
                            else if (bShotgun && !weaponData.bSlug)
                            {
                                numBullets = 8;
                            }
                            for (var b = 0; b < numBullets; b++)
                            {
                                var bulletRad = weapon.aimRotation + this.ToRad(this.Random(-weaponData.accuracy, weaponData.accuracy));
                                if (weaponData.bAutoLock)
                                {
                                    var pawn = this.getObjectById(pawnId);
                                    if (pawn && pawn.data.lockOnTargetId)
                                    {
                                        bulletRad += this.ToRad(this.Random(-15, 15));
                                    }
                                }
                                if (weaponData.bRocket)
                                {
                                    var pawn = this.getObjectById(pawnId);
                                    this.createRocket(muzzlePos, {
                                        rocketType: weaponData.rocketType ? weaponData.rocketType : Rocket.DEFAULT,
                                        team: data.team,
                                        playerId: pawnId,
                                        causerId: data.id,
                                        angle: bulletRad,
                                        weaponId: weaponData.id,
                                        damage: weaponData.damage,
                                        radius: weaponData.radius,
                                        bRequireLock: weaponData.bRequireLock,
                                        bAutoLock: weaponData.bAutoLock,
                                        bCanLock: weaponData.bCanLock,
                                        lockOnTargetId: data.enemyId ? data.enemyId : pawn.data.lockOnTargetId,
                                        vehicleId: data.vehicleId
                                    });
                                }
                                else if (weaponData.bGrenade)
                                {
                                    this.createGrenade(muzzlePos, {
                                        team: data.team,
                                        playerId: pawnId,
                                        causerId: data.id,
                                        rotation: bulletRad,
                                        velocity: 1500, //weaponData.velocity ? weaponData.velocity : 1500,
                                        damage: weaponData.damage,
                                        weaponId: weaponData.id,
                                        weaponData: weaponData,
                                        modId: weaponData.mods ? weaponData.mods[Mods.TYPE_AMMO] : null,
                                        bImpact: true,
                                        bMinimumDistance: true
                                    });
                                }
                                else if (weaponData.bProjectile)
                                {
                                    if (data.attachId)
                                    {
                                        this.detachRope(_body);
                                    }
                                    else
                                    {
                                        this.createProjectile(muzzlePos, bulletRad, data.team, {
                                            playerId: pawnId,
                                            causerId: data.id,
                                            rotation: bulletRad,
                                            weaponId: weaponData.id,
                                            frameId: weaponData.frameId,
                                            sourceId: data.id
                                        });
                                    }
                                }
                                else if (weaponData.bFlame)
                                {
                                    var flameVel = weaponData.velocity ? weaponData.velocity : 1300;
                                    var flameSpeed = this.Random(flameVel, flameVel + 200);
                                    var flame = this.createFlame(muzzlePos, [Math.cos(bulletRad) * flameSpeed, Math.sin(bulletRad) * flameSpeed], data.team, pawnId, weaponData, weaponData.fireTime, true);
                                    flame.data.bAutomated = data.bAutomated;
                                }
                                else
                                {
                                    this.createBullet({
                                        x: muzzlePos[0],
                                        y: muzzlePos[1],
                                        rotation: bulletRad,
                                        range: weaponData.range,
                                        damage: weaponData.damage,
                                        instigatorId: pawnId,
                                        causerId: data.id,
                                        weaponId: weaponData.id,
                                        weaponData: weaponData,
                                        bDirectlyCausedByPlayer: !data.bAutomated,
                                        bMelee: weaponData.bDinosaur,
                                        bIgnoreObstacles: data.type == ObjectType.HELICOPTER
                                    });
                                }
                            }
                            weapon.bFireDelay = true;
                            weapon.fireDelayTimer = Math.max(1, Math.ceil(weaponData.fireRate * this.game.fpsMult));
                            if (weapon.ammo != null)
                            {
                                weapon.ammo--;
                                if (data.type == ObjectType.MOUNTED_WEAPON && !data.bUnlimitedAmmo && weapon.ammo <= 0 && data.bAutomated)
                                {
                                    this.removeNextStep(_body);
                                }
                            }
                            if (weapon.weaponData && weapon.weaponData.overheatMax)
                            {
                                weapon.overheat += (weapon.weaponData.overheatNum ? weapon.weaponData.overheatNum : Math.round(weaponData.fireRate * 1.75));
                                if (weapon.overheat >= weapon.weaponData.overheatMax)
                                {
                                    weapon.overheat = weapon.weaponData.overheatMax;
                                    weapon.bCooldown = true;
                                    this.onEvent({
                                        eventId: GameServer.EVENT_PAWN_ACTION,
                                        pawnId: data.id,
                                        type: GameServer.PAWN_WEAPON_COOLDOWN,
                                        index: j,
                                        value: weapon.bCooldown
                                    });
                                }
                            }
                            if (data.ammo != null && !data.bUnlimitedAmmo)
                            {
                                this.setDataValue(_body, "ammo", data.ammo - 1);
                                if (data.ammo <= 0)
                                {
                                    this.exitAllPawnsFromVehicle(_body);
                                    this.killPawn(data.id); //Remove empty turret
                                }
                            }
                            var obj = {
                                eventId: GameServer.EVENT_PAWN_ACTION,
                                pawnId: data.id,
                                type: GameServer.PAWN_FIRE_WEAPON,
                                index: i,
                                angle: weapon.aimRotation,
                                ammo: weapon.ammo,
                                overheat: weapon.overheat
                            };
                            this.requestEvent(obj);
                            if (!data.bUntargetable)
                            {
                                this.emitAISound(_body.position, _body.position, 1000, data.team);
                            }
                        }
                    }
                }
            }
        }
        //_body.position[1] = Math.max(0, _body.position[1]);
    }

    handleTank(_body)
    {
        this.handleCar(_body);
    }

    handleCar(_body)
    {
        this.handleVehicle(_body);
        var data = _body.data;

        var carSpeed = (data.speed ? data.speed : 100);
        if (data.type == ObjectType.TANK)
        {
            this.constrainVelocity(_body, data.maxSpeed ? data.maxSpeed : 275);
            var turnSpeed = 6;
        }
        else
        {
            this.constrainVelocity(_body, (data.maxSpeed ? data.maxSpeed : 750) * (data.bReversing ? 0.5 : 1));
            if (_body.mass < Number.MAX_VALUE)
            {
                var vel = this.getTotalVelocity(_body) * 0.001 / carSpeed;
                turnSpeed = Math.min(carSpeed * Math.min(1, Math.abs(vel)), 100 / (_body.mass * 0.3));
                turnSpeed = Math.min(30, turnSpeed);
            }
            else
            {
                turnSpeed = 0;
            }
        }
        turnSpeed = turnSpeed / this.game.fpsMult;

        if (!this.vehicleHasOccupant(_body))
        {
            this.setDataValue(_body, "turnDirection", 0);
            this.setDataValue(_body, "bGas", false);
            this.setDataValue(_body, "bReversing", false);
        }
        else
        {
            var driverId = data.seats[0] ? data.seats[0].pawnId : null;
            var ps = this.getPlayerById(driverId);
            if (ps)
            {
                var input = ps.input;
            }
            else
            {
                var pawn = this.getObjectById(driverId);
                if (pawn)
                {
                    input = pawn.input;
                }
            }
            if (input)
            {
                if (input[Control.UP])
                {
                    _body.applyImpulse([Math.cos(_body.angle) * carSpeed, Math.sin(_body.angle) * carSpeed]);
                    this.setDataValue(_body, "bReversing", false);
                    this.setDataValue(_body, "bGas", true);
                }
                else if (input[Control.DOWN])
                {
                    _body.applyImpulse([Math.cos(_body.angle) * -carSpeed, Math.sin(_body.angle) * -carSpeed]);
                    this.setDataValue(_body, "bReversing", true);
                    this.setDataValue(_body, "bGas", true);
                }
                else
                {
                    this.setDataValue(_body, "bGas", false);
                    this.setDataValue(_body, "bReversing", false);
                }
                if (input[Control.RIGHT])
                {
                    _body.wakeUp();
                    var turn = this.ToRad(turnSpeed);
                    if (data.bReversing)
                    {
                        _body.angularVelocity -= turn;
                    }
                    else
                    {
                        _body.angularVelocity += turn;
                    }   
                    this.setDataValue(_body, "turnDirection", 1);
                }
                else if (input[Control.LEFT])
                {
                    _body.wakeUp();
                    turn = this.ToRad(turnSpeed);
                    if (data.bReversing)
                    {
                        _body.angularVelocity += turn;
                    }
                    else
                    {
                        _body.angularVelocity -= turn;
                    }
                    this.setDataValue(_body, "turnDirection", -1);
                }
                else
                {
                    this.setDataValue(_body, "turnDirection", 0);
                }
            }
        }
        if (data.turnDirection == 0)
        {
            _body.angularVelocity *= 0.25;
        }            
    }

    handleMountedWeapon(_body)
    {
        this.handleVehicle(_body);
        var data = _body.data;
        if (this.game.bSurvival && data.team == 1)
        {
            this.setDataValue(_body, "bJammed", this.hasNearbyJammer(_body));
        }
        if (data.playerId && this.bodyIsInWall(_body))
        {
            this.removeNextStep(_body);
        }
    }

    handleHelicopter(_body)
    {
        this.handleVehicle(_body);
        var data = _body.data;
        var speedMult = data.speedMultiplier != null ? data.speedMultiplier : 1;
        this.constrainVelocity(_body, (data.maxSpeed ? data.maxSpeed : 1000) * speedMult);
        if (data.swayMax > 0)
        {
            if (data.swayDir == 1)
            {
                data.sway++;
                if (data.sway > data.swayMax)
                {
                    data.swayDir = -1;
                }
            }
            else
            {
                data.sway--;
                if (data.sway < -data.swayMax)
                {
                    data.swayDir = 1;
                }
            }
        }
        if (this.vehicleHasOccupant(_body))
        {
            var sway = data.sway * 3;
            _body.applyForce([sway, sway]);
            var rad = Math.atan2(-_body.velocity[0], _body.velocity[1]) + this.ToRad(90);
            var weapon = this.getCurrentVehicleWeapon(_body, 0);
            if (!data.bAutomated && weapon.weaponData)
            {
                rad = weapon.aimRotation;
            }
            else if (weapon && weapon.weaponData && weapon.bWantsToFire)
            {
                rad = weapon.aimRotation;
            }
            else if (data.destination)
            {
                rad = this.Angle(_body.position[0], _body.position[1], data.destination[0], data.destination[1]);
            }
            var target = this.WrapAngle(rad - _body.angle, true);
            _body.angularVelocity += target * 0.05;
        }
    }

    handleReviver(_body)
    {
        this.constrainVelocity(_body, 500);
        var data = _body.data;
        if (!data.currentPawnId && data.bleedTimer != null)
        {
            if (data.bleedTimer > 0)
            {
                data.bleedTimer--;
                this.setDataValue(_body, "bleedTimer", data.bleedTimer - 1);
                if (data.bleedTimer <= 0)
                {
                    data.bleedTimer = null;
                    if (this.game.bOperation)
                    {
                        this.requestEvent({
                            eventId: GameServer.EVENT_GAME_END,
                            condition: MatchState.END_CONDITION_DEAD_ALLY,
                            cameraTargetId: data.id
                        });
                    }
                    else
                    {
                        this.removeNextStep(_body);
                    }
                }
            }
        }
    }

    isInSmoke(_body)
    {
        if (_body)
        {
            var grenades = this.getSmokeGrenades();
            for (var i = 0; i < grenades.length; i++)
            {
                var grenade = grenades[i];
                var dist = this.Dist(grenade.position[0], grenade.position[1], _body.position[0], _body.position[1]);
                if (dist <= this.getSharedData("smokeSize"))
                {
                    return true;
                }
            }
        }
        return false;
    }

    handleEgg(_body)
    {
        var body = _body;
        var data = body.data;
        if (this.matchInProgress() && !data.bDisabled)
        {
            if (data.hatchTimer > 0)
            {
                data.hatchTimer--;
                if (data.hatchTimer <= 0)
                {
                    var items = data.items;
                    for (var i = 0; i < items.length; i++)
                    {
                        this.spawnItem(items[i], _body.position, data.team);
                    }
                    data.items = [];
                    this.removeNextStep(_body);
                }
            }
        }
    }

    handleMoney(_body)
    {
        var body = _body;
        var data = body.data;
        if (this.matchInProgress())
        {
            var pawns = this.getCharacters();
            for (var i = 0; i < pawns.length; i++)
            {
                let pawn = pawns[i];
                if (!pawn.data || !pawn.data.health || pawn.data.bInvisible)
                {
                    continue;
                }
                if (this.game.bSurvival && pawn.data.team != 0)
                {
                    continue;
                }
                if (this.game.bSurvival && pawn.data.controllableId)
                {
                    continue;
                }
                let ps = this.getPlayerById(pawn.data.id);
                if (ps && ps.money < this.settings.maxPlayerMoney)
                {
                    let bOverlaps = body.getAABB().overlaps(pawn.getAABB());
                    if (bOverlaps)
                    {
                        this.addPlayerMoney(pawn.data.id, data.value);
                        this.removeNextStep(body);
                    }
                }
            }
        }
    }

    handleArrow(_body)
    {
        var body = _body;
        if (this.matchInProgress())
        {
            var pawns = this.getCharacters();
            for (var i = 0; i < pawns.length; i++)
            {
                let pawn = pawns[i];
                if (!pawn.data || !pawn.data.health || pawn.data.bInvisible || pawn.data.controllableId)
                {
                    continue;
                }
                let index = this.getCharacterInventoryItemIndex(pawn, "bow");
                if (index == -1)
                {
                    index = this.getCharacterInventoryItemIndex(pawn, "crossbow");
                }
                if (index == -1)
                {
                    index = this.getCharacterInventoryItemIndex(pawn, "quadra");
                }
                if (index >= 0)
                {
                    let bOverlaps = body.getAABB().overlaps(pawn.getAABB());
                    if (bOverlaps)
                    {
                        this.addInventoryItemAmmo(pawn, index, 1);
                        this.removeNextStep(body);
                    }
                }
            }
        }
    }

    handleFlame(_body)
    {
        var body = _body;
        var data = body.data;
        this.constrainVelocity(_body, 2000);
        if (this.matchInProgress())
        {
            if (this.isInSmoke(body))
            {
                this.removeNextStep(body);
            }
            else if (data.ticker <= 0)
            {
                //var flamePlayer = this.getPlayerById(data.playerId);
                var pawns = this.getTypes([
                    ObjectType.CHARACTER,
                    ObjectType.DINOSAUR,
                    ObjectType.HELICOPTER,
                    ObjectType.TANK,
                    ObjectType.CAR,
                    ObjectType.DUMMY,
                    ObjectType.EGG,
                    ObjectType.MOUNTED_WEAPON,
                    ObjectType.EQUIPMENT,
                    ObjectType.OBSTACLE
                ]);
                for (var i = 0; i < pawns.length; i++)
                {
                    let pawn = pawns[i];
                    if (!pawn.data || !pawn.data.health || pawn.data.bInvisible || pawn.data.controllableId || pawn.data.bPendingRemoval || pawn.data.bGodMode)
                    {
                        continue;
                    }
                    let ps = this.getPlayerById(pawn.data.id);
                    if (ps && ps.bSpawnProtection)
                    {
                        continue;
                    }
                    let bSelf = pawn.data.id == data.playerId;
                    if (pawn.data.team != data.team || (bSelf && this.game.bFriendlyFire))
                    {
                        if (data.cooldownTimer > 0 && pawn.data.id == data.playerId)
                        {
                            continue;
                        }
                        let dist = this.DistBodies(body, pawn);
                        let bOverlaps = dist < 30; //(body.getAABB() ? body.getAABB().overlaps(pawn.getAABB()) : false);
                        if (bOverlaps)
                        {
                            if (!bSelf && this.isValidArray(_body.velocity))
                            {
                                _body.velocity[0] *= 0.1;
                                _body.velocity[1] *= 0.1;
                            }
                            let dmg = data.damage;
                            let fps = Math.round(30 * this.game.fpsMult);
                            if (data.destroyTimer < fps)
                            {
                                dmg *= (data.destroyTimer / fps);
                            }
                            this.requestEvent({
                                eventId: GameServer.EVENT_PAWN_DAMAGE,
                                damageType: DamageType.DAMAGE_FIRE,
                                damageAmount: dmg,
                                pawnId: pawn.data.id,
                                attackerId: data.playerId,
                                causerId: data.id,
                                weaponId: data.weaponId,
                                bDirectlyCausedByPlayer: body.data.bFromWeapon
                            });
                        }
                    }
                }
                if (data.cooldownTimer > 0)
                {
                    data.cooldownTimer--;
                }
                data.ticker = data.tickerMax;
            }
            else
            {
                data.ticker--;
            }
        }
    }

    handleCrate(_body)
    {
        var data = _body.data;
        switch (data.crateType)
        {
            case Crate.BOMB:
            case Crate.BOMB_GENERIC:
                if (data.bBombPlanted && this.matchInProgress())
                {
                    if (data.bombTimer > 0)
                    {
                        data.bombTimer--;
                        this.pushObjectDataUpdate(data.id, ["bombTimer"]);
                    }
                    else if (!data.bDetonated)
                    {
                        this.detonate(_body);
                    }
                }
                break;
        }
    }

    handleDoor(_body)
    {
        var data = _body.data;
        if (data.cooldownTimer > 0)
        {
            data.cooldownTimer--;
        }
    }

    handleShield(_body)
    {
        var data = _body.data;
        var char = this.getObjectById(data.playerId);
        if (char && char.data.health)
        {
            var curItem = this.getCurrentCharacterInventoryItem(char);
            if (!curItem || curItem.id != "riot_shield")
            {
                this.removeNextStep(_body);
            }
            else
            {
                var weapon = char.data.weapon;
                data.bActive = !char.data.controllableId && !char.data.bWantsToInteract && !char.data.bDoorCooldown && !weapon.bThrowDelay && !weapon.bEquipmentDelay && !weapon.bUseDelay;
                _body.angle = char.data.aimRotation;
                var offset = 25;
                _body.position[0] = char.position[0] + (Math.cos(_body.angle) * offset);
                _body.position[1] = char.position[1] + (Math.sin(_body.angle) * offset);
            }
        }
        else
        {
            this.removeNextStep(_body);
        }
    }

    handleDinosaur(_body)
    {
        this.handlePawn(_body);
        var data = _body.data;       
        if (data.bBot)
        {
            var item = this.getCurrentCharacterInventoryItem(_body);
            if ((item.type != Weapon.TYPE_MELEE && _body.ai.bEnemyLOS) || this.getTotalVelocity(_body) < 100)
            {
                var lookRad = data.aimRotation;
            }
            else
            {
                lookRad = this.Angle(0, 0, _body.velocity[0], _body.velocity[1]);
            }
            var rad = this.WrapAngle(_body.angle - lookRad, true);
            _body.angle -= (rad * 0.25) / _body.mass;            
        }
        else
        {
            //_body.angle = data.aimRotation != null ? data.aimRotation : 0;
            if (data.aimRotation)
            {
                var rad = this.WrapAngle(_body.angle - data.aimRotation, true);
                _body.angle -= (rad * 0.25);    
            }
        }
        var maxSpeed = data.maxSpeed ? data.maxSpeed : 100;
        if (data.bLunge)
        {
            maxSpeed *= data.lungeMult;
        }
        this.constrainVelocity(_body, maxSpeed);
    }

    spawnItem(_data, _position, _team)
    {
        if (_position)
        {
            _data.position = _position;
        }
        if (_data.team == null)
        {
            _data.team = _team;
        }
        return this.createObject(_data);
    }

    handlePawn(_body)
    {
        var data = _body.data;
        if (this.game.bMultiplayer && !data.controllableId && !data.bGodMode && this.isOutOfMap(_body, !data.bBot))
        {
            if (this.game.bSurvival || this.game.gameModeData.bAllowRevives)
            {
                _body.position = this.getBestSpawnPosition(data.team, _body);
            }
            this.killPawn(data.id);
            return;
        }
        if (data.controllableId)
        {
            data.bSprinting = false;
            data.bCrouching = false;
        }

        if (data.type == ObjectType.CHARACTER)
        {
            this.setDataValue(_body, "bJammed", this.hasNearbyJammer(_body));
        }
        if (data.health > data.maxHealth)
        {
            data.health = data.maxHealth;
        }

        if (data.bStunned)
        {
            data.aimRotation -= (data.aimRotation - data.desiredAimRotation) * 0.1;
        }
        else
        {
            data.aimRotation = data.desiredAimRotation;
        }

        if (!data.controllableId)
        {
            if (data.bWantsToMove && this.pawnCanMove(_body) && this.matchInProgress())
            {
                var maxSpeed = data.maxSpeed * this.getCharacterSpeedMultiplier(_body);
                if (data.bStunned || data.bFlashed)
                {
                    maxSpeed = maxSpeed * 0.2;
                }
                else if (data.type == ObjectType.CHARACTER)
                {
                    if (data.bJuiced)
                    {
                        maxSpeed *= this.getSharedData(ObjectType.CHARACTER).juiceSpeedMult;
                    }
                    if (data.bSprinting)
                    {
                        var mult = this.getSharedData(ObjectType.CHARACTER).sprintMult;
                        maxSpeed = maxSpeed * mult;
                    }
                    else if (data.bCrouching)
                    {
                        var mult = this.getSharedData(ObjectType.CHARACTER).crouchMult;
                        maxSpeed = maxSpeed * (mult != null ? mult : 1);
                    }
                }
                else if (data.type == ObjectType.DINOSAUR)
                {
                    if (data.bLunge)
                    {
                        maxSpeed *= data.lungeMult;
                    }
                }
                if (data.moveAngle != null)
                {
                    var moveAngle = data.moveAngle;
                    _body.velocity[0] = Math.cos(moveAngle) * maxSpeed;
                    _body.velocity[1] = Math.sin(moveAngle) * maxSpeed;
                }
            }
        }

        if (data.bCrouching)
        {
            data.bSprinting = false;
        }
        var weapon = data.weapon;
        if (weapon)
        {
            var recoilMult = 0.95; //Lower value is faster recoil recovery
            var recoilDecay = recoilMult * this.game.fpsMult;
            weapon.recoil = this.RoundDecimal(weapon.recoil * recoilDecay);
        }
        var actualItem = this.getCurrentCharacterInventoryItem(_body, false);
        var curInvItem = this.getCurrentCharacterInventoryItem(_body);
        if (weapon.bFireHandler)
        {
            if (!data.bWantsToFire)
            {
                weapon.bFireHandler = false;
            }
            else
            {
                if (this.characterCanFire(_body, true))
                {
                    this.fireCharacterWeapon(_body);
                    switch (curInvItem.fireMode)
                    {
                        case Weapon.MODE_SEMI:
                            weapon.bFireDelay = true;
                            weapon.fireDelayTimer = Math.floor(curInvItem.fireRate * this.game.fpsMult);
                            weapon.bFireHandler = false;
                            break;
                        case Weapon.MODE_BURST:
                            weapon.bFireDelay = true;
                            weapon.fireDelayTimer = Math.floor(curInvItem["burstFireRate"] * this.game.fpsMult);
                            curInvItem["bursts"] = (curInvItem["numBursts"] ? curInvItem["numBursts"] : 3) - 1;
                            weapon.burstTimer = Math.floor(curInvItem.fireRate * this.game.fpsMult);
                            weapon["bBurstFireHandler"] = true;
                            weapon.bFireHandler = false;
                            break;
                        case Weapon.MODE_AUTO:
                        default:
                            weapon.bFireDelay = true;
                            weapon.fireDelayTimer = Math.max(1, Math.ceil(curInvItem.fireRate * this.game.fpsMult));
                            break;
                    }
                }
                else if (curInvItem.mag == 0)
                {
                    this.reloadCharacterWeapon(_body);
                }
                else if (curInvItem.bRequireLock)
                {
                    this.reloadCharacterWeapon(_body);
                }
                else if (data.bReloading)
                {
                    if (curInvItem.bSingleRoundLoaded && curInvItem.mag > 0)
                    {
                        this.cancelCharacterReload(_body);
                    }
                }
            }
        }
        if (weapon["bBurstFireHandler"])
        {
            if (curInvItem["bursts"] > 0)
            {
                if (weapon.burstTimer > 0) 
                {
                    weapon.burstTimer--;
                }
                else 
                {
                    if (curInvItem.mag > 0) 
                    {
                        if (curInvItem["bursts"] > 0)
                        {
                            curInvItem["bursts"]--;
                        }
                        weapon.burstTimer = Math.round(curInvItem.fireRate * this.game.fpsMult);
                        this.fireCharacterWeapon(_body);
                    }
                    else 
                    {
                        weapon["bBurstFireHandler"] = false;
                    }
                }
            }
            else 
            {
                weapon["bBurstFireHandler"] = false;
            }
        }
        if (weapon.bFireDelay)
        {
            weapon.fireDelayTimer--;
            if (weapon.fireDelayTimer <= 0) 
            {
                weapon.bFireDelay = false;
                this.requestEvent({
                    eventId: GameServer.EVENT_PAWN_ACTION,
                    pawnId: data.id,
                    type: GameServer.PAWN_END_FIRE_DELAY
                });
                if (curInvItem["bNeedsBoltPull"])
                {
                    this.pullCharacterBolt(_body);
                }
                else if (curInvItem.mag == 0)
                {
                    if (curInvItem.ammo > 0)
                    {
                        this.reloadCharacterWeapon(_body);
                    }
                    this.onEndWeaponFire(_body);
                }
            }
        }
        if (weapon["bBoltDelay"])
        {
            weapon["boltDelayTimer"]--;
            if (weapon["boltDelayTimer"] <= 0) 
            {
                weapon["bBoltDelay"] = false;
                curInvItem["bNeedsBoltPull"] = false;
                this.requestEvent({
                    eventId: GameServer.EVENT_PAWN_ACTION,
                    pawnId: data.id,
                    type: GameServer.PAWN_END_BOLT_DELAY
                });
                if (curInvItem.mag == 0 && curInvItem.ammo > 0)
                {
                    this.reloadCharacterWeapon(_body);
                }
            }
        }
        if (weapon.bThrowDelay)
        {
            weapon.throwDelayTimer--;
            if (weapon.throwDelayTimer <= 0) 
            {
                weapon.bThrowDelay = false;
                this.requestEvent({
                    eventId: GameServer.EVENT_PAWN_ACTION,
                    pawnId: data.id,
                    type: GameServer.PAWN_END_THROW_DELAY
                });
            }
        }
        if (weapon["bEquipmentDelay"])
        {
            if (weapon["equipmentDelayTimer"] > 0)
            {
                weapon["equipmentDelayTimer"]--;
                if (!data.bCrouching)
                {
                    this.setDataValue(_body, "bCrouching", true);
                }
            }
            else
            {
                weapon["bEquipmentDelay"] = false;
                this.requestEvent({
                    eventId: GameServer.EVENT_PAWN_ACTION,
                    pawnId: data.id,
                    type: GameServer.PAWN_END_EQUIPMENT_DELAY
                });
                this.setDataValue(_body, "bCrouching", false);
            }
        }
        if (weapon["bUseDelay"])
        {
            if (weapon["useDelayTimer"] > 0)
            {
                weapon["useDelayTimer"]--;
            }
            if (weapon["useDelayTimer"] == 0) 
            {
                weapon["useDelayTimer"] = -1;
                var useData = weapon["useData"];
                if (useData)
                {
                    switch (useData.type)
                    {
                        //
                    }
                }
            }
        }
        if (data.juiceTimer > 0)
        {
            data.juiceTimer--;
        }
        else
        {
            delete data.juiceTimer;
            this.setDataValue(_body, "bJuiced", false);
            this.setDataValue(_body, "reloadMultiplier", 1);
            let item = this.getCurrentCharacterInventoryItem(_body);
            if (item)
            {
                
            }
        }
        if (data.vehicleCooldown > 0)
        {
            data.vehicleCooldown--;
        }
        else
        {
            delete data.vehicleCooldown;
        }
        if (data.seatTimer > 0)
        {
            data.seatTimer--;
            if (data.seatTimer <= 0)
            {
                this.requestEvent({
                    eventId: GameServer.EVENT_PAWN_ACTION,
                    pawnId: data.id,
                    type: GameServer.PAWN_SWITCH_SEATS,
                    value: false
                });
                delete data.seatTimer;
                var vehicle = this.getObjectById(data.controllableId);
                if (vehicle)
                {
                    var seatIndex = this.getAvailableSeatIndex(vehicle);
                    if (!data.bBot)
                    {
                        var seats = vehicle.data.seats;
                        for (var i = 0; i < seats.length; i++)
                        {
                            var curSeat = seats[i];
                            if (i > _body.data.seatIndex && !curSeat.pawnId)
                            {
                                seatIndex = i;
                                break;
                            }
                        }
                    }
                    if (seatIndex != null)
                    {
                        this.exitVehicle(_body);
                        this.enterVehicle(_body, vehicle, seatIndex);
                    }
                }
            }
        }
        if (data.stoppingPowerTimer > 0)
        {
            data.stoppingPowerTimer--;
            if (data.stoppingPowerTimer <= 0)
            {
                delete data.stoppingPowerTimer;
                this.setDataValue(_body, "bStoppingPower", false)
            }
        }
        if (data.currentRequest)
        {
            if (data.requestTimer > 0)
            {
                data.requestTimer--;
            }
            else
            {
                delete data.requestTimer;
                this.setDataValue(_body, "currentRequest", 0);
            }
        }
        if (data.bShieldCooldown)
        {
            if (data.shieldCooldownTimer > 0)
            {
                data.shieldCooldownTimer--;
            }
            else
            {
                delete data.bShieldCooldown;
                delete data.shieldCooldownTimer;
                this.requestEvent({
                    eventId: GameServer.EVENT_PAWN_ACTION,
                    pawnId: data.id,
                    type: GameServer.PAWN_END_SHIELD_COOLDOWN,
                    bDoor: data.bDoorCooldown
                });
            }
        }
        if (weapon["bMeleeDelay"])
        {
            weapon["meleeDelayTimer"]--;
            if (weapon["meleeDelayTimer"] <= 0) 
            {
                weapon["bMeleeDelay"] = false;
                this.requestEvent({
                    eventId: GameServer.EVENT_PAWN_ACTION,
                    pawnId: data.id,
                    type: GameServer.PAWN_END_MELEE_DELAY
                });
                if (curInvItem.mag == 0 && curInvItem.ammo > 0)
                {
                    this.reloadCharacterWeapon(_body);
                }
            }
        }
        if (data.bReloading)
        {
            data["reloadTimer"]--;
            if (data["reloadTimer"] == 0)
            {
                data.bReloading = false;
                if (curInvItem["bSingleRoundLoaded"])
                {
                    var roundsToLoad = 1;
                    if (curInvItem["bSpeedLoader"])
                    {
                        var speedLoader = 2;
                        if (weapon.bUnlimitedAmmo)
                        {
                            roundsToLoad = speedLoader;
                        }
                        else if (curInvItem.ammo > speedLoader && (curInvItem.mag + speedLoader) <= curInvItem["magSize"])
                        {
                            roundsToLoad = speedLoader;
                        }
                    }
                    if (!weapon.bUnlimitedAmmo)
                    {
                        curInvItem.ammo = Math.max(curInvItem.ammo - roundsToLoad, 0);
                    }
                    curInvItem.mag = Math.min(curInvItem.mag + roundsToLoad, curInvItem["magSize"]);
                }
                else
                {
                    if (curInvItem.ammo >= curInvItem["magSize"] || weapon.bUnlimitedAmmo) 
                    {
                        if (!weapon.bUnlimitedAmmo)
                        {
                            curInvItem.ammo -= curInvItem["magSize"] - curInvItem.mag;
                        }
                        curInvItem.mag = curInvItem["magSize"];
                    }
                    else if ((curInvItem.ammo + curInvItem.mag) > curInvItem["magSize"]) 
                    {
                        if (!weapon.bUnlimitedAmmo)
                        {
                            curInvItem.ammo -= curInvItem["magSize"] - curInvItem.mag;
                        }
                        curInvItem.mag += (curInvItem["magSize"] - curInvItem.mag);
                    }
                    else 
                    {
                        curInvItem.mag += curInvItem.ammo;
                        if (!weapon.bUnlimitedAmmo)
                        {
                            curInvItem.ammo -= curInvItem.ammo;
                        }
                    }
                }
                var updateObject = {
                    eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                    pawnId: data.id,
                    index: data["currentInventoryIndex"],
                    type: GameServer.INV_ITEM
                };
                if (actualItem.bBarrel)
                {
                    updateObject.bBarrel = 1;
                }
                this.requestEvent(updateObject);
                this.requestEvent({
                    eventId: GameServer.EVENT_PAWN_ACTION,
                    pawnId: data.id,
                    type: GameServer.PAWN_RELOAD_COMPLETE
                });
                if (curInvItem["bSingleRoundLoaded"] && curInvItem.mag < curInvItem["magSize"])
                {
                    this.reloadCharacterWeapon(_body);
                }
            }
        }
        if (data.bInteracting)
        {
            var interactable = this.getObjectById(data.interactableId);
            if (interactable)
            {
                if (data["interactTimer"] > 0)
                {
                    data["interactTimer"]--;
                }
                else
                {
                    if (data.interactableId)
                    {
                        this.executeInteractable(interactable, data.id);
                    }
                    this.stopCharacterInteract(_body);
                }
            }
            else
            {
                this.stopCharacterInteract(_body);
            }
        }
    }

    getCharacterMuzzlePosition(_body)
    {
        if (_body)
        {
            var data = _body.data;
            var rad = data.aimRotation; //data.type == ObjectType.DINOSAUR ? _body.angle : 
            var armsWidth = 5;
            if (data.type == ObjectType.DINOSAUR)
            {
                var shared = this.getSharedData(data.dinoType, false);
                if (shared)
                {
                    armsWidth = shared.size ? shared.size : (shared.width * 0.25);
                }
                else
                {
                    armsWidth = 0;
                }
            }
            var pos = _body.position;
            if (this.isValidArray(data.clientPos))
            {
                pos = [data.clientPos[0], data.clientPos[1]];
            }
            var muzzlePos = [
                pos[0] + (Math.cos(rad) * armsWidth),
                pos[1] + (Math.sin(rad) * armsWidth)
            ];
            return muzzlePos;
        }
        return null;
    }

    isValidArray(_arr)
    {
        if (_arr)
        {
            return !isNaN(_arr[0]) && !isNaN(_arr[1]);
        }
        return false;
    }

    hasUnderbarrelMod(_weaponData)
    {
        return this.hasMod(_weaponData, Mods.ACCESSORY_M203) || this.hasMod(_weaponData, Mods.ACCESSORY_M320) || this.hasMod(_weaponData, Mods.ACCESSORY_GP25) || this.hasMod(_weaponData, Mods.ACCESSORY_MASTERKEY);
    }

    hasMod(_weaponData, _modId)
    {
        if (_weaponData && _modId)
        {
            switch (_modId)
            {
                case Mods.BARREL_SILENCER:
                    if (_weaponData.bSilenced)
                    {
                        return true;
                    }
                    break;
            }
            var mods = _weaponData.mods;
            if (mods)
            {
                var keys = Object.keys(mods);
                for (var i = 0; i < keys.length; i++)
                {
                    let key = keys[i];
                    if (mods[key] == _modId)
                    {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    fireCharacterWeapon(_body)
    {
        var data = _body.data;
        var weapon = data.inventory[data.currentInventoryIndex];
        if (weapon.bBarrel && weapon.barrel)
        {
            weapon = weapon.barrel;
        }
        var rad = data.aimRotation;
        var bSilenced = this.hasMod(weapon, Mods.BARREL_SILENCER);
        var muzzlePos = this.getCharacterMuzzlePosition(_body);
        var bMelee = this.isMeleeWeapon(weapon);
        var numBullets = 1;
        var bShotgun = weapon.type == Weapon.TYPE_SHOTGUN || weapon.bShotgun;
        if (weapon.id == Dinosaur.NEEDLER)
        {
            numBullets = 2;
        }
        else if (bShotgun && !weapon.bSlug)
        {
            numBullets = 8;
        }
        for (var i = 0; i < numBullets; i++)
        {
            var useAccuracy = weapon.accuracy;
            if (weapon.type != Weapon.TYPE_SHOTGUN)
            {
                useAccuracy *= (data.bAiming ? 0.8 : 1);
            }
            useAccuracy *= 10;
            var bulletRad = rad + this.ToRad(this.Random(-useAccuracy, useAccuracy) * 0.1);
            bulletRad += this.ToRad(data.weapon.recoil);
            if (weapon.id == "quadra")
            {
                let addRot = this.ToRad(weapon.mag % 2 == 0 ? 90 : -90);
                let bulletSpacing = 10;
                muzzlePos = this.getCharacterMuzzlePosition(_body);
                muzzlePos[0] += (Math.cos(data.aimRotation + addRot) * bulletSpacing);
                muzzlePos[1] += (Math.sin(data.aimRotation + addRot) * bulletSpacing);
            }
            if (weapon.bRocket)
            {
                var rocketData = {
                    rocketType: weapon.rocketType ? weapon.rocketType : Rocket.DEFAULT,
                    team: data.team,
                    playerId: data.id,
                    causerId: data.id,
                    angle: bulletRad,
                    weaponId: weapon.id,
                    damage: weapon.damage,
                    radius: weapon.radius,
                    bRequireLock: weapon.bRequireLock,
                    bCanLock: weapon.bCanLock,
                    lockOnTargetId: data.lockOnTargetId
                };
                if (weapon.fireDamage)
                {
                    rocketData.weaponData = weapon;
                }
                this.createRocket(muzzlePos, rocketData);
            }
            else if (weapon.bGrenade)
            {
                var grenadeDamage = weapon.damage;
                if (weapon.mods)
                {
                    switch (weapon.mods[Mods.TYPE_AMMO])
                    {
                        case Mods.GRENADE_SMOKE:
                        case Mods.GRENADE_FLASH:
                            //grenadeDamage = 100;
                            break;
                    }
                }
                this.createGrenade(muzzlePos, {
                    team: data.team,
                    playerId: data.id,
                    causerId: data.id,
                    rotation: bulletRad,
                    velocity: weapon.velocity ? weapon.velocity : 1500,
                    damage: grenadeDamage,
                    weaponData: weapon,
                    weaponId: weapon.id,
                    modId: weapon.mods ? weapon.mods[Mods.TYPE_AMMO] : null,
                    bImpact: true,
                    bMinimumDistance: true
                });
            }
            else if (weapon.bProjectile)
            {
                if (data.attachId)
                {
                    this.detachRope(_body);
                }
                else
                {
                    var vel = 200;
                    if (weapon.id == Dinosaur.NEEDLER)
                    {
                        vel = this.Random(200, 250);
                    }
                    this.createProjectile(muzzlePos, bulletRad, data.team, {
                        playerId: data.id,
                        causerId: data.id,
                        rotation: bulletRad,
                        velocity: vel,
                        weaponId: weapon.id,
                        frameId: weapon.frameId,
                        sourceId: data.id
                    });
                }
            }
            else if (weapon.bFlame)
            {
                var flameVel = weapon.velocity ? weapon.velocity : 1300;
                var flameSpeed = this.Random(flameVel, flameVel + 200);
                var flame = this.createFlame(muzzlePos, [Math.cos(bulletRad) * flameSpeed, Math.sin(bulletRad) * flameSpeed], data.team, data.id, weapon, weapon.fireTime, true);
            }
            else if (weapon.bArrow)
            {
                var damage = weapon.damage;
                if (this.game.bSurvival)
                {
                    damage *= 5;
                }                
                this.createProjectile(muzzlePos, bulletRad, data.team, {
                    playerId: data.id,
                    causerId: data.id,
                    rotation: bulletRad,
                    velocity: 300,
                    damage: damage,
                    weaponId: weapon.id,
                    frameId: "arrow"
                });
            }
            else if (weapon.id == "blowtorch")
            {
                let objectToRepair = this.getTouchingRepairableObject(_body);
                if (objectToRepair && objectToRepair.data.health < objectToRepair.data.maxHealth)
                {
                    objectToRepair.data.health = Math.min(objectToRepair.data.maxHealth, objectToRepair.data.health + 10);
                    this.pushObjectDataUpdate(objectToRepair.data.id, ["health"]);
                    var bRepair = true;
                }
                else
                {
                    return;
                }
            }
            else
            {
                var useDamage = weapon.damage;
                this.createBullet({
                    x: muzzlePos[0],
                    y: muzzlePos[1],
                    rotation: bulletRad,
                    range: weapon.range,
                    damage: useDamage,
                    instigatorId: data.id,
                    causerId: data.id,
                    weaponId: weapon.id,
                    weaponData: weapon,
                    bDirectlyCausedByPlayer: true,
                    bMelee: bMelee,
                    bIgnoreObstacles: this.isInHelicopter(_body)
                });
            }
        }
        var useRecoil = weapon.recoil;
        if (data.bAiming && this.hasMod(weapon, Mods.ACCESSORY_GRIP_ANGLED))
        {
            useRecoil *= 0.25;
        }
        //Post-recoil
        if (!weapon.bBoltAction)
        {
            var rand = this.Random(1, 2);
            var scaleVal = data.scale == 1 ? -1 : 1;
            var recoilMult = (data.bAiming ? 0.5 : 1);
            var recoilVal = useRecoil + (Math.abs(useRecoil) * 0.2);
            data.weapon.recoil += -(recoilVal * recoilMult) * (rand == 1 ? scaleVal : -scaleVal);
        }
        if (weapon.type == Weapon.TYPE_MELEE)
        {
            var meleeObj = {
                eventId: GameServer.EVENT_PAWN_ACTION,
                pawnId: data.id,
                type: GameServer.PAWN_FIRE_MELEE,
                recoil: weapon.recoil
            };
            if (bRepair)
            {
                meleeObj.bRepair = bRepair == true ? 1 : 0;
            }
            this.requestEvent(meleeObj);
            if (data.bBot && data.type == ObjectType.DINOSAUR)
            {
                var force = -20 * _body.mass;
                _body.applyImpulse([Math.cos(_body.angle) * force, Math.sin(_body.angle) * force], [0, 0]);
            }
        }
        else
        {
            this.requestEvent({
                eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                pawnId: data.id,
                index: data.currentInventoryIndex,
                type: GameServer.INV_FIRE
            });
            this.requestEvent({
                eventId: GameServer.EVENT_PAWN_ACTION,
                pawnId: data.id,
                type: GameServer.PAWN_FIRE_WEAPON,
                recoil: useRecoil
            });
        }
        if (weapon.bSilenced || this.hasMod(weapon, Mods.BARREL_SILENCER) || this.isMeleeWeapon(weapon) || weapon.round == "arrow")
        {
            var soundRadius = 200;
        }
        else
        {
            soundRadius = 1000 + Math.min(500, weapon.damage);
        }
        if (!data.bUntargetable)
        {
            this.emitAISound(_body.position, _body.position, soundRadius, data.team);
        }
    }

    emitAISound(_targetPos, _sourcePos, _radius, _team)
    {       
        if (this.game.scenario || this.game.bOpenWorld)
        {
            if (!_targetPos)
            {
                console.warn("Invalid target position");
                return;
            }
            if (!_sourcePos)
            {
                _sourcePos = _targetPos;
            }
            var pawns = this.getCharactersAndDinosaurs();
            for (var i = 0; i < pawns.length; i++)
            {
                let pawn = pawns[i];
                let data = pawn.data;
                if (data.bBot && data.bIgnoreOutOfSight && data.team != _team)
                {
                    var ai = pawn.ai;
                    if (ai && ai.bInvestigate)
                    {
                        let dist = this.DistPositions(pawn.position, _sourcePos);
                        if (dist <= _radius)
                        {                     
                            pawn.wakeUp();
                            this.setAIInvestigatePos(pawn, this.clone(_targetPos))
                            if (!ai.enemy)
                            {
                                this.requestEvent({
                                    eventId: GameServer.EVENT_PAWN_ACTION,
                                    pawnId: data.id,
                                    type: GameServer.PAWN_INVESTIGATE,
                                    value: "sound"
                                });
                            }
                        }
                    }
                }
            }
        }
    }

    //createBullet(_x, _y, _rotation, _range, _damage, _instigatorId, _causerId, _weaponId, _weaponData, _bDirectlyCausedByPlayer, _bMelee, _bIgnoreObstacles)
    createBullet(_data)
    {
        var _x = _data.x;
        var _y = _data.y;
        var _rotation = _data.rotation;
        var _range = _data.range;
        var _damage = _data.damage;
        var _instigatorId = _data.instigatorId;
        var _causerId = _data.causerId;
        var _weaponId = _data.weaponData ? _data.weaponData.id : _data.weaponId;
        var _weaponData = _data.weaponData;
        var _bDirectlyCausedByPlayer = _data.bDirectlyCausedByPlayer == true;
        var _bMelee = _data.bMelee == true;
        var _bIgnoreObstacles = _data.bIgnoreObstacles == true;

        var dist = _range;
        var vx = Math.cos(_rotation) * dist;
        var vy = Math.sin(_rotation) * dist;
        var causer = this.getObjectById(_causerId);
        var data = {
            eventId: GameServer.EVENT_SPAWN_BULLET,
            startX: Math.round(_x),
            startY: Math.round(_y),
            endX: Math.round(_x + vx),
            endY: Math.round(_y + vy),
            rotation: _rotation,
            team: causer ? causer.data.team : -1,
            damageAmount: _damage,
            controllerId: _instigatorId,
            causerId: _causerId,
            weaponId: _weaponId,
            weaponData: _weaponData
        }
        if (_bMelee)
        {
            data.bMelee = true;
        }
        if (_bDirectlyCausedByPlayer) data.bDirectlyCausedByPlayer = true;
        if (_bIgnoreObstacles) data.bIgnoreObstacles = true;
        if (this.hasMod(_weaponData, Mods.BARREL_SILENCER)) data.bSilenced = true;
        this.requestEvent(data);
    }

    addInventoryItemAmmo(_body, _index, _ammo)
    {
        if (!_body)
        {
            return;
        }
        var data = _body.data;
        var inventory = data.inventory;
        var invItem = inventory[_index];
        if (invItem && !invItem.bMelee && !invItem.bEquipment && invItem.ammo != null)
        {
            this.requestEvent({
                eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                pawnId: data.id,
                index: _index,
                type: GameServer.INV_AMMO_ADD,
                value: _ammo,
            });
        }
    }

    setCharacterCurrentInventoryItem(_body, _index)
    {
        this.cancelCharacterReload(_body);
        this.cancelCharacterBoltPull(_body);
        var data = _body.data;
        var prevIndex = data.currentInventoryIndex;
        if (prevIndex == _index)
        {
            if (prev && prev.barrel)
            {
                this.toggleUnderbarrelEquipped(_body);
                return;
            }
        }
        var prev = data.inventory[prevIndex];
        data.currentInventoryIndex = _index;
        data.lockOnTargetId = null;
        var item = this.getCurrentCharacterInventoryItem(_body);
        if (!item)
        {
            console.warn("Invalid inventory item at index", _index);
            return;
        }
        if (item.bBarrel && item.barrel)
        {
            item = item.barrel;
        }
        if (prev)
        {
            if (prev.id == "riot_shield")
            {
                data.bShieldCooldown = true;
                data.shieldCooldownTimer = Math.ceil(this.game.settings.fps * 0.25);
                this.requestEvent({
                    eventId: GameServer.EVENT_PAWN_ACTION,
                    pawnId: data.id,
                    type: GameServer.PAWN_START_SHIELD_COOLDOWN
                });
            }
        }
        data.reloadTimerMax = Math.round(Math.ceil(item.reloadTime * this.game.settings.fps) * _body.data.reloadMultiplier);
        data.reloadTimer = _body.data.reloadTimerMax;
        data.aimRotation = this.ToRad(-90);
        data.speedMultiplier = item.speedModifier != null ? item.speedModifier : 1;
        if (item["bNeedsBoltPull"])
        {
            this.pullCharacterBolt(_body);
        }
        if (data["lockOnTargetId"] != null)
        {
            data["lockOnTargetId"] = null;
        }
        if (item.mag == 0)
        {
            this.reloadCharacterWeapon(_body);
        }
        if (item.id == "riot_shield")
        {
            var shield = this.createShield(_body);
            if (shield)
            {
                data.shieldId = shield.data.id;
            }
        }
        else
        {
            if (data.shieldId)
            {
                this.removeObjectById(_body.data.shieldId);
                delete _body.data.shieldId;
            }
        }
    }

    createShield(_body)
    {
        var char = _body;
        if (!char)
        {
            return null;
        }
        var shared = this.getSharedData("shield");
        var body = new this.p2.Body({
            damping: 0,
            angularDamping: 0,
            gravityScale: 0,
            position: char.position
        });
        body.data = {
            id: this.getRandomUniqueId(),
            type: ObjectType.SHIELD,
            material: Material.METAL,
            playerId: char.data.id,
            team: char.data.team,
            bActive: true
        };
        var shape = new this.p2.Box({
            width: shared.width,
            height: shared.height,
            collisionGroup: CollisionGroups.SHIELD,
            collisionMask: CollisionGroups.PROJECTILE
        });
        body.addShape(shape);
        this.addWorldBody(body);
        this.onEvent({
            eventId: GameServer.EVENT_SPAWN_OBJECT,
            position: body.position,
            rotation: body.angle,
            data: body.data
        });
        return body;
    }

    pullCharacterBolt(_body)
    {
        var data = _body.data;
        if (!data)
        {
            return;
        }
        data.weapon.bBoltDelay = true;
        var item = this.getCurrentCharacterInventoryItem(_body);
        if (!item)
        {
            return;
        }
        data.weapon.boltDelayTimer = item.boltDelayTimer * this.game.settings.fps;
        this.requestEvent({
            eventId: GameServer.EVENT_PAWN_ACTION,
            pawnId: data.id,
            type: GameServer.PAWN_PULL_BOLT,
            index: data.currentInventoryIndex
        });
    }

    cancelCharacterReload(_body)
    {
        var data = _body.data;
        if (!data)
        {
            return;
        }
        if (data.bReloading)
        {
            this.requestEvent({
                eventId: GameServer.EVENT_PAWN_ACTION,
                pawnId: data.id,
                type: GameServer.PAWN_CANCEL_RELOAD
            });
        }
        data.bReloading = false;
    }

    cancelCharacterBoltPull(_body)
    {
        var data = _body.data;
        if (!data)
        {
            return;
        }
        if (data.weapon.bBoltDelay)
        {
            this.requestEvent({
                eventId: GameServer.EVENT_PAWN_ACTION,
                pawnId: data.id,
                type: GameServer.PAWN_CANCEL_BOLT_PULL
            });
        }
        data.weapon.bBoltDelay = false;
    }

    getSurfaceNormal(_body)
    {
        if (_body)
        {
            var world = this.game.world;
            for (var i = 0; i < world.narrowphase.contactEquations.length; i++)
            {
                var c = world.narrowphase.contactEquations[i];
                if (c.bodyA === _body || c.bodyB === _body)
                {
                    return c.normalA;
                }
            }
        }
        return null;
    }

    isCharacter(_body)
    {
        if (_body)
        {
            return _body.data.type == ObjectType.CHARACTER;
        }
        return false;
    }

    isHelicopter(_body)
    {
        if (_body)
        {
            return _body.data.type == ObjectType.HELICOPTER;
        }
        return false;
    }

    isInHelicopter(_body)
    {
        if (_body)
        {
            var data = _body.data;
            if (data.controllableId)
            {
                var veh = this.getObjectById(data.controllableId);
                if (veh)
                {
                    return veh.data.type == ObjectType.HELICOPTER;
                }
            }
        }
        return false;
    }

    isTank(_body)
    {
        if (_body)
        {
            return _body.data.type == ObjectType.TANK;
        }
        return false;
    }

    isCar(_body)
    {
        if (_body)
        {
            return _body.data.type == ObjectType.CAR;
        }
        return false;
    }

    isDinosaur(_body)
    {
        if (_body)
        {
            return _body.data.type == ObjectType.DINOSAUR || _body.data.type == ObjectType.FLYING_DINOSAUR;
        }
        return false;
    }

    isVehicle(_body, _bDrivableOnly)
    {
        if (_body)
        {
            switch (_body.data.type)
            {
                case ObjectType.MOUNTED_WEAPON:
                    if (!_bDrivableOnly)
                    {
                        return true;
                    }
                    break;
                case ObjectType.HELICOPTER:
                case ObjectType.TANK:
                case ObjectType.CAR:
                    return true;
            }
        }
        return false;
    }

    pawnCanMove(_body)
    {
        var data = _body.data;
        var ps = this.getPlayerById(data.id);
        if (ps)
        {
            if (ps.controllableId)
            {
                return false;
            }
        }
        return !data.bEquipmentDelay && !data.bInteracting && !data.attachToId && this.matchInProgress();
    }

    characterHasWeaponDelay(_body)
    {
        var weapon = _body.data.weapon;
        return weapon.bFireDelay || weapon.bMeleeDelay || weapon.bThrowDelay || weapon.bEquipmentDelay || weapon.bUseDelay;
    }

    onSpawnProtectionTimer(_playerId)
    {
        this.removeSpawnProtection(_playerId);
    }

    startSpawnProtectionTimer(_playerId)
    {
        var ps = this.getPlayerById(_playerId);
        if (ps)
        {
            var protectionTime = this.game.gameSettings.spawnProtectionTime ? this.game.gameSettings.spawnProtectionTime : 1;
            ps.timer_spawnProtection = Math.ceil(this.game.settings.fps * protectionTime);
            ps.bSpawnProtection = true;
            var pawn = this.getObjectById(_playerId);
            if (pawn)
            {
                this.setDataValue(pawn, "bSpawnProtection", ps.bSpawnProtection);
            }
            this.onEvent({
                eventId: GameServer.EVENT_PLAYER_UPDATE,
                playerId: ps.id,
                data: {
                    bSpawnProtection: ps.bSpawnProtection
                }
            });
        }
    }

    removeSpawnProtection(_playerId)
    {
        var ps = this.getPlayerById(_playerId);
        if (ps)
        {
            if (ps.timer_spawnProtection != null)
            {
                delete ps.timer_spawnProtection;
                ps.bSpawnProtection = false;
                var pawn = this.getObjectById(_playerId);
                if (pawn)
                {
                    this.setDataValue(pawn, "bSpawnProtection", ps.bSpawnProtection);
                }
                this.onEvent({
                    eventId: GameServer.EVENT_PLAYER_UPDATE,
                    playerId: ps.id,
                    data: {
                        bSpawnProtection: ps.bSpawnProtection
                    }
                });
            }
        }
    }

    onRespawnTimer(_playerId)
    {
        if (!this.game)
        {
            return;
        }
        if (!this.game.bPaused)
        {
            var ps = this.getPlayerById(_playerId);
            if (ps.id == _playerId)
            {
                if (!ps.controllableId)
                {
                    ps.respawnTimer--;
                    if (ps.respawnTimer < 0)
                    {
                        ps.respawnTimer = -1;
                        ps.bCanRespawn = true;
                        ps.bWaitingToRespawn = false;
                        if (ps.bAutoRespawn && !ps.bSpectator)
                        {
                            if (this.getReviverByPlayerId(ps.id))
                            {
                                delete ps.inventory;
                            }
                            this.respawnPlayer(ps.id);
                        }
                    }
                    else
                    {
                        ps.timer_respawn = this.game.settings.fps;
                    }
                    this.onEvent({
                        eventId: GameServer.EVENT_PLAYER_UPDATE,
                        playerId: ps.id,
                        data: {
                            bWaitingSpawn: ps.bWaitingToRespawn,
                            bCanRespawn: ps.bCanRespawn,
                            respawnTimer: ps.respawnTimer,
                            bHasPawn: ps.bHasPawn
                        }
                    });
                }
            }
        }
    }

    isInitialized()
    {
        return this.bInit;
    }

    setPaused(_bVal)
    {
        this.game.bPaused = _bVal;
        var timers = [this.game.timer_game, this.game.timer_preGame];
        for (var i = 0; i < timers.length; i++)
        {
            var timer = timers[i];
            if (timer)
            {
                if (_bVal)
                {
                    timer.pause();
                }
                else
                {
                    timer.resume();
                }
            }
        }
    }

    onPreGameTimer()
    {
        if (!this.game)
        {
            return;
        }
        if (!this.game.bPaused)
        {
            this.game.preGameTimer--;
            if (this.game.preGameTimer < 0)
            {
                clearInterval(this.game.timer_preGame);
                delete this.game.timer_preGame;
                delete this.game.preGameTimer;
                var players = this.game.players;
                for (var i = 0; i < players.length; i++)
                {
                    var ps = players[i];
                    ps.bAutoRespawn = true;
                    this.onEvent({
                        eventId: GameServer.EVENT_PLAYER_UPDATE,
                        playerId: ps.id,
                        data: {
                            bAutoRespawn: ps.bAutoRespawn
                        }
                    });
                }
                this.game.state = MatchState.STATE_IN_PROGRESS;
                this.requestEvent({
                    eventId: GameServer.EVENT_GAME_START,
                    timer: this.game.gameTimer
                });
            }
            else
            {
                this.onEvent({
                    eventId: GameServer.EVENT_GAME_PRE_TIMER,
                    timer: this.game.preGameTimer
                });
            }
        }
    }

    onGameTimer()
    {
        if (!this.game)
        {
            return;
        }
        if (!this.game.bPaused && !this.game.preGameTimer && !this.game.cinematic)
        {
            switch (this.game.gameModeId)
            {
                default:
                    if (this.game.gameModeData.timeLimit)
                    {
                        this.game.gameTimer--;
                    }
                    else
                    {
                        this.game.gameTimer++;
                    }
                    break;
            }

            switch (this.game.gameModeId)
            {
                case GameMode.OPEN_WORLD:   
                    var owData = {
                        worldTime: this.game.gameModeData.worldTime
                    };
                    var timeMult = 1;
                    this.game.gameModeData.worldTime += 1 * timeMult;
                    if (this.game.gameModeData.worldTime > 1440)
                    {
                        this.game.gameModeData.worldTime = 0;
                        this.game.gameModeData.day++;
                        owData.day = this.game.gameModeData.day++;
                    }
                    var worldTime = this.game.gameModeData.worldTime;
                    var events = this.data.openWorld.events;
                    if (events)
                    {
                        for (var i = 0; i < events.length; i++)
                        {
                            let event = events[i];
                            if (worldTime % event.time == 0)
                            {
                                this.handleOpenWorldEvent(event);
                            }
                        }
                    }
                    if (worldTime % 60 == 0)
                    {                       
                        //Give bots a new wander area
                        var pawns = this.getCharactersAndDinosaurs();
                        for (var i = 0; i < pawns.length; i++)
                        {
                            let pawn = pawns[i];
                            if (pawn.data.bBot && pawn.ai)
                            {
                                this.setAIWanderArea(pawn, this.Random(500, 1000));
                            }
                        }
                    }                    
                    this.onEvent({
                        eventId: GameServer.EVENT_GAME_UPDATE,
                        data: owData
                    });
                    break;

                case GameMode.EXTRACTION:
                    var extractZone = this.getObjectById("extractZone");
                    if (extractZone)
                    {
                        var humanPlayers = this.getPlayersOnTeam(0);
                        var numTouching = 0;
                        for (var i = 0; i < humanPlayers.length; i++)
                        {
                            let humanPawn = this.getObjectById(humanPlayers[i].id);
                            if (humanPawn && this.DistBodies(humanPawn, extractZone) < 100)
                            {
                                numTouching++;
                            }
                        }
                        if (numTouching >= humanPlayers.length)
                        {
                            for (var i = 0; i < humanPlayers.length; i++)
                            {
                                this.removeObjectById(humanPlayers[i].id);
                            }
                            var extractHeli = this.getObjectById("extractHeli");
                            if (extractHeli)
                            {
                                extractHeli.data.defendTimer = 1;
                            }
                            this.addScore(0, 1);
                            this.requestEvent({
                                eventId: GameServer.EVENT_GAME_END,
                                condition: MatchState.END_CONDITION_HUMANS_EXTRACTED,
                                winningTeam: 0,
                                cameraTargetId: "extractHeli"
                            });
                        }
                    }
                    if (this.game.gameModeData.numAirdrops > 0)
                    {             
                        var gameUpdate = {
                            nextAirdropTimer: this.game.gameTimer % this.game.gameModeData.airdropTimerMax
                        }
                        if (this.game.gameTimer % this.game.gameModeData.airdropTimerMax == 0)
                        {
                            //Extraction airdrop
                            var heli = this.createHelicopter([this.RandomBoolean() ? 0 : this.getMapWidth(), this.RandomBoolean() ? 0 : this.getMapHeight()], {
                                vehicleId: Helicopter.MH6,
                                team: 0,
                                destination: this.getSpawnPointForTeam(1),
                                items: [
                                    {
                                        type: ObjectType.CRATE,
                                        crateType: Crate.OBJECTIVE,
                                        team: 0,
                                        mass: 0,
                                        bDisposable: false,
                                        bLimitInteraction: true
                                    }
                                ],
                                bAutomated: true,
                                bGodMode: true,
                                bUntargetable: true,
                                departSpeedMult: 2
                            });
                            this.onEvent({
                                eventId: GameServer.EVENT_MESSAGE_ADD,
                                data: {
                                    message: "STR_AIRDROP_INBOUND",
                                    hqId: "hq_friendly_package"
                                }
                            });
                            this.game.gameModeData.numAirdrops--;
                            gameUpdate.numAirdrops = this.game.gameModeData.numAirdrops;
                        }
                        this.onEvent({
                            eventId: GameServer.EVENT_GAME_UPDATE,
                            data: gameUpdate
                        });
                    }
                    if (this.game.gameTimer % 30 == 0)
                    {
                        //Extraction egg
                        /*
                        var egg = this.createEgg(this.getBestSpawnPosition(1), {
                            eggType: Egg.LARGE,
                            team: 1,
                            items: [
                                {
                                    type: ObjectType.DINOSAUR,
                                    dinoType: this.getRandomDinosaur(),
                                    bBot: true,
                                    botSkill: BotSkill.SKILL_HARD,
                                    team: 1
                                },
                                {
                                    type: ObjectType.DINOSAUR,
                                    dinoType: this.getRandomDinosaur(),
                                    botSkill: BotSkill.SKILL_HARD,
                                    team: 1
                                },
                                {
                                    type: ObjectType.DINOSAUR,
                                    dinoType: this.getRandomDinosaur(),
                                    botSkill: BotSkill.SKILL_HARD,
                                    team: 1
                                }
                            ]
                        });
                        */
                    }
                    break;
            }

            if (this.game.gameSettings.bRandomAirdrops)
            {
                if (this.game.gameTimer % (this.game.gameSettings.airdropTimer != null ? this.game.gameSettings.airdropTimer : 60) == 0)
                {
                    var airdropTeam = this.game.gameSettings.airdropTeam != null ? this.game.gameSettings.airdropTeam : 100;
                    if (this.getNumHelicoptersOnTeam(airdropTeam, [Helicopter.MH6]) < 10)
                    {
                        var heli = this.createHelicopter([this.RandomBoolean() ? 0 : this.getMapWidth(), this.RandomBoolean() ? 0 : this.getMapHeight()], {
                            vehicleId: Helicopter.MH6,
                            team: airdropTeam,
                            destination: this.getBestSpawnPosition(airdropTeam),
                            items: [
                                {
                                    type: ObjectType.CRATE,
                                    crateType: Crate.ITEM,
                                    itemId: this.getRandomItemId()
                                }
                            ],
                            bAutomated: true
                        });
                        if (heli)
                        {
                            this.onEvent({
                                eventId: GameServer.EVENT_MESSAGE_ADD,
                                data: {
                                    message: "STR_AIRDROP_INBOUND",
                                    hqId: "hq_friendly_package"
                                }
                            });
                        }
                    }
                }
            }

            if (this.game.gameModeData.timeLimit)
            {
                this.onEvent({
                    eventId: GameServer.EVENT_GAME_TIMER,
                    timer: this.game.gameTimer
                });
            }
            this.dispatchTrigger({
                event: "gameTimer",
                value: this.game.gameTimer
            });

            if (this.game.gameTimer < 0)
            {
                clearInterval(this.game.timer_game);
                delete this.game.timer_game;
                if (this.game.gameModeData.round != null)
                {
                    switch (this.game.gameModeId)
                    {
                        case GameMode.HEADQUARTERS:
                            this.winRound(MatchState.END_CONDITION_TIME, null);
                            break;
                        case GameMode.ASSASSINATION:
                            this.winRound(MatchState.END_CONDITION_TIME, this.game.gameModeData.vipTeam == 0 ? 0 : 1, 1);
                            break;
                        case GameMode.DINO_RESCUE:
                            this.winRound(MatchState.END_CONDITION_TIME, this.game.gameModeData.rescueTeam == 0 ? 1 : 0, 1);
                            break;
                        case GameMode.DEMOLITION:
                            this.winRound(MatchState.END_CONDITION_TIME, this.game.gameModeData.bombTeam == 0 ? 1 : 0, 1);
                            break;
                    }    
                }
                else
                {
                    var endObj = {
                        eventId: GameServer.EVENT_GAME_END,
                        condition: MatchState.END_CONDITION_TIME
                    };
                    switch (this.game.gameModeId)
                    {
                        case GameMode.SCENARIO:
                            endObj.winningTeam = this.game.gameSettings.timeLimitWinningTeam;
                            break;
                        case GameMode.TYRANT:
                        case GameMode.EVOLUTION:
                            endObj.winningTeam = 0;
                            var scores = this.game.gameModeData.scores;
                            scores[0]++;
                            break;
                        case GameMode.EXTRACTION:
                            endObj.winningTeam = 1;
                            var scores = this.game.gameModeData.scores;
                            scores[1]++;
                            break;
                        case GameMode.FREE_FOR_ALL:
                            var players = this.getPlayers();
                            players.sort(function (a, b)
                            {
                                if (a.kills < b.kills) return 1;
                                if (a.kills > b.kills) return -1;
                                return 0;
                            });
                            if (players.length > 0)
                            {
                                if (players.length > 1 && players[1].kills == players[0].kills)
                                {
                                    endObj.winningTeam = -1; //Draw
                                }
                                else
                                {
                                    endObj.winningTeam = players[0].team;
                                    endObj.playerId = players[0].id;
                                }
                            }
                            break;

                        default:
                            var scores = this.game.gameModeData.scores;
                            if (scores)
                            {
                                if (scores[0] > scores[1])
                                {
                                    endObj.winningTeam = 0;
                                }
                                else if (scores[1] > scores[0])
                                {
                                    endObj.winningTeam = 1;
                                }
                                else
                                {
                                    endObj.winningTeam = -1; //Draw
                                }
                            }
                            break;
                    }
                    if (scores)
                    {
                        this.onEvent({
                            eventId: GameServer.EVENT_GAME_UPDATE,
                            data: {
                                scores: scores
                            }
                        });
                    }
                    this.requestEvent(endObj);
                }
            }
        }
    }

    isHoldingFlag(_body)
    {
        if (_body)
        {
            switch (this.game.gameModeId)
            {
                case GameMode.DEFENDER:
                    var flag = null; //this.getDefenderFlag();
                    if (flag)
                    {
                        return flag.data.carrierId == _body.data.id;
                    }
                    break;

                case GameMode.CAPTURE_THE_FLAG:
                    var flags = [this.getFlagCTF(0), this.getFlagCTF(1)];
                    for (var i = 0; i < flags.length; i++)
                    {
                        flag = flags[i];
                        if (flag && flag.data.carrierId == _body.data.id)
                        {
                            return true;
                        }
                    }
                    break;
            }
        }
        return false;
    }

    isNearFlag(_body)
    {
        if (_body)
        {
            var flags = this.getFlags();
            for (var i = 0; i < flags.length; i++)
            {
                let flag = flags[i];
                var bOverlaps = this.DistBodies(_body, flag) < 200;
                if (bOverlaps)
                {
                    return true;
                }
            }
        }
        return false;
    }

    isNearFriendlyObjective(_body)
    {
        if (_body)
        {
            var flags = this.getFlags();
            for (var i = 0; i < flags.length; i++)
            {
                let flag = flags[i];
                var bOverlaps = this.DistBodies(_body, flag) < 200;
                if (bOverlaps)
                {
                    return flag.data.team == _body.data.team;
                }
            }
            var bombs = this.getBombCrates();
            for (var i = 0; i < bombs.length; i++)
            {
                var bomb = bombs[i];
                if (this.Dist(bomb.position[0], bomb.position[1], _body.position[0], _body.position[1]) < 200)
                {
                    return bomb.data.team == _body.data.team;
                }
            }
        }
        return false;
    }

    isNearEnemyObjective(_body)
    {
        if (_body)
        {
            var flags = this.getFlags();
            for (var i = 0; i < flags.length; i++)
            {
                let flag = flags[i];
                if (this.DistBodies(_body, flag) < 200)
                {
                    return flag.data.team != _body.data.team;
                }
            }
            var bombs = this.getBombCrates();
            for (var i = 0; i < bombs.length; i++)
            {
                let bomb = bombs[i];
                if (this.Dist(bomb.position[0], bomb.position[1], _body.position[0], _body.position[1]) < 200)
                {
                    return bomb.data.team != _body.data.team;
                }
            }
        }
        return false;
    }

    sendBatchData()
    {
        if (!this.game)
        {
            console.log("Invalid game for batch data");
            return;
        }
        if (this.batchData.length > 0)
        {
            for (var i = 0; i < this.batchData.length; i++)
            {
                let item = this.batchData[i];
                this.optimizeKeys(item);
            }
            this.onEventFunc({
                eventId: GameServer.EVENT_BATCH,
                lobbyId: this.lobbyId,
                items: this.batchData
            });
            this.batchData = [];
        }
    }

    removePlayer(_id)
    {
        var players = this.game.players;
        for (var i = 0; i < players.length; i++)
        {
            var ps = players[i];
            if (ps.id == _id)
            {
                var timer = ps.timer_respawn;
                if (timer)
                {
                    delete ps.timer_respawn;
                }
                timer = ps.timer_spawnProtection;
                if (timer)
                {
                    delete ps.timer_spawnProtection;
                }
                players.splice(i, 1);
                return true;
            }
        }
        console.warn("Player does not exist:", _id);
        return false;
    }

    stopAllTimers()
    {
        var game = this.game;
        if (game["timer_game"])
        {
            var timer = game["timer_game"];
            clearInterval(timer);
            delete game["timer_game"];
        }
        if (game["timer_preGame"])
        {
            timer = game["timer_preGame"];
            clearInterval(timer);
            delete game["timer_preGame"];
        }
        var players = game.players;
        for (var i = 0; i < players.length; i++)
        {
            var player = players[i];
            timer = player["timer_respawn"];
            if (timer)
            {
                delete player["timer_respawn"];
            }
            timer = player["timer_spawnProtection"];
            if (timer)
            {
                delete player["timer_spawnProtection"];
            }
        }
    }

    getSpawnPointForTeam(_team)
    {
        if ((this.isPreGame() && this.isTeamGameMode()) || this.game.gameSettings.bUseTeamSpawns || this.game.bOpenWorld)
        {
            var teamSpawns = this.getCurrentMapData().teamSpawns;
            if (teamSpawns)
            {
                var index = _team;
                switch (this.game.gameModeId)
                {
                    case GameMode.HEADQUARTERS:
                        index = _team == (this.game.gameModeData.round + 1) % 2 == 0 ? 0 : 1;
                        break;
                    case GameMode.DEMOLITION:
                        index = _team == this.game.gameModeData.bombTeam ? 1 : 0;
                        break;
                    case GameMode.ASSASSINATION:
                        index = _team == this.game.gameModeData.vipTeam ? 0 : 1;
                        break;
                    case GameMode.DINO_RESCUE:
                        index = _team == this.game.gameModeData.rescueTeam ? 0 : 1;
                        break;
                }
                var pos = teamSpawns[index];
                if (pos)
                {
                    return [this.Random(pos.x, pos.x + pos.w), this.Random(pos.y, pos.y + pos.h)];
                }
                else
                {
                    console.warn("Missing team", index, "for teamSpawn");
                }
            }
            else
            {
                console.warn("Invalid teamSpawns");
            }
        }
        return this.getBestSpawnPosition(_team);
    }

    getBot(_botSkill = 1)
    {
        var arr = [
            "Easy",
            "Normal",
            "Hard",
            "Insane",
            "God"
        ];
        if (_botSkill == null || isNaN(_botSkill))
        {
            _botSkill = 1;
        }
        var botSkill = Math.max(0, _botSkill);        
        var bot = {
            id: this.getRandomUniqueId(),
            name: this.getRandomBotName() + " (" + arr[botSkill] + ")",
            bBot: true,
            botSkill: botSkill,
            level: this.Random(1, 100)
        };
        return bot;
    }

    addPlayer(_data)
    {
        var ps = this.clone(_data);
        if (this.getPlayerById(ps.id))
        {
            return;
        }
        if (!ps.id)
        {
            console.warn("Missing player id", _data);
        }
        if (ps.team == null || ps.team < 0)
        {
            ps.team = 0;
        }
        ps.bCanRespawn = true;
        ps.desiredSpawn = this.getSpawnPointForTeam(ps.team);
        ps.bAutoRespawn = true;
        if (this.playerCanRespawn(ps) || this.game.gameModeId == GameMode.EXTRACTION || this.game.bOpenWorld)
        {
            ps.respawnTimer = this.matchInProgress() ? (this.game.gameModeData.respawnTime + 1) : -1;
        }
        else
        {
            ps.respawnTimer = -1;
        }
        ps.bCanRespawn = !this.matchInProgress();
        ps.itemIndex = 0;
        ps.kills = 0;
        ps.headshots = 0;
        ps.assists = 0;
        ps.deaths = 0;
        ps.melees = 0;
        ps.money = Math.min(this.settings.maxPlayerMoney, this.game.gameSettings.money ? this.game.gameSettings.money : 0);
        ps.items = [];
        ps.killedBy = [];
        switch (this.game.gameModeId)
        {
            case GameMode.DOMINATION:
            case GameMode.CONQUEST:
                ps.captures = 0;
                break;
            case GameMode.CAPTURE_THE_FLAG:
                ps.captures = 0;
                ps.returns = 0;
                break;
            case GameMode.DESTRUCTION:
                ps.plants = 0;
                ps.defuses = 0;
                break;
            case GameMode.DINO_RESCUE:
            case GameMode.EXTRACTION:
                ps.score = 0;
                break;
            case GameMode.SURVIVAL_CHAOS:
            case GameMode.SURVIVAL_DINO:
            case GameMode.SURVIVAL_MILITIA:
            case GameMode.SURVIVAL_ZOMBIE:
            case GameMode.SURVIVAL_CHICKEN:
                ps.money = 0;
                ps.currentFaction = null;
                break;
        }
        var mode = this.getGameModeData(this.game.gameModeId);
        if (!ps.currentClass)
        {
            ps.currentClass = Classes.ASSAULT;
        }
        if (!ps.currentDino)
        {
            ps.currentDino = ps.bBot ? this.getRandomDinosaur() : Dinosaur.COMPY;
        }
        if (ps.bBot)
        {           
            if (!ps.classes)
            {
                ps.classes = this.getBotClasses();
            }
            var classes = [Classes.ASSAULT, Classes.COMMANDO, Classes.SUPPORT, Classes.HUNTER];
            ps.currentClass = classes[this.Random(0, classes.length - 1)];
            if (!ps.dinosaurs)
            {
                ps.dinosaurs = {};
            }            
        }
        switch (this.game.gameModeId)
        {
            case GameMode.TYRANT:
                ps.currentDino = Dinosaur.TREX;
                break;
            case GameMode.RAPTOR_HUNT:
                ps.currentDino = this.game.gameSettings.dinoType ? this.game.gameSettings.dinoType : Dinosaur.RAPTOR;
                break;
            case GameMode.EVOLUTION:
                ps.currentDino = this.game.gameModeData.dino;
                break;
        }
        this.setCurrentClass(ps, ps.currentClass);
        if (ps.bBot)
        {
            ps.dinosaurs[ps.currentDino] = {
                colour: this.getRandomDinosaurColour()
            }
            switch (this.game.gameModeData.botFaction)
            {
                case "humans":
                    ps.currentFaction = "human";
                    break;
                case "dinosaurs":
                    ps.currentFaction = ObjectType.DINOSAUR;
                    break;
                default:
                    switch (this.game.gameModeData.allowFactions)
                    {
                        case "humans":
                            ps.currentFaction = "human";
                            break;
                        case "dinosaurs":
                            ps.currentFaction = ObjectType.DINOSAUR;
                            break;
                        case "humans_dinosaurs":
                            this.game.gameModeData.factions = [Faction.DINOGEN, Faction.DINOSAURS];
                            if (this.isTeamGameMode())
                            {
                                ps.currentFaction = ps.team == 1 ? ObjectType.DINOSAUR : "human";
                            }
                            else
                            {
                                ps.currentFaction = this.RandomBoolean() ? ObjectType.DINOSAUR : "human";
                            }
                            break;
                        default:
                            ps.currentFaction = this.Random(1, 3) == 1 ? ObjectType.DINOSAUR : "human";
                            break;
                    }
                    break;
            }
        }
        else
        {
            switch (this.game.gameModeData.allowFactions)
            {
                case "humans":
                    ps.currentFaction = "human";
                    break;
                case "dinosaurs":
                    ps.currentFaction = ObjectType.DINOSAUR;
                    break;
                case "humans_dinosaurs":
                    if (this.isTeamGameMode())
                    {
                        ps.currentFaction = ps.team == 1 ? ObjectType.DINOSAUR : "human";
                    }
                    else
                    {
                        ps.currentFaction = this.RandomBoolean() ? ObjectType.DINOSAUR : "human";
                    }
                    break;
            }
        }
        this.game.players.push(ps);
        this.requestEvent({
            eventId: GameServer.EVENT_PLAYER_JOIN,
            player: ps
        });        
        if (this.game.scenario)
        {
            this.dispatchTrigger({
                event: "playerJoined",
                playerId: ps.id,
                playerIndex: this.game.players.indexOf(ps),
                playerTeam: ps.team
            });
            if (this.playerCanRespawn(ps))
            {
                ps.bWaitingToRespawn = true;
                ps.respawnTimer = this.game.gameModeData.respawnTime;
                ps.timer_respawn = this.game.settings.fps;
                if (ps.bAutoRespawn && !this.matchInProgress())
                {
                    this.respawnPlayer(ps.id);
                }
            }
            else if (this.game.bSurvival && this.game.gameModeData.bIntermission)
            {
                this.respawnPlayer(ps.id);
            }
        }
        else if (this.game.bSurvival)
        {
            if (this.game.gameModeData.bIntermission)
            {
                this.respawnPlayer(ps.id);
            }
        }
        else if (ps.bAutoRespawn && !this.matchInProgress())
        {
            this.respawnPlayer(ps.id);
        }
        else
        {
            ps.bWaitingToRespawn = true;
            ps.respawnTimer = this.game.gameModeData.respawnTime;
            ps.timer_respawn = this.game.settings.fps;
        }
    }

    removePlayer(_id)
    {
        var players = this.game.players;
        for (var i = 0; i < players.length; i++)
        {
            var player = players[i];
            if (player.id == _id)
            {
                var timer = player["timer_respawn"];
                if (timer)
                {
                    delete player["timer_respawn"];
                }
                timer = player["timer_spawnProtection"];
                if (timer)
                {
                    delete player["timer_spawnProtection"];
                }
                players.splice(i, 1);
                return true;
            }
        }
        return false;
    }

    isGeneratingNodes()
    {
        return this.game && this.game.nodesToCheck != null;
    }

    handleEmitter(_body)
    {
        var data = _body.data;
        if (data.attachToId && !this.getObjectById(data.attachToId))
        {
            if (data.destroyTimer == null)
            {
                data.destroyTimer = data.lifespan ? ((data.lifespan / 1000) * this.game.settings.fps) : 180;
                this.setDataValue(_body, "bDisabled", true);
            }
        }
    }

    handleTriggerArea(_body)
    {
        var data = _body.data;               
        if (this.isGeneratingNodes())
        {
            return;
        }
        if (this.matchInProgress() && data.onTouchTriggerId)
        {
            if (data.ticker > 0)
            {
                data.ticker--;
            }
            else
            {
                data.ticker = 1;
                var area = Math.max(data.areaWidth, data.areaHeight);
                var objects = this.getTypes([
                    ObjectType.CHARACTER,
                    ObjectType.DINOSAUR,
                    ObjectType.HELICOPTER,
                    ObjectType.TANK,
                    ObjectType.CAR
                ]);
                for (var i = 0; i < objects.length; i ++)
                {
                    let pawn = objects[i];
                    if (data.targetId)
                    {
                        if (data.targetId != pawn.data.id)
                        {
                            continue;
                        }
                    }
                    else if (data.targetTeam != null)
                    {
                        if (data.targetTeam != pawn.data.team)
                        {
                            continue;
                        }
                    }
                    if (data.targetType != null)
                    {
                        if (data.targetType != pawn.data.type)
                        {
                            continue;
                        }
                    }
                    if (!data.bBotsCanTrigger && (pawn.data.bBot || pawn.data.bAutomated))
                    {
                        continue;
                    }
                    var bOverlaps = this.DistBodies(_body, pawn) < area && _body.getAABB().overlaps(pawn.getAABB());
                    if (bOverlaps)
                    {
                        let trigger = this.getTriggerById(data.onTouchTriggerId);
                        if (trigger)
                        {
                            let bExecute = true;
                            if (trigger.conditions)
                            {
                                for (var i = 0; i < trigger.conditions.length; i++)
                                {
                                    let condition = trigger.conditions[i];
                                    let res = this.checkTriggerCondition(condition, trigger);
                                    if (!res)
                                    {
                                        bExecute = false;
                                        break;
                                    }
                                }
                            }
                            if (bExecute)
                            {
                                this.executeTriggerById(data.onTouchTriggerId, { objectId: pawn.data.id, team: pawn.data.team });
                                if (data.uses != null)
                                {
                                    data.uses--;
                                    if (data.uses <= 0)
                                    {
                                        this.removeNextStep(_body);
                                    }
                                }
                            }
                        }
                        break;
                    }
                }
            }
        }
    }

    getTriggerById(_id)
    {
        var triggers = this.game.triggers;
        if (triggers)
        {
            for (var i = 0; i < triggers.length; i++)
            {
                let trigger = triggers[i];
                if (trigger && trigger.id == _id)
                {
                    return trigger;
                }
            }
        }
        var scenario = this.game.scenario;
        if (scenario)
        {
            if (scenario.triggers)
            {
                for (var i = 0; i < scenario.triggers.length; i++)
                {
                    let trigger = scenario.triggers[i];
                    if (trigger && trigger.id == _id)
                    {
                        return trigger;
                    }
                }
            }
        }
        return null;
    }

    checkTriggerAndExecuteById(_id, _params)
    {
        var trigger = this.getTriggerById(_id);
        if (trigger)
        {
            let bExecute = true;
            if (trigger.conditions)
            {
                for (var i = 0; i < trigger.conditions.length; i++)
                {
                    let condition = trigger.conditions[i];
                    let res = this.checkTriggerCondition(condition, _params ? _params : trigger);
                    if (!res)
                    {
                        bExecute = false;
                        break;
                    }
                }
            }
            if (bExecute)
            {
                this.executeTriggerById(_id, _params);
                /*
                if (data.uses != null)
                {
                    data.uses--;
                    if (data.uses <= 0)
                    {
                        this.removeNextStep(_body);
                    }
                }
                */
            }
        } 
    }

    executeMacro(_data)
    {
        if (_data)
        {
            switch (_data.macroId)
            {

            }
        }
    }

    executeTriggerById(_id, _params = null)
    {
        try
        {
            var triggers = this.game.triggers;
            if (triggers)
            {
                for (var i = 0; i < triggers.length; i++)
                {
                    let trigger = triggers[i];
                    if (trigger && trigger.id == _id)
                    {
                        this.executeTriggerActions(trigger.actions, trigger, _params);
                        break;
                    }
                }
            }
            var scenario = this.game ? this.game.scenario : null;
            if (scenario)
            {
                if (scenario.triggers)
                {
                    for (var i = 0; i < scenario.triggers.length; i++)
                    {
                        let trigger = scenario.triggers[i];
                        if (trigger && trigger.id == _id)
                        {
                            this.executeTriggerActions(trigger.actions, trigger, _params);
                            break;
                        }
                    }
                }
            }
        }
        catch (e)
        {
            this.onGameError(e);
        }
    }

    dispatchTrigger(_data)
    {
        try
        {
            if (this.game)
            {
                if (this.game.scenario || this.game.triggers)
                {
                    this.handleTrigger(_data);
                }
            }
        }
        catch (e)
        {
            this.onGameError(e);
        }
    }

    handleTrigger(_trigger)
    {               
        if (_trigger.bDisabled)
        {
            return;
        }
        if (this.game.scenario || this.game.triggers)
        {
            var toExecute = [];
            var triggers = this.game.triggers ? this.game.triggers : this.game.scenario.triggers;
            if (triggers)
            {
                for (var i = 0; i < triggers.length; i++)
                {
                    let scenarioTrigger = triggers[i];                    
                    if (scenarioTrigger.event == _trigger.event)
                    {
                        scenarioTrigger = this.clone(scenarioTrigger); //Clone to prevent special value caching                        
                        this.checkSpecialStringsInObject(scenarioTrigger);
                        let bExecute = true;
                        switch (scenarioTrigger.event)
                        {
                            case "gameTimer":
                                if (scenarioTrigger.value != null)
                                {
                                    bExecute = _trigger.value == scenarioTrigger.value;
                                }
                                else if (scenarioTrigger.threshold != null)
                                {
                                    var res = this.checkSpecialString(scenarioTrigger.threshold);
                                    bExecute = _trigger.value % parseFloat(scenarioTrigger.threshold) == 0;
                                }
                                break;
                            case "questObjectiveCompleted":
                                bExecute = _trigger.questId == scenarioTrigger.questId && _trigger.objectiveId == scenarioTrigger.objectiveId;
                                break;
                            case "variableChanged":
                                bExecute = _trigger.name === scenarioTrigger.name;
                                if (scenarioTrigger.value != null)
                                {
                                    bExecute = bExecute && this.game.gameModeData.vars[scenarioTrigger.name] === scenarioTrigger.value;
                                }
                                this.onEvent({
                                    eventId: GameServer.EVENT_GAME_UPDATE,
                                    data: {
                                        var: {
                                            name: scenarioTrigger.name,
                                            value: this.game.gameModeData.vars[scenarioTrigger.name]
                                        }
                                    }
                                });                                
                                break;
                            case "objectRemoved":
                                if (scenarioTrigger.objectIds)
                                {
                                    bExecute = scenarioTrigger.objectIds.indexOf(_trigger.objectId) >= 0;
                                }
                                else if (scenarioTrigger.objectId)
                                {
                                    bExecute = _trigger.objectId == scenarioTrigger.objectId;
                                }
                                break;
                            case "objectCreated":
                                if (scenarioTrigger.objectId)
                                {
                                    bExecute = _trigger.objectId == scenarioTrigger.objectId;
                                }
                                if (scenarioTrigger.team != null)
                                {
                                    bExecute = bExecute && _trigger.team == scenarioTrigger.team;
                                }
                                if (scenarioTrigger.type != null)
                                {
                                    bExecute = bExecute && _trigger.type == scenarioTrigger.type;
                                }
                                break;
                            case "objectKilled":
                                if (scenarioTrigger.objectIds)
                                {
                                    bExecute = scenarioTrigger.objectIds.indexOf(_trigger.objectId) >= 0;
                                }
                                else if (scenarioTrigger.objectId)
                                {
                                    bExecute = _trigger.objectId == scenarioTrigger.objectId;
                                }
                                if (scenarioTrigger.team != null)
                                {
                                    bExecute = bExecute && _trigger.team == scenarioTrigger.team;
                                }
                                if (scenarioTrigger.type != null)
                                {
                                    bExecute = bExecute && _trigger.type == scenarioTrigger.type;
                                }
                                break;
                            case "objectUsed":
                                if (scenarioTrigger.objectId != null)
                                {
                                    bExecute = bExecute && _trigger.objectId == scenarioTrigger.objectId;
                                }
                                if (scenarioTrigger.userId != null)
                                {
                                    bExecute = bExecute && _trigger.userId == scenarioTrigger.userId;
                                }
                                break;                            
                            case "doorOpened":
                            case "doorClosed":
                                if (scenarioTrigger.objectId != null)
                                {
                                    bExecute = bExecute && _trigger.objectId == scenarioTrigger.objectId;
                                }
                                if (scenarioTrigger.causerId != null)
                                {
                                    bExecute = bExecute && _trigger.causerId == scenarioTrigger.causerId;
                                }
                                break;
                            case "pawnInvestigate":
                                if (scenarioTrigger.pawnId != null)
                                {
                                    bExecute = bExecute && _trigger.pawnId == scenarioTrigger.pawnId;
                                }
                                if (scenarioTrigger.investigateType != null)
                                {
                                    bExecute = bExecute && _trigger.investigateType == scenarioTrigger.investigateType;
                                }
                                break;
                            case "cinematicStarted":
                            case "cinematicEnded":
                                if (scenarioTrigger.cinematicId != null)
                                {
                                    bExecute = bExecute && _trigger.cinematicId == scenarioTrigger.cinematicId;
                                }
                                break;
                            case "playerJoined":
                            case "playerRespawned":
                                if (scenarioTrigger.playerId)
                                {
                                    bExecute = bExecute && scenarioTrigger.playerId == _trigger.playerId;
                                }
                                if (scenarioTrigger.playerIndex != null)
                                {
                                    console.log(scenarioTrigger.playerIndex == _trigger.playerIndex);
                                    bExecute = bExecute && scenarioTrigger.playerIndex == _trigger.playerIndex;
                                }
                                if (scenarioTrigger.playerTeam != null)
                                {
                                    bExecute = bExecute && scenarioTrigger.playerTeam == _trigger.playerTeam;
                                }
                                break;
                            case "playerInput":
                                if (scenarioTrigger.playerId)
                                {
                                    bExecute = bExecute && scenarioTrigger.playerId == _trigger.playerId;
                                }
                                if (scenarioTrigger.keyId != null)
                                {
                                    bExecute = bExecute && scenarioTrigger.keyId == _trigger.keyId;
                                }
                                if (scenarioTrigger.bValue != null)
                                {
                                    bExecute = bExecute && scenarioTrigger.bValue == _trigger.bValue;
                                }
                                break;
                        }
                        if (bExecute)
                        {
                            if (scenarioTrigger.conditions)
                            {
                                for (var j = 0; j < scenarioTrigger.conditions.length; j++)
                                {
                                    let condition = scenarioTrigger.conditions[j];  
                                    let res = this.checkTriggerCondition(condition, _trigger);
                                    if (!res)
                                    {
                                        bExecute = false;
                                        break;
                                    }
                                }
                            }
                        }
                        if (bExecute)
                        {                            
                            if (scenarioTrigger.delay > 0)
                            {
                                for (var j = 0; j < scenarioTrigger.actions.length; j++)
                                {
                                    let action = scenarioTrigger.actions[j];
                                    this.addToActionQueue(action, action.delay, _trigger);
                                }
                            }
                            else
                            {
                                //this.executeTriggerActions(scenarioTrigger.actions, scenarioTrigger, _trigger); 
                                toExecute.push(scenarioTrigger);
                            }
                        }
                    }
                }
            }
            if (toExecute)
            {
                for (var i = 0; i < toExecute.length; i++)
                {
                    let trigger = toExecute[i];
                    this.executeTriggerActions(trigger.actions, trigger, _trigger); 
                }
            }
        }        
    }

    checkTriggerCondition(_condition, _params)
    {
        if (_condition)
        {
            _condition = this.clone(_condition);
            this.checkSpecialStringsInObject(_condition);
            this.checkParamsInObject(_condition, _params);
            switch (_condition.condition)
            {
                case "numDinosaurs":
                    if (_condition.team != null)
                    {
                        var val = this.getNumDinosaursOnTeam(_condition.team);
                    }
                    else
                    {
                        val = this.getDinosaurs().length;
                    }
                    break;
                case "numCharactersOnTeam":
                case "numCharacters":
                    if (_condition.team != null)
                    {
                        var val = this.getNumCharactersOnTeam(_condition.team);
                    }
                    else
                    {
                        val = this.getCharacters().length;
                    }
                    break;
                case "numPawnsOnTeam":
                case "numPawns":
                    if (_condition.team != null)
                    {
                        val = this.getNumPawnsOnTeam(_condition.team);
                    }
                    else
                    {
                        val = this.getPawns().length;
                    }
                    break;
                case "numPlayersAlive":
                    var numAlive = 0;
                    for (var i = 0; i < this.game.players.length; i++)
                    {
                        let ps = this.game.players[i];
                        if (this.getObjectById(ps.id))
                        {
                            if (_condition.team == null || ps.team == _condition.team)
                            {
                                numAlive++;
                            }
                        }
                    }
                    val = numAlive;
                    break;
                case "numHelicoptersOnTeam":
                case "numHelicopters":
                    val = this.getNumHelicoptersOnTeam(_condition.team, _condition.heliTypes);
                    break;
                case "variableValue":                    
                    val = this.getScenarioVarValue(_condition.variableName);
                    break;
                case "objectExists":
                    val = this.getObjectById(_condition.objectId) != null;
                    break;
                case "gameInProgress":
                    val = this.matchInProgress();
                    break;
                case "gameHasEnded":
                    val = this.matchHasEnded();
                    break;
                case "isMultiplayer":
                    val = this.game.bMultiplayer;
                    break;
                case "questIsComplete":
                    var quest = this.getQuestById(_condition.questId);
                    val = quest ? quest.bComplete == true : false;
                    break;
                case "questObjectiveIsComplete":
                    var objective = this.getQuestObjectiveById(_condition.questId, _condition.objectiveId);
                    val = objective ? objective.bComplete == true : false;
                    break;
                case "playerStateValue":
                    var ps = this.getPlayerById(_condition.playerId);
                    if (ps)
                    {
                        val = ps[_condition.key];
                    }
                    else
                    {
                        this.scenarioLog("[playerStateValue] Player doesn't exist with id " + _condition.playerId, Colours.RED_STRING);
                    }
                    break;
                case "objectDataValue":
                    var object = this.getObjectById(_condition.objectId);
                    if (object && object.data)
                    {
                        val = object.data[_condition.key];
                    }
                    else
                    {
                        this.scenarioLog("[objectDataValue] Object doesn't exist with id " + _condition.objectId, Colours.RED_STRING);
                    }
                    break;
                case "gameDataValue":
                    val = this.game.gameModeData[_condition.key];
                    break;
                default:
                    this.log("Unhandled condition: " + _condition.condition);
                    break;
            }
            if (val !== undefined)
            {
                switch (_condition.operator)
                {
                    case "==":
                        return val == _condition.value;
                    case "!=":
                        return val != _condition.value;
                    case "<":
                        return val < _condition.value;
                    case ">":
                        return val > _condition.value;
                    case "<=":
                        return val <= _condition.value;
                    case ">=":
                        return val >= _condition.value;
                    case "%":
                        return val % _condition.value == 0;
                }
            }
        }
        return false;
    }

    executeTriggerActions(_actions, _trigger, _params = null)
    {
        if (_trigger)
        {
            if (_trigger.repeats != null)
            {
                _trigger.repeats--;
                if (_trigger.repeats <= 0)
                {
                    if (this.game.triggers)
                    {
                        let index = this.game.triggers.indexOf(_trigger);
                        if (index >= 0)
                        {
                            this.game.triggers.splice(index, 1);
                            console.log("Remove trigger", _trigger.id);
                        }
                    }
                    else
                    {
                        let index = this.game.scenario.triggers.indexOf(_trigger);
                        if (index >= 0)
                        {
                            this.game.scenario.triggers.splice(index, 1);
                            console.log("Remove trigger", _trigger.id);
                        }
                    }
                }
            }
            this.scenarioLog("Trigger executed: " + _trigger.id, Colours.GREEN_STRING);
        }
        var actions = _actions;
        if (actions)
        {
            for (var i = 0; i < actions.length; i++)
            {
                var action = actions[i];
                if (action)
                {
                    this.executeTriggerAction(action, _params);
                }
            }
        }
    }

    addToActionQueue(_action, _delay = 1, _params = null)
    {
        var delayItem = {
            action: this.clone(_action),
            delayMax: _delay,
            delayTimer: Math.max(1, Math.round(_delay * this.game.settings.fps)),
            params: _params
        }
        this.game.actionQueue.push(delayItem);
    }

    checkSpecialStringsInObject(obj)
    {
        for (var k in obj)
        {
            if (typeof obj[k] == "object" && obj[k] !== null)
            {
               this.checkSpecialStringsInObject(obj[k]);
            }
            else
            {
                obj[k] = this.checkSpecialString(obj[k]);
            }
        }
    }

    checkParamsInObject(obj, _params)
    {
        for (var k in obj)
        {
            if (typeof obj[k] == "object" && obj[k] !== null)
            {
                this.checkParamsInObject(obj[k], _params);
            }
            else
            {
                obj[k] = this.checkParamString(obj[k], _params);
            }
        }
    }

    checkParamString(_str, _params)
    {
        let paramKeys = Object.keys(_params);
        for (var i = 0; i < paramKeys.length; i++)
        {
            let param = paramKeys[i];
            let str = "{" + param + "}";
            let paramVal = _params[param];
            if (_str == str)
            {
                //console.log(str, paramVal);
                return paramVal;
            }
            else if (typeof _str === "string")
            {
                let index = _str.indexOf(str);
                if (index >= 0)
                {
                    //console.log(_str, paramVal);
                    return _str.replace(str, paramVal);
                }
            }
        }
        return _str;
    }

    executeTriggerAction(_data, _params)
    {
        //console.log(_data, _params);
        if (_data.delay > 0)
        {
            this.addToActionQueue(_data, _data.delay, _params);
        }
        else
        {
            var callback = _data.callback;
            _data = this.clone(_data);            
            if (_params)
            {                
                var keys = Object.keys(_data);
                var tmp = {};                
                this.checkParamsInObject(_data, _params);
            }            
            this.checkSpecialStringsInObject(_data);
            let trigger;
            switch (_data.action)
            {
                case "callback":
                    if (callback)
                    {
                        callback();
                    }
                    else
                    {
                        console.warn("Invalid callback", callback);
                    }
                    break; 
                case "macro":
                    switch (_data.id)
                    {
                        case 0:
                            break;
                    }
                    break;
                case "disableTrigger":
                    trigger = this.getTriggerById(_data.triggerId);
                    if (trigger)
                    {
                        trigger.bDisabled = true;
                    }
                    break;
                case "enableTrigger":
                    trigger = this.getTriggerById(_data.triggerId);
                    if (trigger)
                    {
                        delete trigger.bDisabled;
                    }
                    break;
                case "log":
                    this.scenarioLog((_data.bWarning ? "[WARNING] " : "") + _data.message, _data.bWarning ? Colours.ORANGE_STRING : null);
                    break;
                case "chat":
                    this.triggerCallback("chat", {
                        messageText: String(_data.message),
                        playerText: _data.playerText,
                        playerId: _data.playerId,
                        fill: _data.fill,
                        date: Date.now()
                    });
                    break;
                case "message":
                    this.onEvent({
                        eventId: GameServer.EVENT_MESSAGE_ADD,
                        data: {
                            playerId: _data.playerId,
                            message: this.checkSpecialString(_data.message),
                            timerMax: _data.timerMax,
                            hqId: _data.hqId,
                            bInfofeed: _data.bInfofeed
                        }
                    });
                    break;
                case "setGodMode":
                    if (_data.objectId)
                    {
                        var object = this.getObjectById(_data.objectId);
                        if (object)
                        {
                            this.setDataValue(object, "bGodMode", _data.value == true);
                        }
                    }
                    else
                    {
                        var chars = this.getCharactersOnTeam(0);
                        for (var i = 0; i < chars.length; i++)
                        {
                            var char = chars[i];
                            if (char)
                            {
                                this.setDataValue(char, "bGodMode", _data.value == true);
                            }
                        }
                    }
                    break;
                case "setUnlimitedAmmo":
                    if (_data.objectId)
                    {
                        var object = this.getObjectById(_data.objectId);
                        if (object)
                        {
                            this.setDataValue(object, "bUnlimitedAmmo", _data.value == true);
                        }
                    }
                    else
                    {
                        var chars = this.getCharactersOnTeam(0);
                        for (var i = 0; i < chars.length; i++)
                        {
                            var char = chars[i];
                            if (char)
                            {
                                char.data.weapon.bUnlimitedAmmo = _data.value == true;
                            }
                        }
                    }
                    break;
                case "setDataValue":
                    var object = this.getObjectById(_data.objectId);
                    if (object)
                    {
                        this.setDataValue(object, _data.key, _data.value);
                    }
                    break;
                case "setDamageMultipliers":
                    var object = this.getObjectById(_data.objectId);
                    if (object)
                    {
                        //this.applyDamageMultipliers(object, _data.damageMultipliers);
                        this.setDataValue(object, "damageMultipliers", _data.damageMultipliers);
                    }
                    else
                    {
                        this.scenarioLog("[setDamageMultipliers] Object doesn't exist: " + _data.objectId, Colours.RED_STRING);
                    }
                    break;
                case "exitAllPawnsFromVehicle":
                    var veh = this.getObjectById(_data.objectId);
                    if (veh)
                    {
                        this.exitAllPawnsFromVehicle(veh);
                    }
                    else
                    {
                        this.scenarioLog("[exitAllPawnsFromVehicle] Object doesn't exist: " + _data.objectId, Colours.RED_STRING);
                    }
                    break;
                case "killAllPawnsInVehicle":
                    var veh = this.getObjectById(_data.objectId);
                    if (veh)
                    {
                        this.killAllPawnsInVehicle(veh);
                    }
                    else
                    {
                        this.scenarioLog("[exitAllPawnsFromVehicle] Object doesn't exist: " + _data.objectId, Colours.RED_STRING);
                    }
                    break;
                case "setGameValue":
                    if (_data.key)
                    {
                        var updateData = {};
                        updateData[_data.key] = _data.value;
                        this.game.gameModeData[_data.key] = _data.value;
                        this.onEvent({
                            eventId: GameServer.EVENT_GAME_UPDATE,
                            data: updateData
                        });
                    }
                    break;
                case "setPlayerStateValue":
                    if (_data.key)
                    {
                        var ps = this.getPlayerById(_data.playerId);
                        if (ps)
                        {
                            ps[_data.key] = _data.value;
                            let updateData = {};
                            updateData[_data.key] = ps[_data.key];
                            this.onEvent({
                                eventId: GameServer.EVENT_PLAYER_UPDATE,
                                playerId: ps.id,
                                data: updateData
                            });
                        }
                    }
                    break;
                case "setMass":
                    var object = this.getObjectById(_data.objectId);
                    if (object && _data.mass != null)
                    {
                        object.mass = _data.mass;
                        object.updateMassProperties();
                    }
                    break;
                case "setDisabled":
                    var object = this.getObjectById(_data.objectId);
                    if (object)
                    {
                        this.setDataValue(object, "bDisabled", _data.value == true);
                    }
                    break;
                case "addPlayerMoney":
                    if (_data.playerId)
                    {
                        var ps = this.getPlayerById(_data.playerId);
                    }
                    else
                    {
                        ps = this.game.players[_data.playerIndex];
                    }
                    if (ps)
                    {
                        this.addPlayerMoney(ps.id, _data.value);
                    }
                    break;
                case "setVehicleWeapon":
                    var vehicle = this.getObjectById(_data.objectId);
                    if (vehicle)
                    {
                        console.log(_data);
                        if (_data.inventoryItem)
                        {
                            var vehicleWeapon = this.getWeaponData(_data.inventoryItem.id, _data.inventoryItem);
                            if (vehicleWeapon && !vehicleWeapon.bEquipment)
                            {
                                this.setVehicleWeapon(vehicle, _data.seatIndex, _data.weaponIndex, vehicleWeapon);
                            }
                            else
                            {
                                this.log("Invalid vehicle weapon");
                            }
                        }
                        else
                        {
                            this.log("Invalid vehicle inventory item");
                        }
                    }
                    break;
                case "setAI":
                    var pawn = this.getObjectById(_data.objectId);
                    if (pawn)
                    {       
                        if (_data.bInteract != null)
                        {
                            this.setAIInteract(pawn, _data.bInteract);
                        }
                        if (_data.bInvestigate != null)
                        {
                            this.setAIInvestigate(pawn, _data.bInvestigate);
                        }
                        if (_data.investigatePosition)
                        {
                            this.setAIInvestigatePos(pawn, _data.investigatePosition);
                        }
                        if (_data.desiredItemId !== undefined)
                        {
                            this.setAIObjectiveItemId(pawn, _data.desiredItemId);
                        }
                        if (_data.bCamp !== undefined)
                        {
                            this.setAICamp(pawn, _data.bCamp);
                        }
                        if (_data.followTargetId !== undefined)
                        {
                            this.setAIFollowTargetId(pawn, _data.followTargetId);
                        }
                        if (_data.wanderArea !== undefined)
                        {
                            this.setAIWanderArea(pawn, _data.wanderArea);
                        }
                    }
                    break;
                case "emitAISound":
                    console.log(_data);
                    this.emitAISound(_data.targetPosition, _data.sourcePosition, _data.radius, _data.team);
                    break;
                case "setPlayerTeam":
                    if (_data.playerId)
                    {
                        var ps = this.getPlayerById(_data.playerId);
                    }
                    else
                    {
                        ps = this.game.players[_data.playerIndex];
                    }
                    if (ps)
                    {
                        ps.team = _data.value;
                        this.onEvent({
                            eventId: GameServer.EVENT_PLAYER_UPDATE,
                            playerId: ps.id,
                            data: {
                                team: ps.team,
                            }
                        });
                    }
                    var object = this.getObjectById(_data.playerId);
                    if (object)
                    {
                        this.setDataValue(object, "team", _data.value);
                    }
                    break;
                case "setVariable":
                    this.game.gameModeData.vars[_data.name] = _data.value;
                    this.dispatchTrigger({
                        event: "variableChanged",
                        name: _data.name,
                        value: this.game.gameModeData.vars[_data.name]
                    });
                    this.onScenarioVarChanged(_data.name, this.game.gameModeData.vars[_data.name]);
                    break;
                case "addVariable":
                case "addToVariable":
                    if (this.game.gameModeData.vars[_data.name] == null)
                    {
                        this.game.gameModeData.vars[_data.name] = 0;
                    }
                    this.game.gameModeData.vars[_data.name] = this.RoundDecimal(this.game.gameModeData.vars[_data.name] + _data.value);  
                    this.dispatchTrigger({
                        event: "variableChanged",
                        name: _data.name,
                        value: this.game.gameModeData.vars[_data.name]
                    });
                    this.onScenarioVarChanged(_data.name, this.game.gameModeData.vars[_data.name]);
                    break;
                case "executeFunction":
                    this.executeScenarioFunction(_data.id);
                    break;
                case "executeTrigger":
                    this.executeTriggerById(_data.triggerId);
                    break;
                case "executeMacro":
                    this.executeMacro(_data);
                    break;
                case "endGame":
                    this.requestEvent({
                        eventId: GameServer.EVENT_GAME_END,
                        condition: _data.endCondition ? _data.endCondition : MatchState.END_CONDITION_SCORE,
                        conditionText: _data.conditionText,
                        winningTeam: _data.winningTeam,
                        playerId: _data.playerId,
                        cameraTargetId: _data.cameraTargetId
                    });
                    break;
                case "applyDamage":
                    if (this.getObjectById(_data.objectId))
                    {
                        this.requestEvent({
                            eventId: GameServer.EVENT_PAWN_DAMAGE,
                            damageType: _data.damageType ? _data.damageType : DamageType.DAMAGE_WORLD,
                            damageAmount: _data.damage,
                            pawnId: _data.objectId,
                            attackerId: _data.attackerId,
                            causerId: _data.causerId,
                            weaponId: _data.weaponId
                        });
                    }
                    else
                    {
                        this.scenarioLog("[applyDamage] No object with id " + _data.objectId, Colours.RED_STRING);
                    }
                    break;                
                case "setCharacterAvatar":
                    var char = this.getObjectById(_data.objectId);
                    if (char && char.data.type == ObjectType.CHARACTER)
                    {
                        if (_data.avatarId)
                        {
                            var avatar = this.getAvatarDataById(_data.avatarId);
                            if (avatar)
                            {
                                this.setDataValue(char, "avatar", avatar);
                            }
                        }
                        else if (_data.avatar)
                        {
                            this.setDataValue(char, "avatar", _data.avatar);
                        }
                    }
                    else
                    {
                        this.scenarioLog("[setCharacterAvatar] No character with id " + _data.objectId, Colours.RED_STRING);
                    }
                    break;
                case "setCharacterInventoryIndex":
                    var char = this.getObjectById(_data.objectId);
                    if (char && char.data.type == ObjectType.CHARACTER)
                    {
                        this.changeCharacterInventoryIndex(char, _data.index);
                    }
                    else
                    {
                        this.scenarioLog("[setCharacterInventoryIndex] No character with id " + _data.objectId, Colours.RED_STRING);
                    }
                    break;
                case "setCharacterInventory":
                    if (_data.inventory)
                    {
                        var char = this.getObjectById(_data.objectId);
                        if (char && char.data.type == ObjectType.CHARACTER)
                        {
                            let inv = [];
                            for (var i = 0; i < _data.inventory.length; i++)
                            {
                                let invItem = _data.inventory[i];
                                let newItem = this.getWeaponData(invItem.id, invItem);
                                this.applyWeaponMods(newItem, invItem.mods);
                                inv.push(newItem);
                            }
                            this.setCharacterInventory(char, inv);
                        }
                    }
                    break;
                case "setCharacterInventoryItem":
                    var char = this.getObjectById(_data.objectId);
                    if (char && char.data.type == ObjectType.CHARACTER && _data.inventoryItem)
                    {
                        var newItem = this.getWeaponData(_data.inventoryItem.id, _data.inventoryItem);
                        this.applyWeaponMods(newItem, _data.inventoryItem.mods);
                        this.requestEvent({
                            eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                            pawnId: char.data.id,
                            index: _data.index,
                            item: newItem,
                            type: GameServer.INV_ITEM_REPLACE
                        });
                    }
                    break;
                case "createObject":
                    this.createObject(_data);
                    break;
                case "createProjectile":
                    this.createProjectile(_data.position, _data.angle != null ? _data.angle : this.ToRad(_data.rotation), _data.team, {
                        playerId: _data.playerId,
                        causerId: _data.id,
                        velocity: _data.velocity,
                        weaponId: _data.weaponId,
                        frameId: _data.frameId,
                        sourceId: _data.sourceId
                    });
                    break;
                case "createExplosion":
                    _data.eventId = GameServer.EVENT_SPAWN_EXPLOSION;
                    this.createExplosion(_data);
                    break;
                case "removeObject":
                    this.removeObjectById(_data.objectId);
                    break;
                case "setDestination":
                    var obj = this.getObjectById(_data.objectId);
                    if (obj)
                    {
                        if (this.isVehicle(obj))
                        {
                            obj.data.destination = _data.position;
                            obj.data.bDestinationReached = false;
                        }
                        else
                        {
                            this.setAIDestination(obj, _data.position, _data.onDestinationTriggerId);
                        }
                    }
                    else
                    {
                        this.scenarioLog("[setDestination] No object with id " + _data.objectId, Colours.RED_STRING);
                    }
                    break;
                case "setPosition":
                    var obj = this.getObjectById(_data.objectId);
                    if (obj)
                    {
                        obj.position = _data.position;
                        this.setObjectPosition(obj, _data.position);
                    }
                    else
                    {
                        this.scenarioLog("[setPosition] No object with id " + _data.objectId, Colours.RED_STRING);
                    }
                    break;
                case "setRotation":
                    var obj = this.getObjectById(_data.objectId);
                    if (obj)
                    {
                        obj.angle = typeof _data.rotation === "number" ? this.ToRad(_data.rotation) : 0;
                    }
                    else
                    {
                        this.scenarioLog("[setRotation] No object with id " + _data.objectId, Colours.RED_STRING);
                    }
                    break;
                case "setAngle":
                    var obj = this.getObjectById(_data.objectId);
                    if (obj)
                    {
                        obj.angle = typeof _data.angle === "number" ? _data.angle : 0;
                    }
                    else
                    {
                        this.scenarioLog("[setAngle] No object with id " + _data.objectId, Colours.RED_STRING);
                    }
                    break;
                case "rotate":
                    var obj = this.getObjectById(_data.objectId);
                    if (obj)
                    {
                        if (typeof _data.degrees === "number")
                        {
                            obj.angle += this.ToRad(_data.degrees);
                            obj.data.bSkipServerUpdate = false;
                            if (!obj.world)
                            {
                                this.addWorldBody(obj, true);
                            }
                        }
                        else
                        {
                            this.scenarioLog("[rotate] Invalid degrees " + _data.degrees, Colours.RED_STRING);
                        }
                    }
                    else
                    {
                        this.scenarioLog("[rotate] No object with id " + _data.objectId, Colours.RED_STRING);
                    }
                    break;
                case "move":
                    var obj = this.getObjectById(_data.objectId);
                    if (obj)
                    {
                        if (typeof _data.x === "number")
                        {
                            obj.position[0] += _data.x;
                        }
                        if (typeof _data.y === "number")
                        {
                            obj.position[0] += _data.y;
                        }
                        obj.data.bSkipServerUpdate = false;
                    }
                    else
                    {
                        this.scenarioLog("[move] No object with id " + _data.objectId, Colours.RED_STRING);
                    }
                    break;
                case "applyImpulse":
                    var obj = this.getObjectById(_data.objectId);
                    if (obj)
                    {
                        obj.applyImpulse([_data.x, _data.y], [0, 0]);
                        if (_data.angularVelocity != null)
                        {
                            obj.angularVelocity += _data.angularVelocity;
                        }
                    }
                    else
                    {
                        this.scenarioLog("[applyImpulse] No object with id " + _data.objectId, Colours.RED_STRING);
                    }
                    break;
                case "applyForce":
                    var obj = this.getObjectById(_data.objectId);
                    if (obj)
                    {
                        obj.applyForce([_data.x, _data.y], [0, 0]);
                        if (_data.angularVelocity != null)
                        {
                            obj.angularVelocity += _data.angularVelocity;
                        }
                    }
                    else
                    {
                        this.scenarioLog("[applyForce] No object with id " + _data.objectId, Colours.RED_STRING);
                    }
                    break;
                case "setIndicatorData":
                    var obj = this.getObjectById(_data.id);
                    if (obj)
                    {
                        this.setDataValue(obj, "indicatorData", _data.indicatorData);
                    }
                    else
                    {
                        this.scenarioLog("[setIndicatorData] No object with id " + _data.id, Colours.RED_STRING);
                    }
                    break;
                case "setDoorLocked":
                    var door = this.getObjectById(_data.doorId);
                    if (door)
                    {
                        var prev = door.data.bDisabled;
                        this.setDataValue(door, "bDisabled", _data.value == true);
                        if (prev != door.data.bDisabled || door.data.bDisabled)
                        {
                            this.addDirtyNodeObject(door);
                        }
                    }
                    break;
                case "setDoorClosed":
                    var door = this.getObjectById(_data.doorId);
                    if (door)
                    {
                        this.setDoorClosed(door, _data.value == true);
                    }
                    break;
                case "respawn":
                    var respawnData = _data.data ? _data.data : _data;
                    if (_data.playerId)
                    {
                        this.respawnPlayer(_data.playerId, respawnData);
                    }
                    else if (_data.playerIndex != null)
                    {
                        var ps = this.game.players[_data.playerIndex];
                        if (ps)
                        {
                            this.respawnPlayer(ps.id, respawnData);
                        }
                        else
                        {
                            this.scenarioLog("No player at index " + _data.playerIndex);
                        }
                    }
                    else
                    {
                        this.respawnAllPlayers(respawnData);
                    }
                    break;
                case "setCurrentClass":
                    if (_data.playerId)
                    {
                        var ps = this.getPlayerById(_data.playerId);
                        this.setCurrentClass(ps, _data.classId, _data);
                    }
                    else
                    {
                        var players = this.getPlayers();
                        for (var i = 0; i < players.length; i++)
                        {
                            var ps = players[i];
                            this.setCurrentClass(ps, _data.classId, _data);
                        }
                    }
                    break;
                case "setCurrentDinosaur":
                    if (_data.playerId)
                    {
                        var ps = this.getPlayerById(_data.playerId);
                        this.setCurrentDinosaur(ps, _data.dinoId);
                    }
                    else
                    {
                        var players = this.getPlayers();
                        for (var i = 0; i < players.length; i++)
                        {
                            var ps = players[i];
                            this.setCurrentDinosaur(ps, _data.dinoId);
                        }
                    }
                    break;
                case "addQuest":
                    var quest = this.clone(_data.quest);
                    if (!quest.objectives)
                    {
                        quest.objectives = [];
                    }
                    this.game.gameModeData.quests.push(quest);
                    this.onEvent({
                        eventId: GameServer.EVENT_GAME_UPDATE,
                        data: {
                            newQuest: quest
                        }
                    });
                    break;
                case "addQuestObjective":
                    quest = this.getQuestById(_data.questId);
                    if (quest)
                    {
                        var objective = this.getQuestObjectiveById(_data.questId, _data.objective.id);
                        if (objective)
                        {
                            console.warn("Objective already exists", _data.questId, _data.objective.id);
                        }
                        else
                        {
                            objective = this.clone(_data.objective);
                            if (!quest.objectives)
                            {
                                quest.objectives = [];
                            }
                            quest.objectives.push(objective);
                        }
                        this.onEvent({
                            eventId: GameServer.EVENT_GAME_UPDATE,
                            data: {
                                questId: _data.questId,
                                objective: objective
                            }
                        });
                    }
                    else
                    {
                        console.warn("Quest doesn't exist", _data.questId);
                    }
                    break;
                case "updateQuestObjective":
                    quest = this.getQuestById(_data.questId);
                    if (quest && _data.objective)
                    {
                        var objective = this.getQuestObjectiveById(_data.questId, _data.objective.id);
                        if (objective)
                        {
                            var keys = Object.keys(_data.objective);
                            for (var i = 0; i < keys.length; i++)
                            {
                                var key = keys[i];
                                objective[key] = _data.objective[key];
                                switch (key)
                                {
                                    case "bComplete":
                                        if (_data.objective[key] == true)
                                        {
                                            this.dispatchTrigger({
                                                event: "questObjectiveCompleted",
                                                questId: _data.questId,
                                                objectiveId: _data.objective.id
                                            });
                                        }
                                        break;
                                }
                            }
                            if (this.getNumQuestObjectivesComplete(_data.questId) >= this.getNumQuestObjectives(_data.questId))
                            {
                                this.dispatchTrigger({
                                    event: "questCompleted",
                                    questId: _data.questId
                                });
                            }
                            this.onEvent({
                                eventId: GameServer.EVENT_GAME_UPDATE,
                                data: {
                                    questId: _data.questId,
                                    objective: _data.objective
                                }
                            });
                        }
                        else
                        {
                            console.warn("Objective doesn't exist", _data.questId, _data.objective.id);
                        }
                    }
                    else
                    {
                        console.warn("Quest doesn't exist", _data.questId);
                    }
                    break;
                case "showTip":
                    this.onEvent({
                        eventId: GameServer.EVENT_GAME_UPDATE,
                        data: _data
                    });
                    break;
                case "hideTip":
                    this.onEvent({
                        eventId: GameServer.EVENT_GAME_UPDATE,
                        data: {
                            bHideTip: true
                        }
                    });
                    break;
                case "executeInteractable":
                    if (_data.objectId)
                    {
                        var interactable = this.getObjectById(_data.interactableId);
                        if (interactable)
                        {
                            this.executeInteractable(interactable, _data.objectId);
                        }
                    }
                    break;
                case "setCameraTarget":
                    this.onEvent({
                        eventId: GameServer.EVENT_GAME_UPDATE,
                        data: {
                            cameraTargetId: _data.objectId,
                            playerId: _data.playerId
                        }
                    });
                    break;
                case "setCameraToPlayer":
                    this.onEvent({
                        eventId: GameServer.EVENT_GAME_UPDATE,
                        data: {
                            setCameraToPlayer: 1
                        }
                    });
                    break;
                case "setCinematicMode":
                    this.onEvent({
                        eventId: GameServer.EVENT_GAME_UPDATE,
                        data: {
                            bCinematicMode: _data.value == true
                        }
                    });
                    break;
                case "startCinematic":
                    this.startCinematic(_data.cinematic);
                    break;
                case "fadeCameraIn":
                    this.onEvent({
                        eventId: GameServer.EVENT_GAME_UPDATE,
                        data: {
                            fadeCameraIn: 1
                        }
                    });
                    break;
                case "fadeCameraOut":
                    this.onEvent({
                        eventId: GameServer.EVENT_GAME_UPDATE,
                        data: {
                            fadeCameraOut: 1
                        }
                    });
                    break;
                case "setMusic":
                    this.onEvent({
                        eventId: GameServer.EVENT_GAME_UPDATE,
                        data: {
                            music: _data.music,
                            bFadeIn: _data.bFadeIn
                        }
                    });
                    break;
                case "setWorldType":
                    this.game.gameSettings.worldType = _data.worldType;
                    this.game.gameSettings.worldTypeAlpha = _data.alpha;
                    this.onEvent({
                        eventId: GameServer.EVENT_GAME_UPDATE,
                        data: {
                            worldType: _data.worldType,
                            alpha: _data.alpha
                        }
                    });
                    break;
                case "pulseHUD":
                    this.onEvent({
                        eventId: GameServer.EVENT_GAME_UPDATE,
                        data: {
                            pulseHUD: _data.elementId
                        }
                    });
                    break;
                case "setMatchTimer":
                    this.onEvent({
                        eventId: GameServer.EVENT_GAME_UPDATE,
                        data: {
                            matchTimer: _data.value
                        }
                    });
                    break;
                case "playWorldSound":
                    this.onEvent({
                        eventId: GameServer.EVENT_GAME_UPDATE,
                        data: {
                            worldSoundId: _data.soundId,
                            position: _data.position,
                            volumeMultiplier: _data.volumeMultiplier,
                            randomMax: _data.randomMax,
                        }
                    });
                    break;
                case "playUISound":
                    this.onEvent({
                        eventId: GameServer.EVENT_GAME_UPDATE,
                        data: {
                            uiSoundId: _data.soundId,
                            volumeMultiplier: _data.volumeMultiplier
                        }
                    });
                    break;
                case "shakeCamera":
                    this.onEvent({
                        eventId: GameServer.EVENT_GAME_UPDATE,
                        data: {
                            shake: _data.value
                        }
                    });
                    break;
                case "setHUDElement": 
                    var hudElement = this.game.gameModeData.hudElements[_data.id];
                    if (!hudElement)
                    {
                        this.game.gameModeData.hudElements[_data.id] = this.clone(_data);
                        hudElement = this.game.gameModeData.hudElements[_data.id];
                    }
                    else
                    {
                        hudElement.label = _data.label ? _data.label : hudElement.label;
                        hudElement.value = _data.value ? _data.value : hudElement.value;
                        hudElement.variableName = _data.variableName ? _data.variableName : hudElement.variableName;
                    }
                    if (hudElement.variableName)
                    {
                        hudElement.value = this.game.gameModeData.vars[hudElement.variableName];
                    }
                    this.onEvent({
                        eventId: GameServer.EVENT_GAME_UPDATE,
                        data: {
                            hudElement: hudElement
                        }
                    });
                    break;
                case "removeHUDElement":
                    delete this.game.gameModeData.hudElements[_data.id];
                    this.onEvent({
                        eventId: GameServer.EVENT_GAME_UPDATE,
                        data: {
                            removeHUDElementId: _data.id
                        }
                    });
                    break;
                case "setCameraScale":
                    this.onEvent({
                        eventId: GameServer.EVENT_GAME_UPDATE,
                        data: {
                            cameraScale: _data.value
                        }
                    });
                    break;
                case "addObjectiveArrow":
                    this.onEvent({
                        eventId: GameServer.EVENT_GAME_UPDATE,
                        data: {
                            objectiveArrowId: _data.objectId
                        }
                    });
                    break;
                case "removeObjectiveArrow":
                    this.onEvent({
                        eventId: GameServer.EVENT_GAME_UPDATE,
                        data: {
                            removeObjectiveArrowId: _data.objectId
                        }
                    });
                    break;
                case "setHUDPawn":
                    this.onEvent({
                        eventId: GameServer.EVENT_GAME_UPDATE,
                        data: {
                            hudPawnId: _data.objectId,
                            playerId: _data.playerId
                        }
                    });
                    break;
                case "removeHUDPawn":
                    this.onEvent({
                        eventId: GameServer.EVENT_GAME_UPDATE,
                        data: {
                            removeHUDPawnId: _data.objectId
                        }
                    });
                    break;
                case "openRespawnMenu":
                    this.onEvent({
                        eventId: GameServer.EVENT_GAME_UPDATE,
                        data: {
                            openRespawnMenu: 1
                        }
                    });
                    break;
                case "closeRespawnMenu":
                    this.onEvent({
                        eventId: GameServer.EVENT_GAME_UPDATE,
                        data: {
                            closeRespawnMenu: 1
                        }
                    });
                    break;
            }
            this.scenarioLog("Action: " + _data.action, Colours.XP_STRING);
            if (tmp)
            {
                let keys = Object.keys(tmp);
                for (var i = 0; i < keys.length; i++)
                {
                    let key = keys[i];
                    _data[key] = tmp[key];
                }
            }
        }
    }

    getScenarioVarValue(_name)
    {
        if (this.game.scenario)
        {
            if (this.game.gameModeData.vars)
            {
                return this.game.gameModeData.vars[_name];
            }
        }
        return null;
    }

    onScenarioVarChanged(_name, _val)
    {
        if (this.game.scenario)
        {
            this.scenarioLog(_name + " = " + _val);
            if (this.game.gameModeData.hudElements)
            {
                var keys = Object.keys(this.game.gameModeData.hudElements);
                for (var i = 0; i < keys.length; i++)
                {
                    var key = keys[i];
                    var element = this.game.gameModeData.hudElements[key];
                    if (element && element.variableName == _name)
                    {
                        element.value = _val;
                        this.onEvent({
                            eventId: GameServer.EVENT_GAME_UPDATE,
                            data: {
                                hudElement: element
                            }
                        });
                    }
                }
            }
        }
    }

    getQuestById(_id)
    {
        if (this.game.scenario)
        {
            var quests = this.game.gameModeData.quests;
            if (quests)
            {
                for (var i = 0; i < quests.length; i++)
                {
                    if (quests[i].id == _id)
                    {
                        return quests[i];
                    }
                }
            }
        }
        return null;
    }

    getQuestObjectiveById(_questId, _id)
    {
        var quest = this.getQuestById(_questId);
        if (quest)
        {
            if (quest.objectives)
            {
                for (var i = 0; i < quest.objectives.length; i++)
                {
                    if (quest.objectives[i].id == _id)
                    {
                        return quest.objectives[i];
                    }
                }
            }
        }
        return null;
    }

    getNumQuestObjectives(_questId)
    {
        var quest = this.getQuestById(_questId);
        if (quest)
        {
            return quest.objectives ? quest.objectives.length : 0;
        }
        return 0;
    }

    getNumQuestObjectivesComplete(_questId)
    {
        var quest = this.getQuestById(_questId);
        if (quest)
        {
            return quest.objectives ? quest.objectives.length : 0;
        }
        return 0;
    }

    executeScenarioFunction(_id)
    {
        var scenario = this.game.scenario;
        if (scenario && scenario.functions)
        {
            for (var i = 0; i < scenario.functions.length; i++)
            {
                var func = scenario.functions[i];
                if (func && func.id == _id)
                {
                    this.scenarioLog("Function executed: " + func.id, Colours.GREEN_STRING);
                    this.executeTriggerActions(func.actions);
                    break;
                }
            }
        }
    }

    setCurrentDinosaur(_playerData, _dinoId)
    {
        if (!this.game.scenario)
        {
            if (this.game.bSurvival || this.game.gameSettings.allowFactions == "humans")
            {
                return;
            }
        }
        var ps = _playerData;
        if (ps)
        {
            ps.currentFaction = ObjectType.DINOSAUR;
            ps.currentDino = _dinoId;
            this.onEvent({
                eventId: GameServer.EVENT_PLAYER_UPDATE,
                playerId: ps.id,
                data: {
                    currentFaction: ps.currentFaction,
                    currentDino: ps.currentDino
                }
            });
            var dino = this.getObjectById(ps.id);
            if (dino)
            {
                if (dino.data.dinoType != _dinoId)
                {
                    if (!this.matchInProgress() || this.game.scenario)
                    {
                        var dinoPos = dino.position;
                        this.removeObject(dino);
                        this.respawnPlayer(ps.id, { position: dinoPos });
                        if (ps.respawnData)
                        {
                            delete ps.respawnData.position;
                        }
                    }
                }
            }
        }
    }

    setCurrentClass(_playerData, _classId, _data)
    {
        var ps = _playerData;
        if (ps)
        {
            if (!_data)
            {
                _data = {};
            }
            ps.currentFaction = "human";
            if (_classId)
            {
                ps.currentClass = _classId;
            }
            this.onEvent({
                eventId: GameServer.EVENT_PLAYER_UPDATE,
                playerId: ps.id,
                data: {
                    currentFaction: ps.currentFaction,
                    currentClass: ps.currentClass
                }
            });
            var classData = ps.classes[ps.currentClass];
            ps.avatar = classData.avatar[ps.classes.preferredFaction ? ps.classes.preferredFaction : Faction.DINOGEN];
            if (this.game.gameModeData.factions)
            {
                if (this.isTeamGameMode() && this.game.gameModeData.factions[ps.team])
                {
                    ps.avatar = classData.avatar[this.game.gameModeData.factions[ps.team]];
                }
            }
            if (!ps.avatar && !ps.bBot && ps.currentFaction == "human")
            {
                console.log("Missing avatar");
            }
            var bAllowInventoryChange = !this.game.bSurvival;
            if (this.game.scenario)
            {
                bAllowInventoryChange = bAllowInventoryChange || this.game.gameSettings.bAllowClassSelection == true;
            }
            if (bAllowInventoryChange)
            {
                var char = this.getObjectById(ps.id);
                if (char)
                {
                    if (char.data.type == ObjectType.CHARACTER)
                    {
                        var primary = this.getWeaponData(classData.primary.id);
                        this.applyWeaponMods(primary, classData.primary.mods);
                        var secondary = this.getWeaponData(classData.secondary.id);
                        this.applyWeaponMods(secondary, classData.secondary.mods);                        
                        var inv = [
                            primary,
                            secondary,
                            this.getWeaponData(classData.melee),
                            this.getWeaponData(classData.equipment),
                            this.getWeaponData(classData.grenade)
                        ];
                        this.setCharacterInventory(char, inv);
                        this.setDataValue(char, "avatar", ps.avatar);
                    }
                    else
                    {
                        var charPos = char.position;
                        this.removeObject(char);
                        this.respawnPlayer(ps.id, {
                            position: charPos,
                            inventory: _data.inventory,
                            melee: _data.melee,
                            grenade: _data.grenade,
                            equipment: _data.equipment
                        });
                    }
                }
            }
        }
    }

    changeCharacterInventoryIndex(_body, _index)
    {
        if (_body)
        {
            this.requestEvent({
                eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                pawnId: _body.data.id,
                type: GameServer.INV_CURRENT_INVENTORY_INDEX,
                value: _index
            });
        }
    }

    setCharacterInventory(_body, _inventory)
    {
        if (_body && _inventory)
        {
            var data = _body.data;
            for (var i = 0; i < 5; i++)
            {
                if (!_inventory[i])
                {
                    _inventory[i] = null;
                }
            }
            if (_inventory[Character.INDEX_MELEE]) data.melee = _inventory[Character.INDEX_MELEE];
            if (_inventory[Character.INDEX_EQUIPMENT]) data.equipment = _inventory[Character.INDEX_EQUIPMENT];
            if (_inventory[Character.INDEX_GRENADE]) data.grenade = _inventory[Character.INDEX_GRENADE];
            for (var i = Character.INDEX_MELEE; i <= Character.INDEX_GRENADE; i++)
            {
                if (!_inventory[i])
                {
                    _inventory[i] = data.inventory[i];
                }
            }
            this.requestEvent({
                eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                pawnId: data.id,
                type: GameServer.INV_INVENTORY_REPLACE,
                inventory: _inventory
            });
            this.pushObjectDataUpdate(data.id, ["melee", "equipment", "grenade"]);
        }
    }

    onEvent(_data)
    {
        if (!this.batchData)
        {
            return;
        }
        if (this.lobbyId)
        {
            _data.lobbyId = this.lobbyId;
        }        
        this.batchData.push(_data);
        switch (_data.eventId)
        {
            case GameServer.EVENT_GAME_INIT:
                this.generateMapNodes();
                this.dispatchTrigger({ event: "gameInit" });
                this.checkPerformanceMode();
                break;
            case GameServer.EVENT_GAME_START:
                this.dispatchTrigger({ event: "gameStart" });
                break;
            case GameServer.EVENT_GAME_UPDATE:
                if (_data.data)
                {
                    let gameData = this.clone(_data.data);
                    gameData.event = "gameUpdated";
                    this.dispatchTrigger(gameData);
                }
                break;
            case GameServer.EVENT_SPAWN_OBJECT:
                var data = _data.data;
                var ps = this.getPlayerById(data.id);
                this.dispatchTrigger({
                    event: "objectCreated",
                    objectId: data.id,
                    type: data.type,
                    team: data.team,
                    playerId: ps ? ps.id : null,
                    playerIndex: ps ? this.game.players.indexOf(ps) : null
                });
                break;
            case GameServer.EVENT_OBJECT_UPDATE:
                if (_data.objects)
                {
                    var keys = Object.keys(_data.objects);
                    for (var i = keys.length - 1; i >= 0; i--)
                    {
                        let key = keys[i];
                        let obj = _data.objects[key];
                        if (!obj.length)
                        {
                            delete _data.objects[key];
                        }
                    }
                }
                break;
        }
    }

    requestEvent(_data)
    {
        if (_data)
        {
            var eventId = _data.eventId;
            switch (eventId)
            {
                case GameServer.EVENT_PLAYER_UPDATE:
                    if (_data.data)
                    {
                        var ps = this.getPlayerById(_data.playerId);
                        if (ps)
                        {
                            if (_data.data.itemIndex != null)
                            {
                                ps.itemIndex = Math.max(0, Math.min(ps.items.length - 1, _data.data.itemIndex));
                            }
                            if (_data.data.bChangeTeam)
                            {
                                if (this.isTeamGameMode())
                                {
                                    this.changeTeam(ps.id);
                                }
                            }
                            if (_data.data.preferredFaction)
                            {
                                ps.classes.preferredFaction = _data.data.preferredFaction;
                            }
                            if (_data.data.currentClass)
                            {
                                this.setCurrentClass(ps, _data.data.currentClass);
                            }
                            if (_data.data.currentDino)
                            {
                                this.setCurrentDinosaur(ps, _data.data.currentDino);
                            }
                            if (_data.data.clan !== undefined)
                            {
                                ps.clan = _data.data.clan;
                            }
                            if (_data.data.vehicles)
                            {
                                if (!ps.vehicles)
                                {
                                    ps.vehicles = _data.data.vehicles;
                                }
                                else
                                {
                                    var keys = Object.keys(_data.data.vehicles);
                                    for (var i = 0; i < keys.length; i++)
                                    {
                                        var key = keys[i];
                                        ps.vehicles[key] = _data.data.vehicles[key];
                                    }
                                }
                            }
                            if (_data.data.desiredSpawn != null)
                            {
                                ps.desiredSpawn = _data.data.desiredSpawn;
                            }
                            if (_data.data.bAutoRespawn != null)
                            {
                                ps.bAutoRespawn = _data.data.bAutoRespawn;
                                if (ps.bAutoRespawn && ps.bCanRespawn)
                                {
                                    this.respawnPlayer(ps.id);
                                }
                            }
                        }
                    }
                    break;

                case GameServer.EVENT_PLAYER_JOIN:
                    this.checkPerformanceMode();
                    break;

                case GameServer.EVENT_PLAYER_LEAVE:
                    if (!this.game)
                    {
                        break;
                    }
                    var pawn = this.getObjectById(_data.playerId);
                    if (pawn)
                    {
                        this.exitVehicle(pawn);
                        this.removeNextStep(pawn);
                        if (this.game.bSurvival || pawn.data.bDropAllWeapons)
                        {
                            this.dropAllCharacterWeapons(pawn);
                        }
                    }
                    var arr = this.getMountedWeapons(_data.playerId);
                    for (var i = 0; i < arr.length; i++)
                    {
                        this.exitAllPawnsFromVehicle(arr[i]);
                        this.removeNextStep(arr[i]);
                    }
                    arr = this.getVehicles(_data.playerId);
                    for (var i = 0; i < arr.length; i++)
                    {
                        this.removeNextStep(arr[i]);
                    }
                    this.removeEquipmentByPlayerId(_data.playerId);
                    this.removeNextStep(this.getReviverByPlayerId(_data.playerId));
                    var ps = this.getPlayerById(_data.playerId);
                    this.dispatchTrigger({
                        event: "playerLeft",
                        playerId: _data.playerId
                    });
                    this.removePlayer(_data.playerId);
                    if (this.game.bScenario)
                    {
                        if (this.getNumPawnsOnTeam(0, true) <= 0)
                        {
                            this.requestEvent({
                                eventId: GameServer.EVENT_GAME_END,
                                condition: MatchState.END_CONDITION_KIA,
                                result: MatchState.END_RESULT_LOSS
                            });
                        }
                    }
                    else if (this.game.bSurvival)
                    {
                        if (this.getNumPawnsOnTeam(0, true) <= 0)
                        {
                            this.requestEvent({
                                eventId: GameServer.EVENT_GAME_END,
                                condition: MatchState.END_CONDITION_KIA,
                                result: MatchState.END_RESULT_LOSS,
                                winningTeam: 1
                            });
                        }
                    }
                    else
                    {
                        switch (this.game.gameModeId)
                        {
                            case GameMode.TYRANT:
                            case GameMode.EVOLUTION:
                                if (this.getPlayersOnTeam(1) <= 0)
                                {
                                    this.requestEvent({
                                        eventId: GameServer.EVENT_GAME_END,
                                        condition: MatchState.END_CONDITION_FORFEIT,
                                        result: MatchState.END_RESULT_WIN,
                                        winningTeam: 0
                                    });
                                }
                                break;
                            case GameMode.EXTRACTION:
                                if (this.getPlayersOnTeam(0, true) <= 0)
                                {
                                    this.addScore(1, 1);
                                    this.requestEvent({
                                        eventId: GameServer.EVENT_GAME_END,
                                        condition: MatchState.END_CONDITION_FORFEIT,
                                        winningTeam: 1
                                    });
                                }
                                break;
                        }
                    }        
                    this.checkPerformanceMode();
                    break;

                case GameServer.EVENT_SPAWN_EXPLOSION:
                    if (_data.damage)
                    {
                        this.checkExplosion(_data);
                        //this.checkExplosion(Math.round(_data["x"]), Math.round(_data["y"]), _data.radius, _data.damage, _data.playerId, _data.causerId, _data.weaponId, _data["bLOS"], _data["directHitId"]);
                    }
                    this.emitAISound(_data.position, _data.position, _data.radius, _data.team);
                    break;

                case GameServer.EVENT_PLAYER_INTERACT:
                    if (this.matchInProgress())
                    {
                        var char = this.getObjectById(_data.playerId);
                        if (char && char.data.bCanInteract) 
                        {
                            var item = this.getObjectById(_data.itemId);
                            if (item)
                            {
                                if (char.data.bInteracting)
                                {
                                    this.stopCharacterInteract(char);
                                }
                                else
                                {
                                    this.startInteraction(char, item);
                                }
                            }
                            else
                            {
                                if (char.data.bInteracting)
                                {
                                    this.stopCharacterInteract(char);
                                }
                                else
                                {
                                    this.attemptInteract(_data.playerId);
                                }
                            }
                        }
                    }
                    break;

                case GameServer.PAWN_LOCK_ACQUIRED:
                    if (_data.bRocket)
                    {
                        var pawn = this.getObjectById(_data.pawnId);
                        if (pawn && pawn.data.bBot)
                        {
                            var veh = this.getObjectById(pawn.data.controllableId);
                            if (veh)
                            {
                                this.triggerCountermeasure(pawn);
                            }
                        }
                    }
                    break;

                case GameServer.EVENT_PAWN_ACTION:
                    switch (_data.type)
                    {
                        case GameServer.PAWN_REQUEST:
                            var pawn = this.getObjectById(_data.pawnId);
                            if (pawn)
                            {
                                this.setPawnRequest(pawn, _data.value == pawn.data.currentRequest ? 0 : _data.value);
                            }
                            break;
                        case GameServer.PAWN_INVESTIGATE:
                            this.dispatchTrigger({
                                event: "pawnInvestigate",
                                pawnId: _data.pawnId,
                                investigateType: _data.value
                            });
                            break;
                    }
                    if (_data.lockOnTargetId !== undefined)
                    {
                        var pawn = this.getObjectById(_data.pawnId);
                        if (pawn)
                        {
                            if (!pawn.data.lockOnTargetId && _data.lockOnTargetId)
                            {
                                this.requestEvent({
                                    eventId: GameServer.EVENT_PAWN_ACTION,
                                    pawnId: _data.lockOnTargetId,
                                    type: GameServer.PAWN_LOCK_ACQUIRED
                                });
                            }
                            pawn.data.lockOnTargetId = _data.lockOnTargetId;
                        }
                        _data.bServer = true;
                    }
                    break;

                case GameServer.EVENT_PAWN_DAMAGE:
                    if (!this.matchInProgress())
                    {
                        break;
                    }
                    var damageAmount = _data.damageAmount;
                    if (isNaN(damageAmount) || damageAmount == 0)
                    {
                        damageAmount = 0;
                        break;
                    }
                    var pawnToDamage = this.getObjectById(_data.pawnId);
                    if (!pawnToDamage || !pawnToDamage.data)
                    {
                        break;
                    }
                    var causer = this.getObjectById(_data.causerId);
                    var killer = this.getPlayerById(_data.attackerId);
                    var killerPawn = this.getObjectById(_data.attackerId);
                    var bHitmarker = true;
                    if (causer)
                    {
                        switch (pawnToDamage.data.type)
                        {
                            case ObjectType.WINDOW:
                                bHitmarker = false;
                                break;
                            case ObjectType.OBSTACLE:
                                bHitmarker = pawnToDamage.data.health != null;
                                if (killerPawn)
                                {
                                    var pawnAngle = this.Angle(causer.position[0], causer.position[1], pawnToDamage.position[0], pawnToDamage.position[1]);
                                    var force = damageAmount;
                                    pawnToDamage.applyImpulse([Math.cos(pawnAngle) * force, Math.sin(pawnAngle) * force]);
                                }
                                break;
                        }
                    }
                    if (pawnToDamage.data.bGodMode || pawnToDamage.data.bSpawnProtection)
                    {
                        bHitmarker = false;
                        break;
                    }
                    if (pawnToDamage.data.type == ObjectType.CHARACTER && killer && killer.id != pawnToDamage.data.id && killer.team == pawnToDamage.data.team)
                    {
                        damageAmount *= 0.25; //Friendly fire
                        //console.warn("Friendly fire", pawnToDamage.data.type);
                    }
                    if (this.game.bSurvival)
                    {
                        var seatData = this.getSeatData(pawnToDamage);
                        if (seatData)
                        {
                            if (seatData.damageMultiplier != null)
                            {
                                damageAmount = damageAmount * seatData.damageMultiplier;
                            }
                        }
                    }
                    if (_data.weaponId == Dinosaur.DILO)
                    {
                        if (this.characterHasEquipment(pawnToDamage, "dino_vest"))
                        {
                            damageAmount = damageAmount * 0.5;
                        }
                    }
                    else
                    {
                        if (_data.damageType == DamageType.DAMAGE_EXPLOSIVE && this.characterHasEquipment(pawnToDamage, "blast_vest"))
                        {
                            damageAmount = damageAmount * 0.5;
                        }
                    }
                    if (bHitmarker)
                    {
                        _data.bHitmarker = 1;
                    }
                    if (pawnToDamage.data.health > 0)
                    {
                        var damageMultipliers = pawnToDamage.data.damageMultipliers;
                        if (damageMultipliers)
                        {
                            if (damageMultipliers[_data.damageType] != null)
                            {
                                damageAmount *= damageMultipliers[_data.damageType];
                            }
                        }
                        damageAmount = Math.ceil(damageAmount);
                        pawnToDamage.data.health = Math.max(0, Math.round(pawnToDamage.data.health - damageAmount));
                        if (pawnToDamage.data.maxHealth)
                        {
                            pawnToDamage.data.health = Math.min(pawnToDamage.data.health, pawnToDamage.data.maxHealth);
                        }
                        this.pushObjectDataUpdate(pawnToDamage.data.id, ["health"]);
                        if (pawnToDamage.data.bRegenHealth)
                        {
                            pawnToDamage.data.regenTimer = pawnToDamage.data.regenTimerMax;
                        }
                        switch (pawnToDamage.data.type)
                        {
                            case ObjectType.CHARACTER:
                                if (pawnToDamage.data.bBot)
                                {
                                    let flinch = this.ToRad(damageAmount);
                                    pawnToDamage.data.desiredAimRotation = pawnToDamage.data.aimRotation += flinch; //Add flinch to bots
                                }
                                break;
                            case ObjectType.OBSTACLE:
                                if (pawnToDamage.data.obstacleId == "barrel_explosive" || pawnToDamage.data.obstacleId == "barrel_poison" || pawnToDamage.data.obstacleId == "barrel_oil")
                                {                                    
                                    pawnToDamage.data.playerId = _data.attackerId;
                                    pawnToDamage.data.detonationTimer = this.game.settings.fps * 3;
                                    this.setDataValue(pawnToDamage, "bTriggered", true);
                                }
                                break;
                        }
                        if (pawnToDamage.data.bJuggernaut)
                        {
                            _data.bJuggernaut = 1;
                        }
                        if (pawnToDamage.data.dinoType == Dinosaur.TREX)
                        {
                            _data.bRex = 1;
                        }
                        if (pawnToDamage.data.health <= 0)
                        {
                            _data.bKill = 1;
                            switch (pawnToDamage.data.type)
                            {
                                default:
                                    var bSuicide = killer == victim;
                                    if (killer && pawnToDamage.data.id == killer.id)
                                    {
                                        this.addEvolutionKill(null);
                                    }
                                    var bTeamKill = bTeamKill || !bSuicide && killer ? (killer.team == pawnToDamage.data.team) : false;
                                    if (pawnToDamage.data.type == ObjectType.CHARACTER || pawnToDamage.data.type == ObjectType.DINOSAUR)
                                    {
                                        if (this.game.bRanked || this.game.gameSettings.bUseKillfeed)
                                        {
                                            var victim = this.getPlayerById(_data.pawnId);                                            
                                            if (!killer)
                                            {
                                                if (killerPawn)
                                                {
                                                    var name = "Enemy";
                                                    switch (killerPawn.data.type)
                                                    {
                                                        case ObjectType.CHARACTER:
                                                            name = "Soldier";
                                                            break;
                                                        case ObjectType.DINOSAUR:
                                                        case ObjectType.FLYING_DINOSAUR:
                                                            name = "Dinosaur";
                                                            break;
                                                    }
                                                    killer = {
                                                        name: killerPawn.data.pawnName ? killerPawn.data.pawnName : name,
                                                        id: killerPawn.data.id,
                                                        team: killerPawn.data.team
                                                    }
                                                }
                                                else
                                                {
                                                    killer = victim;
                                                }
                                            }
                                            if (killer && victim)
                                            {
                                                bSuicide = killer == victim;
                                                this.onEvent({
                                                    eventId: GameServer.EVENT_KILLFEED_ADD,
                                                    type: FeedItem.TYPE_KILL,
                                                    killerId: killer.id,
                                                    killerName: killer.name,
                                                    //killerClan: killer.clan,
                                                    killerTeam: killer.team,
                                                    victimId: victim.id,
                                                    victimName: victim.name,
                                                    //victimClan: victim.clan,
                                                    victimTeam: victim.team,
                                                    weaponId: _data.useId ? _data.useId : _data.weaponId,
                                                    bHeadshot: _data.bHeadshot,
                                                    bDirectImpact: _data.bDirectImpact,
                                                    bSuicide: bSuicide
                                                });
                                            }
                                        }
                                    }
                                    var damageInfo = {
                                        x: Math.round(pawnToDamage.position[0]),
                                        y: Math.round(pawnToDamage.position[1]),
                                        type: pawnToDamage.data.type,
                                        damageType: _data.damageType,
                                        weaponId: _data.weaponId
                                    };
                                    if (pawnToDamage.data.reward)
                                    {
                                        damageInfo.reward = pawnToDamage.data.reward;
                                    }
                                    switch (pawnToDamage.data.type)
                                    {
                                        case ObjectType.EQUIPMENT:
                                            damageInfo.equipmentId = pawnToDamage.data.weaponData.id;
                                            break;
                                        case ObjectType.DINOSAUR:
                                            damageInfo.dinoType = pawnToDamage.data.dinoType;
                                            break;
                                    }
                                    if (causer)
                                    {
                                        damageInfo.causer = causer.data.type;
                                        damageInfo.bXP = !causer.data.bAutomated;                                        
                                    }
                                    if (killerPawn)
                                    {
                                        if (killerPawn.data.seatIndex > 0)
                                        {
                                            var veh = this.getObjectById(killerPawn.data.controllableId);
                                            if (veh && veh.data.type != ObjectType.MOUNTED_WEAPON)
                                            {
                                                damageInfo.bFromVehicle = 1;
                                            }
                                        }
                                    }
                                    if (pawnToDamage.data.controllableId)
                                    {
                                        var veh = this.getObjectById(pawnToDamage.data.controllableId);
                                        if (veh && veh.data.type != ObjectType.MOUNTED_WEAPON)
                                        {
                                            damageInfo.bInVehicle = 1;
                                        }
                                    }
                                    if (pawnToDamage.data.bJuggernaut)
                                    {
                                        damageInfo.bJuggernaut = 1;
                                    }
                                    if (this.game.bSurvival)
                                    {
                                        if (pawnToDamage.data.reward)
                                        {
                                            damageInfo.reward = pawnToDamage.data.reward;
                                        }
                                    }
                                    if (_data.bDirectlyCausedByPlayer)
                                    {
                                        damageInfo.bDirectlyCausedByPlayer = true;
                                    }
                                    if (_data.bTeamKill || bTeamKill)
                                    {
                                        damageInfo.bTeamKill = true;
                                    }
                                    if (_data.bMelee)
                                    {
                                        damageInfo.bMelee = true;
                                    }
                                    if (bSuicide)
                                    {
                                        damageInfo.bSuicide = true;
                                    }
                                    if (_data.bHeadshot)
                                    {
                                        damageInfo.bHeadshot = true;
                                    }
                                    if (_data.bLongshot)
                                    {
                                        damageInfo.bLongshot = true;
                                    }
                                    if (_data.bDirectImpact)
                                    {
                                        damageInfo.bDirectImpact = true;
                                    }
                                    var weapon = this.getWeaponData(_data.weaponId);
                                    if (weapon)
                                    {
                                        if (weapon.bDinosaur)
                                        {
                                            damageInfo.bDinosaur = true;
                                        }
                                    }
                                    if (pawnToDamage.data.type == ObjectType.CHARACTER || this.isDinosaur(pawnToDamage))
                                    {
                                        switch (this.game.gameModeId)
                                        {
                                            case GameMode.DOMINATION:
                                            case GameMode.CONQUEST:
                                            case GameMode.HEADQUARTERS:
                                            case GameMode.DEMOLITION:
                                            case GameMode.DESTRUCTION:
                                                if (this.isNearFriendlyObjective(pawnToDamage) || this.isNearEnemyObjective(causer))
                                                {
                                                    damageInfo.bOffensiveKill = true;
                                                }
                                                else if (this.isNearEnemyObjective(pawnToDamage) || this.isNearFriendlyObjective(causer))
                                                {
                                                    damageInfo.bDefensiveKill = true;
                                                }
                                                break;

                                            case GameMode.DEFENDER:
                                            case GameMode.CAPTURE_THE_FLAG:
                                                if (this.isHoldingFlag(pawnToDamage))
                                                {
                                                    damageInfo.bEnemyHoldingFlag = true;
                                                }
                                                break;

                                            case GameMode.ASSASSINATION:
                                                if (killer && killer.bVIP)
                                                {
                                                    damageInfo.bOffensiveKill = true;
                                                }
                                                break;
                                        }
                                    }
                                    _data.damageAmount = damageAmount;
                                    var causerId = _data.causerId;
                                    if (causer)
                                    {
                                        if (causer.data.type == ObjectType.DINOSAUR && causer.data.playerId)
                                        {
                                            causerId = causer.data.playerId;
                                        }
                                    }
                                    this.onPlayerKill(_data.attackerId, damageAmount, _data.pawnId, causerId, damageInfo);
                                    this.onObjectDeath(_data.pawnId, damageAmount, _data.attackerId, _data.causerId, damageInfo);
                                    break;
                            }
                        }
                        else
                        {
                            switch (pawnToDamage.data.type)
                            {
                                case ObjectType.CHARACTER:
                                case ObjectType.DINOSAUR:
                                case ObjectType.FLYING_DINOSAUR:
                                    if (this.isTeamGameMode())
                                    {
                                        if (!pawnToDamage.data.damagedBy)
                                        {
                                            pawnToDamage.data.damagedBy = [];
                                        }
                                        var damagedBy = pawnToDamage.data.damagedBy;
                                        if (damagedBy.indexOf(_data.attackerId) == -1)
                                        {
                                            damagedBy.push(_data.attackerId);
                                        }
                                    }
                                    if (pawnToDamage.data.bBot)
                                    {
                                        if (!pawnToDamage.ai.enemy)
                                        {
                                            this.emitAISound([pawnToDamage.position[0] + this.Random(-100, 100), pawnToDamage.position[1] + this.Random(-100, 100)], null, 200, null);
                                        }
                                    }
                                    break;
                            }
                            if (_data.weaponId == "tazer")
                            {
                                if (pawnToDamage.data.dinoType != Dinosaur.TREX)
                                {
                                    pawnToDamage.data.bStunned = true;
                                    pawnToDamage.data.stunTimer = Math.round((this.game.settings.fps * 3) / pawnToDamage.mass);
                                    this.onEvent({
                                        eventId: GameServer.EVENT_PAWN_ACTION,
                                        pawnId: pawnToDamage.data.id,
                                        type: GameServer.PAWN_STUN,
                                        weaponId: _data.weaponId,
                                        causerId: _data.attackerId,
                                        bValue: true
                                    });
                                }
                            }
                        }
                    }
                    break;

                case GameServer.EVENT_SPAWN_BULLET:
                    var weaponData = _data.weaponData ? _data.weaponData : this.getWeaponData(_data.weaponId);
                    var result = this.raycast(_data.startX, _data.startY, _data.endX, _data.endY, null, this.isMeleeWeapon(weaponData));
                    if (result)
                    {
                        var dist = this.Dist(_data.startX, _data.startY, _data.endX, _data.endY);
                        var impactEffects = [];
                        var penetration = 0;
                        var penetrationMax = weaponData ? weaponData.penetration : 1;
                        var impactType = Material.DEFAULT;
                        var bHit = false;
                        var hitIds = {};
                        var angle = this.Angle(_data.startX, _data.startY, _data.endX, _data.endY);
                        var shield = null;
                        for (var i = 0; i < result.length; i++)
                        {
                            bHit = false;
                            shield = null;
                            var cur = result[i];
                            if (cur)
                            {
                                var body = cur.body;
                                var data = body.data;
                                if (!data)
                                {
                                    continue;
                                }
                                if (!data.bInvisible)
                                {
                                    impactType = data.material ? data.material : Material.DEFAULT;
                                }
                                else 
                                {
                                    continue;
                                }
                                switch (data.type)
                                {
                                    case ObjectType.ROCKET:
                                        break;
                                    case ObjectType.GRENADE:
                                        if (data.weaponId == "c4")
                                        {
                                            this.detonate(body);
                                        }
                                        break;
                                    case ObjectType.EGG:
                                        penetration = penetrationMax;
                                        break;
                                    case ObjectType.CHARACTER:
                                    case ObjectType.DINOSAUR:
                                    case ObjectType.FLYING_DINOSAUR:
                                        var ps = this.getPlayerById(data.id);
                                        if (ps && ps.bSpawnProtection)
                                        {
                                            continue;
                                        }
                                        if (this.characterHasEquipment(body, "kevlar"))
                                        {
                                            //bHit = true;
                                        }
                                        if (data.team != _data.team)
                                        {
                                            if (body.mass >= 4)
                                            {
                                                penetration = penetrationMax;
                                            }
                                            if (data.material == Material.METAL)
                                            {
                                                penetration = penetrationMax;
                                            }
                                            bHit = true;
                                        }
                                        break;
                                    case ObjectType.GROUND:
                                        if (_data.bIgnoreObstacles)
                                        {
                                            continue;
                                        }
                                        else if (body.data.bIgnoreProjectiles)
                                        {
                                            continue;
                                        }
                                        penetration = penetrationMax;
                                        bHit = true;
                                        break;
                                    case ObjectType.DOOR:
                                        if (_data.bIgnoreObstacles)
                                        {
                                            continue;
                                        }
                                        if (data.bClosed)
                                        {
                                            if (data.material == Material.METAL)
                                            {
                                                penetration = penetrationMax;
                                            }
                                            bHit = true;
                                        }
                                        break;
                                    case ObjectType.SHIELD:
                                        if (body.data.bActive && body.data.playerId != _data.causerId)
                                        {
                                            var causer = this.getObjectById(_data.causerId);
                                            var causerTeam = causer ? causer.data.team : -1;
                                            //Don't block with shield if melee or survival enemy
                                            var bBlock = !_data.bMelee || this.game.bSurvival;
                                            if (bBlock && causerTeam == body.data.team)
                                            {
                                                if (this.game.bSurvival)
                                                {
                                                    bBlock = false;
                                                }
                                            }
                                            if (bBlock)
                                            {
                                                penetration = penetrationMax;
                                                bHit = true;
                                                shield = body; //Hit shield
                                                this.onEvent({
                                                    eventId: GameServer.EVENT_PAWN_ACTION,
                                                    pawnId: body.data.playerId,
                                                    type: GameServer.PAWN_HIT_SHIELD,
                                                    damage: _data.damageAmount
                                                });
                                            }
                                        }
                                        break;
                                    case ObjectType.OBSTACLE:
                                        if (_data.bIgnoreObstacles && !body.data.health)
                                        {
                                            continue;
                                        }
                                        else if (body.data.bIgnoreProjectiles)
                                        {
                                            continue;
                                        }
                                        else if (!_data.bMelee)
                                        {
                                            //Check if using obstacle as cover
                                            if (!body.data.bBlockLOS && body.data.obstacleId != "window")
                                            {
                                                var obsDist = body.data.obstacleId.indexOf("sandbags") >= 0 ? 80 : 40;
                                                var causer = this.getObjectById(_data.causerId);
                                                if (causer)
                                                {
                                                    if (causer.data.bBot)
                                                    {
                                                        obsDist = 80;
                                                    }
                                                }
                                                if (!body.data.bBlock && this.Dist(cur.point.x, cur.point.y, _data.startX, _data.startY) < obsDist)
                                                {
                                                    continue;
                                                }
                                            }
                                            if (body.data.material != Material.SANDBAG)
                                            {
                                                penetration = penetrationMax;
                                            }
                                            bHit = true;
                                        }
                                        break;
                                    case ObjectType.CAR:
                                    case ObjectType.TANK:
                                        if (!_data.bMelee)
                                        {
                                            //Check if using vehicle as cover
                                            if (this.Dist(cur.point.x, cur.point.y, _data.startX, _data.startY) < 50)
                                            {
                                                continue;
                                            }
                                        }
                                        if (!this.vehicleHasOccupant(body))
                                        {
                                            penetration = penetrationMax;
                                        }
                                        break;
                                    case ObjectType.HELICOPTER:
                                        penetration = penetrationMax;
                                        break;                                    
                                }
                                if (!hitIds[data.id])
                                {
                                    if (data.health)
                                    {
                                        var bCollide = data.team != _data.team;
                                        switch (data.type)
                                        {
                                            case ObjectType.EQUIPMENT:
                                                if (_data.controllerId == data.ownerId && this.game.bFriendlyFire)
                                                {
                                                    bCollide = true;
                                                }
                                                if (bCollide && data.weaponData.bMine)
                                                {
                                                    data.ownerId = _data.controllerId;
                                                    this.detonate(body);
                                                }
                                                break;
                                            case ObjectType.HELICOPTER:
                                            case ObjectType.TANK:
                                            case ObjectType.CAR:
                                                bCollide = bCollide || !this.vehicleHasOccupant(body); //bCollide && (this.vehicleHasOccupant(body) || this.game.bSurvival);
                                                break;
                                        }
                                        if (bCollide)
                                        {
                                            hitIds[data.id] = true;
                                            var damageAmount = _data.damageAmount;
                                            if (penetration > 0)
                                            {
                                                var mult = (1 - (penetration / penetrationMax)) * (impactType == Material.METAL ? 0.25 : 0.75);
                                                if (penetration != penetrationMax)
                                                {
                                                    damageAmount = Math.ceil(damageAmount * mult);
                                                }
                                            }
                                            var bMelee = _data.bMelee;
                                            var bHeadshot = cur.bHeadshot;
                                            var bLongshot = !bMelee && cur.distance > dist * 0.5;
                                            var bNearshot = !bMelee && cur.distance < 250;
                                            var damageType = DamageType.DAMAGE_BULLET;
                                            if (weaponData)
                                            {
                                                if (weaponData.bDinosaur)
                                                {
                                                    damageType = DamageType.DAMAGE_MELEE;
                                                }
                                                if (this.isMeleeWeapon(weaponData))
                                                {
                                                    bHeadshot = false;
                                                    damageType = DamageType.DAMAGE_MELEE;
                                                }
                                            }
                                            if (bHeadshot)
                                            {
                                                damageAmount *= weaponData.headshotMult ? weaponData.headshotMult : 1.4;
                                            }
                                            if (!bMelee)
                                            {
                                                if (this.characterHasEquipment(body, "kevlar") && damageType == DamageType.DAMAGE_BULLET)
                                                {
                                                    var bKevlar = true;
                                                    damageAmount = damageAmount * 0.75;
                                                }
                                            }

                                            if (weaponData)
                                            {
                                                if (this.characterHasEquipment(body, "dino_vest") && weaponData.bDinosaur)
                                                {
                                                    var bDinoVest = true;
                                                    damageAmount = damageAmount * 0.5;
                                                }
                                                if (bNearshot)
                                                {
                                                    if (weaponData.type == Weapon.TYPE_SHOTGUN)
                                                    {
                                                        damageAmount *= 1.5;
                                                        if (this.isDinosaur(body))
                                                        {
                                                            damageAmount *= 1.25;
                                                        }
                                                    }
                                                }
                                                else
                                                {
                                                    if (cur.distance > weaponData.dropRange)
                                                    {
                                                        //console.log("Beyond effective range", weaponData.id, cur.distance + "/" + weaponData.dropRange, weaponData.range);
                                                        damageAmount *= 0.5;
                                                    }
                                                }
                                                if (this.hasMod(weaponData, Mods.AMMO_HOLLOW_POINT))
                                                {
                                                    this.onStoppingPowerHit(body, damageAmount);
                                                }
                                            }
                                            if (weaponData)
                                            {
                                                if (this.isVehicle(body) && weaponData.bDinosaur)
                                                {
                                                    if (weaponData.penetration >= 4)
                                                    {
                                                        var penetrationMult = 1 + (weaponData.penetration * 0.2);
                                                        damageAmount *= penetrationMult;
                                                    }
                                                }
                                                if (this.isVehicle(body))
                                                {
                                                    switch (weaponData.round)
                                                    {
                                                        case "408":
                                                        case "50bmg":
                                                            damageAmount *= 2;
                                                            break;
                                                    }
                                                }
                                                if (this.isVehicle(body) || this.isDinosaur(body) || body.data.bJuggernaut)
                                                {
                                                    if (weaponData.penetration >= 5)
                                                    {
                                                        penetrationMult = 1 + (weaponData.penetration * 0.2);
                                                        damageAmount *= penetrationMult;
                                                    }
                                                }
                                            }
                                            if (this.isDinosaur(body))
                                            {
                                                if (weaponData.round == "arrow")
                                                {
                                                    damageAmount *= this.game.bSurvival ? 5 : 2;
                                                }
                                            }
                                            var eventData = {
                                                eventId: GameServer.EVENT_PAWN_DAMAGE,
                                                damageType: damageType,
                                                damageAmount: damageAmount,
                                                pawnId: body.data.id,
                                                attackerId: _data.controllerId,
                                                causerId: _data.causerId,
                                                weaponId: _data.weaponId,
                                                useId: _data.useId
                                            };
                                            if (bLongshot)
                                            {
                                                eventData.bLongshot = 1;
                                            }
                                            if (bNearshot)
                                            {
                                                eventData.bNearshot = 1;
                                            }
                                            if (bMelee)
                                            {
                                                eventData.bMelee = 1;
                                            }
                                            if (_data.bDirectlyCausedByPlayer)
                                            {
                                                eventData.bDirectlyCausedByPlayer = 1;
                                            }
                                            if (shield)
                                            {
                                                eventData.bShield = 1;
                                            }
                                            if (bKevlar)
                                            {
                                                eventData.bKevlar = 1;
                                            }
                                            if (bDinoVest)
                                            {
                                                eventData.bDinoVest = 1;
                                            }
                                            this.requestEvent(eventData);
                                            bHit = true;
                                        }
                                    }
                                    if (bHit)
                                    {                                       
                                        if (weaponData.bExplosive)
                                        {
                                            this.createExplosion({
                                                eventId: GameServer.EVENT_SPAWN_EXPLOSION,
                                                position: [Math.round(cur.point.x), Math.round(cur.point.y)],
                                                radius: weaponData.radius ? weaponData.radius : 100,
                                                damage: damageAmount ? damageAmount : _data.damageAmount,
                                                playerId: _data.controllerId,
                                                causerId: _data.causerId,
                                                weaponId: weaponData.id,
                                                bExplosive: weaponData.bExplosive
                                            });
                                        }
                                        else if (weaponData.bPoison)
                                        {
                                            var numFlames = 5;
                                            for (var i = 0; i < numFlames; i++)
                                            {
                                                this.createFlame([cur.point.x, cur.point.y], [this.Random(-200, 200), this.Random(-200, 200)], _data.team, _data.controllerId, weaponData, weaponData.fireTime, true);
                                            }
                                        }
                                        else
                                        {
                                            impactEffects.push({
                                                x: Math.round(cur.point.x + this.Random(-10, 10)),
                                                y: Math.round(cur.point.y + this.Random(-10, 10)),
                                                rotation: angle + this.ToRad(180),
                                                impactType: impactType,
                                                damageAmount: damageAmount ? damageAmount : _data.damageAmount,
                                                intensity: (bNearshot ? (weaponData.type == Weapon.TYPE_SHOTGUN ? 1.75 : 1.25) : 1) + (damageAmount >= 200 ? 0.5 : 0),
                                                objectId: data.id
                                            });
                                        }
                                        penetration++;
                                        if (penetration >= penetrationMax)
                                        {
                                            _data.endX = cur.point.x;
                                            _data.endY = cur.point.y;
                                            if (weaponData.round == "arrow" && !weaponData.bExplosive && !weaponData.bPoison)
                                            {
                                                var arrow = this.createArrow([cur.point.x, cur.point.y], {
                                                    angle: angle
                                                });
                                                arrow.angularVelocity = this.Random(-5, 5);
                                            }
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    if (impactEffects)
                    {
                        this.createImpactEffects(impactEffects);
                    }
                    if (this.batchData.length >= this.settings.maxBatchItems)
                    {
                        _data.bServer = true;
                    }
                    break;

                case GameServer.EVENT_GAME_PAUSE:
                    this.game.bPaused = _data.bPaused;
                    break;

                case GameServer.EVENT_BUY:
                    var ps = this.getPlayerById(_data.pawnId);
                    if (ps)
                    {
                        var pawn = this.getObjectById(_data.pawnId);
                        if (pawn)
                        {
                            if (_data.bAmmo)
                            {
                                var curWeapon = pawn.data.inventory[_data.index];
                                if (curWeapon)
                                {
                                    if (curWeapon.bEquipment)
                                    {
                                        var moneyCost = this.getWeaponMoneyCost(curWeapon);
                                    }
                                    else
                                    {
                                        moneyCost = this.getSharedData("ammoCost")[curWeapon.round] * curWeapon.magSize;
                                    }
                                    if (ps.money >= moneyCost)
                                    {
                                        ps.money -= moneyCost;
                                        this.onEvent({
                                            eventId: GameServer.EVENT_PLAYER_UPDATE,
                                            playerId: pawn.data.id,
                                            data: {
                                                money: ps.money
                                            }
                                        });
                                        if (_data.index <= 1)
                                        {
                                            this.requestEvent({
                                                eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                                                pawnId: pawn.data.id,
                                                index: _data.index,
                                                type: GameServer.INV_AMMO_ADD,
                                                value: curWeapon.magSize,
                                                barrelAmmo: curWeapon.barrel ? curWeapon.barrel.magSize : 1
                                            });
                                        }
                                        else if (_data.index >= 3)
                                        {
                                            this.requestEvent({
                                                eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                                                pawnId: pawn.data.id,
                                                type: GameServer.INV_EQUIPMENT_ADD,
                                                slot: _data.index == 3 ? "equipment" : "grenade",
                                                value: 1
                                            });
                                        }
                                    }
                                }
                            }
                            else if (_data.itemId)
                            {
                                var item = this.getItemData(_data.itemId);
                                if (item)
                                {
                                    var moneyCost = item.cost;
                                    if (ps.money >= moneyCost)
                                    {
                                        ps.money -= moneyCost;
                                        if (ps.items)
                                        {
                                            ps.items.push({
                                                id: _data.itemId
                                            });
                                            ps.itemIndex = ps.items.length - 1;
                                        }
                                        this.onEvent({
                                            eventId: GameServer.EVENT_PLAYER_UPDATE,
                                            playerId: pawn.data.id,
                                            data: {
                                                items: ps.items,
                                                itemIndex: ps.itemIndex,
                                                itemId: _data.itemId,
                                                money: ps.money
                                            }
                                        });
                                    }
                                }
                            }
                            else if (_data.modId !== undefined)
                            {
                                var mod = this.getModData(_data.modId);
                                if (mod)
                                {
                                    var moneyCost = this.getModMoneyCost(mod);
                                    if (ps.money >= moneyCost)
                                    {
                                        ps.money -= moneyCost;
                                        this.onEvent({
                                            eventId: GameServer.EVENT_PLAYER_UPDATE,
                                            playerId: pawn.data.id,
                                            data: {
                                                money: ps.money
                                            }
                                        });
                                        var curWeapon = pawn.data.inventory[_data.index];
                                        if (curWeapon)
                                        {
                                            if (!curWeapon.mods)
                                            {
                                                curWeapon.mods = {};
                                            }
                                            curWeapon.mods[_data.modType] = _data.modId;
                                            this.applyWeaponMods(curWeapon, curWeapon.mods);
                                            this.requestEvent({
                                                eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                                                pawnId: pawn.data.id,
                                                inventory: pawn.data.inventory,
                                                type: GameServer.INV_INVENTORY
                                            });
                                        }
                                    }
                                }
                                else
                                {
                                    var curWeapon = pawn.data.inventory[_data.index];
                                    if (curWeapon)
                                    {
                                        if (!curWeapon.mods)
                                        {
                                            curWeapon.mods = {};
                                        }
                                        curWeapon.mods[_data.modType] = null;
                                        this.applyWeaponMods(curWeapon, curWeapon.mods);
                                        this.requestEvent({
                                            eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                                            pawnId: pawn.data.id,
                                            inventory: pawn.data.inventory,
                                            type: GameServer.INV_INVENTORY
                                        });
                                    }
                                }
                            }
                            else if (_data.weaponId)
                            {
                                var newItem = this.getWeaponData(_data.weaponId);
                                if (newItem)
                                {
                                    newItem.mods = {
                                        optic: null
                                    };
                                    var moneyCost = this.getWeaponMoneyCost(newItem);
                                    if (ps.money >= moneyCost)
                                    {
                                        ps.money -= moneyCost;
                                        this.onEvent({
                                            eventId: GameServer.EVENT_PLAYER_UPDATE,
                                            playerId: pawn.data.id,
                                            data: {
                                                money: ps.money
                                            }
                                        });
                                        if (_data.index <= 2)
                                        {
                                            this.requestEvent({
                                                eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                                                pawnId: pawn.data.id,
                                                index: _data.index,
                                                item: newItem,
                                                type: GameServer.INV_ITEM_REPLACE
                                            });
                                        }
                                        else
                                        {
                                            var slot = _data.index == 3 ? "equipment" : "grenade";
                                            this.requestEvent({
                                                eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                                                pawnId: pawn.data.id,
                                                slot: slot,
                                                value: newItem.id,
                                                type: GameServer.INV_EQUIPMENT_SET,
                                                sfxId: "wpn_ammo"
                                            });
                                        }
                                    }
                                }
                            }
                        }
                    }
                    break;  

                case GameServer.EVENT_ROUND:
                    if (_data.type == "end")
                    {
                        this.game.state = MatchState.STATE_POST_ROUND;
                    }
                    break;

                case GameServer.EVENT_GAME_END:
                    console.log(_data);
                    if (_data.condition == MatchState.END_CONDITION_FORFEIT)
                    {
                        _data.winningTeam = -1; //Draw
                    }
                    this.game.gameModeData.winner = _data.winningTeam;
                    this.endGame();
                    break;

                case GameServer.EVENT_PLAYER_TRIGGER_EQUIPMENT:
                    var char = this.getObjectById(_data.playerId);
                    if (char)
                    {
                        if (char.data.controllableId && char.data.seatIndex == 0)
                        {
                            this.triggerCountermeasure(char);
                        }
                        else
                        {
                            this.triggerCharacterEquipment(_data, "equipment");
                        }
                    }
                    _data.bServer = true;
                    break;

                case GameServer.EVENT_PLAYER_TRIGGER_GRENADE:
                    this.triggerCharacterEquipment(_data, "grenade");
                    _data.bServer = true;
                    break;

                case GameServer.EVENT_PLAYER_TRIGGER_WEAPON:
                    if (_data)
                    {
                        if (this.game.cinematic)
                        {      
                            if (_data.value)
                            {
                                if (!this.game.bMultiplayer)
                                {
                                    console.log("Skip cinematic", _data);
                                    this.loadNextCinematicAction();
                                }                            
                                break;
                            }
                        }
                        var pawn = this.getObjectById(_data.playerId);
                        if (pawn)
                        {
                            switch (pawn.data.type)
                            {
                                case ObjectType.CHARACTER:
                                case ObjectType.DINOSAUR:
                                case ObjectType.FLYING_DINOSAUR:
                                    this.triggerCharacterWeapon(_data);
                                    break;
                            }
                        }
                    }
                    break;

                case GameServer.EVENT_PLAYER_UPDATE_INVENTORY:
                    var pawn = this.getObjectById(_data.pawnId);
                    if (pawn)
                    {
                        var inventory = pawn.data.inventory;
                        if (_data["bRemoveEquipment"])
                        {
                            pawn.data.equipment = null;
                            _data.equipment = null;
                        }
                        if (typeof _data.type !== "number")
                        {
                            console.warn("Invalid type:", _data.type);
                        }
                        switch (_data.type)
                        {
                            case GameServer.INV_PERK_ADD:
                                var perks = pawn.data["perks"];
                                if (perks)
                                {
                                    if (perks.indexOf(_data["perkId"]) == -1)
                                    {
                                        perks.push(_data["perkId"]);
                                    }
                                }
                                this.updateCharacterPerks(pawn);
                                _data["perks"] = perks;
                                break;

                            case GameServer.INV_PERKS:
                                var perks = pawn.data["perks"];
                                this.updateCharacterPerks(pawn);
                                _data["perks"] = perks;
                                break;

                            case GameServer.INV_PERKS_SET:
                                pawn.data["perks"] = _data["perks"];
                                this.updateCharacterPerks(pawn);
                                break;

                            case GameServer.INV_FIRE:
                                var curItem = inventory[_data.index];
                                if (curItem.bBarrel)
                                {
                                    var barrel = curItem.barrel;
                                    if (barrel)
                                    {
                                        barrel.mag--;
                                        _data.mag = barrel.mag;
                                    }
                                    _data.bBarrel = curItem.bBarrel;
                                }
                                else
                                {
                                    if (!this.isMeleeWeapon(curItem) && !curItem.bDinosaur)
                                    {
                                        curItem.mag--;
                                        if (curItem["bBoltAction"])
                                        {
                                            curItem["bNeedsBoltPull"] = true;
                                        }
                                        _data.mag = curItem.mag;
                                    }
                                }
                                break;

                            case GameServer.INV_CLASS_DATA:
                                if (!this.game.gameModeData["bNoClasses"] && this.game["bModeGame"])
                                {
                                    var ps = this.getPlayerById(_data.pawnId);
                                    if (ps && ps.bVIP)
                                    {
                                        _data = {};
                                    }
                                    else
                                    {
                                        var primary = this.getWeaponData(_data["primary"].id);
                                        this.applyWeaponMods(primary, _data["primary"]["mods"], pawn ? pawn.data.id : null);
                                        var secondary = this.getWeaponData(_data["secondary"].id);
                                        this.applyWeaponMods(secondary, _data["secondary"]["mods"], pawn ? pawn.data.id : null);
                                        var newEquipment = this.getWeaponData(_data.equipment);
                                        pawn.data.inventory = [primary, secondary];
                                        pawn.data["equipment"] = newEquipment;
                                        delete pawn.data["bBandolier"];
                                        this.setCharacterCurrentInventoryItem(pawn, 0);
                                        _data.inventory = pawn.data.inventory;
                                        _data.equipment = pawn.data["equipment"];
                                        _data.currentInventoryIndex = 0;
                                        var perks = [
                                            _data["playerPerk"],
                                            _data["weaponPerk"]
                                        ];
                                        pawn.data.perks = perks;
                                        this.updateCharacterPerks(pawn);
                                        _data["perks"] = perks;
                                    }
                                }
                                else
                                {
                                    _data = {};
                                }
                                break;

                            case GameServer.INV_MOD_SET:
                                var weapon = pawn.data.inventory[_data.index];
                                if (weapon)
                                {
                                    var mods = weapon.mods ? weapon.mods : {};
                                    mods[_data["modType"]] = _data["modId"];
                                    this.applyWeaponMods(weapon, mods);
                                    _data.inventory = pawn.data.inventory;
                                }
                                break;

                            case GameServer.INV_UNDERBARREL_EQUIP:
                                var weapon = this.getCurrentCharacterInventoryItem(pawn, false);
                                if (weapon && weapon.barrel)
                                {
                                    weapon.bBarrel = _data.value;
                                    this.setCharacterCurrentInventoryItem(pawn, _data.index);
                                    _data.item = weapon;
                                    _data.mag = weapon.barrel.mag;
                                    _data.ammo = weapon.barrel.ammo;
                                }
                                break;

                            case GameServer.INV_EQUIPMENT_SET:
                                var equipmentData = this.getWeaponData(_data.value);
                                if (equipmentData)
                                {
                                    if (_data.ammo != undefined)
                                    {
                                        equipmentData.ammo = _data.ammo;
                                    }
                                    pawn.data[_data.slot] = equipmentData;
                                    switch (_data.slot)
                                    {
                                        case "equipment":
                                            pawn.data.inventory[Character.INDEX_EQUIPMENT] = equipmentData;
                                            break;
                                        case "grenade":
                                            pawn.data.inventory[Character.INDEX_GRENADE] = equipmentData;
                                            break;
                                    }
                                    _data[_data.slot] = pawn.data[_data.slot];
                                }
                                break;

                            case GameServer.INV_EQUIPMENT_ADD:
                                var equipment = pawn.data[_data.slot];
                                if (equipment && equipment.ammo != null)
                                {
                                    equipment.ammo += _data.value;
                                    equipment.ammo = Math.min(equipment.ammo, equipment.ammoMax);
                                }
                                _data[_data.slot] = equipment;
                                break;

                            case GameServer.INV_AMMO:
                                if (!inventory[_data.index].bPassive && inventory[_data.index].ammo != null)
                                {
                                    inventory[_data.index].ammo = _data.value;
                                    _data.item = inventory[_data.index];
                                }
                                break;

                            case GameServer.INV_AMMO_ADD:
                                if (!inventory[_data.index].bPassive && inventory[_data.index].ammo != null)
                                {
                                    inventory[_data.index].ammo += _data.value;
                                    inventory[_data.index].ammo = Math.min(inventory[_data.index].ammo, 999);
                                    if (_data.barrelAmmo > 0 && inventory[_data.index].barrel)
                                    {
                                        inventory[_data.index].barrel.ammo = Math.min(inventory[_data.index].barrel.ammo + (_data.barrelAmmo ? _data.barrelAmmo : 1), 99);
                                    }
                                    _data.item = inventory[_data.index];
                                }
                                break;

                            case GameServer.INV_MAG:
                                inventory[_data.index].mag = _data.value;
                                _data.item = inventory[_data.index];
                                break;

                            case GameServer.INV_MAG_ADD:
                                inventory[_data.index].mag += _data.value;
                                _data.item = inventory[_data.index];
                                break;

                            case GameServer.INV_BURSTS:
                                inventory[_data.index]["bursts"] = _data.value;
                                _data.item = inventory[_data.index];
                                break;

                            case GameServer.INV_BURSTS_ADD:
                                inventory[_data.index]["bursts"] += _data.value;
                                _data.item = inventory[_data.index];
                                break;

                            case GameServer.INV_ITEM:
                                if (_data.bBarrel)
                                {
                                    _data.item = inventory[_data.index].barrel;
                                }
                                else
                                {
                                    _data.item = inventory[_data.index];
                                }
                                break;

                            case GameServer.INV_ITEM_ADD:
                                if (inventory.length == 2)
                                {
                                    inventory.splice(0, 1);
                                }
                                inventory.push(_data.item);
                                this.setCharacterCurrentInventoryItem(pawn, 1);
                                _data.currentInventoryIndex = 1;
                                _data.inventory = inventory;
                                break;

                            case GameServer.INV_ITEM_REPLACE:
                                inventory[_data.index] = _data.item;
                                if (_data.index == pawn.data.currentInventoryIndex)
                                {
                                    this.setCharacterCurrentInventoryItem(pawn, _data.index);
                                }
                                switch (_data.index)
                                {
                                    case Character.INDEX_EQUIPMENT:
                                        pawn.data.equipment = _data.item;
                                        _data.equipment = _data.item;
                                        break;
                                    case Character.INDEX_GRENADE:
                                        pawn.data.grenade = _data.item;
                                        _data.grenade = _data.item;
                                        break;
                                }
                                _data.bReplace = 1;
                                _data.inventory = inventory;
                                break;

                            case GameServer.INV_INVENTORY_REPLACE:
                                pawn.data.inventory = _data.inventory;
                                this.setCharacterCurrentInventoryItem(pawn, 0);
                                _data.currentInventoryIndex = 0;
                                _data.inventory = _data.inventory;
                                break;

                            case GameServer.INV_CURRENT_INVENTORY_INDEX:
                                if (this.characterCanSwitchWeapons(pawn))
                                {
                                    if (pawn.data.inventory[_data.value])
                                    {
                                        this.setCharacterCurrentInventoryItem(pawn, _data.value);
                                        _data.currentInventoryIndex = _data.value;
                                        var curItem = pawn.data.inventory[_data.value];
                                        if (pawn.data.bReloading)
                                        {
                                            _data.bReload = true;
                                        }
                                    }
                                }
                                break;

                            case GameServer.INV_INVENTORY:
                                _data.inventory = inventory;
                                break;

                            case GameServer.INV_EQUIPMENT:
                                _data[_data.slot] = pawn.data[_data.slot];
                                break;
                        }
                        let invKeys = Object.keys(_data);
                        for (var i = 0; i < invKeys.length; i++)
                        {
                            let key = invKeys[i];
                            let val = _data[key];
                            if (typeof val === "boolean")
                            {
                                _data[key] = val == true ? 1 : 0;                                
                            }
                            else if (val == null)
                            {
                                delete _data[key];
                            }
                        }
                    }
                    break;

                case GameServer.EVENT_PLAYER_INPUT:
                    var keyInfo = _data.keyInfo;
                    if (keyInfo)
                    {
                        var ps = this.getPlayerById(_data.playerId);
                        var pawn = this.getObjectById(_data.playerId);
                        var keys = Object.keys(keyInfo);
                        for (var i = 0; i < keys.length; i++)
                        {
                            let curKey = keys[i];
                            let keyVal = keyInfo[curKey];
                            switch (curKey)
                            {
                                case Control.UP:
                                case Control.DOWN:
                                case Control.LEFT:
                                case Control.RIGHT:
                                    if (ps)
                                    {
                                        if (!ps.input)
                                        {
                                            ps.input = {};
                                        }
                                        ps.input[curKey] = keyVal;
                                    }
                                    else if (pawn)
                                    {
                                        if (!pawn.input)
                                        {
                                            pawn.input = {};
                                        }
                                        pawn.input[curKey] = keyVal;
                                    }
                                    break;
                            }
                            let sendData = {
                                keyId: curKey,
                                value: keyVal
                            };
                            if (pawn && pawn.data.controllableId)
                            {
                                let controllablePawn = this.getObjectById(pawn.data.controllableId);
                                this.handleControllableInput(pawn, controllablePawn, sendData);
                            }
                            else
                            {
                                this.handlePlayerInput(pawn, sendData);
                            }
                            if (curKey != Control.LOOK)
                            {
                                this.dispatchTrigger({
                                    event: "playerInput",
                                    playerId: _data.playerId,
                                    keyId: curKey,
                                    bValue: keyVal == true
                                });
                            }
                        }
                    }
                    _data.bServer = true;                   
                    break;
            }
            if (!_data.bServer)
            {
                this.onEvent(_data);
            }
        }
    }

    characterCanSwitchWeapons(_body)
    {
        var data = _body.data;
        return this.seatCanInput(_body) && !data.weapon.bFireDelay && !data.bInteracting && !data.bShieldCooldown && !data.weapon.bMeleeDelay;
    }

    characterCanMelee(_body)
    {
        var data = _body.data;
        var ps = this.getPlayerById(data.id);
        if (ps && ps.controllableId)
        {
            return false;
        }
        if (data.bShieldCooldown)
        {
            return false;
        }
        var item = this.getCurrentCharacterInventoryItem(_body);
        var bWeaponCanMelee = this.isMeleeWeapon(item) ? item.bCanMelee : true;
        return !data.bInteracting && !this.characterHasWeaponDelay(_body) && bWeaponCanMelee && !data.bSprinting;
    }

    triggerCharacterMeleeAttack(_body)
    {
        if (this.characterCanMelee(_body))
        {
            this.cancelCharacterReload(_body);
            this.cancelCharacterBoltPull(_body);
            var data = _body.data;
            var melee = data.melee;
            data.weapon.bMeleeDelay = true;
            data.weapon.meleeDelayTimer = (melee ? melee.fireRate : 30) * this.game.fpsMult;
            var damage = melee ? melee.damage : 100;
            this.createBullet({
                x: _body.position[0],
                y: _body.position[1] - 10,
                rotation: data.aimRotation,
                range: melee ? melee.range : 50,
                damage: damage,
                instigatorId: data.id,
                causerId: data.id,
                weaponId: melee ? melee.id : "melee_knife",
                weaponData: null,
                bDirectlyCausedByPlayer: true,
                bMelee: true,
                bIgnoreObstacles: false
            });
            this.requestEvent({
                eventId: GameServer.EVENT_PAWN_ACTION,
                pawnId: data.id,
                type: GameServer.PAWN_MELEE_ATTACK
            });
        }
    }

    getSeatData(_body)
    {
        if (!_body || _body.data.seatIndex == null || !_body.data.controllableId)
        {
            return null;
        }
        var vehicle = this.getObjectById(_body.data.controllableId);
        if (vehicle && vehicle.data.seats)
        {
            return vehicle.data.seats[_body.data.seatIndex];
        }
        return null;
    }

    getVehiclePawnIds(_vehicle)
    {
        var arr = [];
        var seats = _vehicle.data.seats;
        if (seats)
        {
            for (var i = 0; i < seats.length; i++)
            {
                var seat = seats[i];
                if (seat.pawnId)
                {
                    arr.push(seat.pawnId);
                }
            }
        }
        return arr;
    }

    getVehicleDriverId(_vehicle)
    {
        var seats = _vehicle.data.seats;
        if (seats)
        {
            for (var i = 0; i < seats.length; i++)
            {
                var seat = seats[i];
                if (seat.pawnId)
                {
                    return seat.pawnId;
                }
            }
        }
        return null;
    }

    getVehicleMuzzlePosition(_body, _index)
    {
        var weapon = this.getCurrentVehicleWeapon(_body, _index); //_body.data.weapons[_index];
        var pos = [_body.position[0], _body.position[1]];
        if (weapon.muzzlePos)
        {
            var offsetX = weapon.muzzlePos[0];
            var offsetY = weapon.muzzlePos[1];
            var offset = offsetX ? offsetX : offsetY;
            pos[0] += Math.cos(_body.angle) * offset;
            pos[1] += Math.sin(_body.angle) * offset;
        }
        return pos;
    }

    cycleVehicleWeapon(_body, _index)
    {
        var data = _body.data;
        var weapons = data.weapons;
        if (weapons)
        {
            var weaponList = weapons[_index];
            if (weaponList && weaponList.length > 1)
            {
                var seat = data.seats[_index];
                if (seat.weaponIndex == null)
                {
                    seat.weaponIndex = 0;
                }
                var prevWeapon = weaponList[seat.weaponIndex];
                if (prevWeapon)
                {
                    prevWeapon.bWantsToFire = false;
                }
                var curIndex = seat.weaponIndex;
                seat.weaponIndex++;
                if (seat.weaponIndex > weaponList.length - 1)
                {
                    seat.weaponIndex = 0;
                }
                for (var i = 0; i < weaponList.length; i++)
                {
                    //weaponList[i].aimRotation = weaponList[curIndex].aimRotation;
                    this.setVehicleWeaponAimRotation(_body, _index, weaponList[i], weaponList[curIndex].aimRotation);
                }
                this.pushObjectDataUpdate(data.id, ["seats"]);
                this.requestEvent({
                    eventId: GameServer.EVENT_PAWN_ACTION,
                    pawnId: _body.data.id,
                    type: GameServer.PAWN_VEHICLE_UPDATE,
                    index: _index,
                    weaponIndex: seat.weaponIndex
                });
            }
        }
    }

    setVehicleWeaponIndex(_body, _index, _weaponIndex)
    {
        var data = _body.data;
        var weapons = data.weapons;
        if (weapons)
        {
            var weaponList = weapons[_index];
            if (weaponList && weaponList.length > 1)
            {
                var seat = data.seats[_index];
                if (seat.weaponIndex == null)
                {
                    seat.weaponIndex = 0;
                }
                var prevIndex = seat.weaponIndex;
                weaponList[prevIndex].bWantsToFire = false;
                if (weaponList[_weaponIndex] && _weaponIndex != prevIndex)
                {
                    seat.weaponIndex = _weaponIndex;
                    this.pushObjectDataUpdate(data.id, ["seats"]);
                    this.requestEvent({
                        eventId: GameServer.EVENT_PAWN_ACTION,
                        pawnId: _body.data.id,
                        type: GameServer.PAWN_VEHICLE_UPDATE,
                        index: _index,
                        weaponIndex: seat.weaponIndex
                    });
                }
            }
        }
    }

    canSwitchSeats(_body)
    {
        return !_body.data.seatTimer && !_body.data.vehicleCooldown && _body.data.controllableId;
    }

    getCurrentVehicleWeapon(_vehicle, _seatIndex)
    {
        var weapons = _vehicle ? _vehicle.data.weapons : null;
        if (weapons)
        {
            var seat = _vehicle.data.seats[_seatIndex];
            var weaponIndex = (seat && seat.weaponIndex != null) ? seat.weaponIndex : 0;
            if (weapons[_seatIndex])
            {
                return weapons[_seatIndex][weaponIndex];
            }
        }
        return null;
    }

    switchSeats(_body)
    {
        if (this.canSwitchSeats(_body))
        {
            var vehicle = this.getObjectById(_body.data.controllableId);
            if (vehicle)
            {
                var seatIndex = this.getAvailableSeatIndex(vehicle);
                if (seatIndex != null)
                {
                    var weapon = this.getCurrentVehicleWeapon(vehicle, _body.data.seatIndex);
                    if (weapon)
                    {
                        weapon.bWantsToFire = false;
                    }
                    _body.data.seatTimer = Math.round(this.game.settings.fps * 0.35);
                    this.requestEvent({
                        eventId: GameServer.EVENT_PAWN_ACTION,
                        pawnId: _body.data.id,
                        type: GameServer.PAWN_SWITCH_SEATS,
                        value: true
                    });
                }
            }
        }
    }

    handleControllableInput(_char, _controllable, _data)
    {
        if (!_char || !_controllable || !_data)
        {
            return;
        }
        var type = _controllable.data.type;
        var keyId = _data["keyId"];
        var value = _data.value;
        var seatData = this.getSeatData(_char);
        if (seatData && seatData.bInput)
        {
            this.handlePlayerInput(_char, _data);
        }
        switch (keyId)
        {
            case Control.RELOAD:
                var weapon = this.getCurrentVehicleWeapon(_controllable, _char.data.seatIndex);
                if (weapon && weapon.weaponData)
                {
                    if (weapon.overheat > 0 && weapon.weaponData.overheatCooldownNum == 0 && !weapon.bCooldown)
                    {
                        weapon.bCooldown = true;
                        this.onEvent({
                            eventId: GameServer.EVENT_PAWN_ACTION,
                            pawnId: _controllable.data.id,
                            type: GameServer.PAWN_WEAPON_COOLDOWN,
                            index: _char.data.seatIndex,
                            value: weapon.bCooldown
                        });
                    }
                }
                break;
        }
        switch (type)
        {
            case ObjectType.MOUNTED_WEAPON:
                switch (keyId)
                {
                    case Control.LOOK:
                        var weapons = _controllable.data.weapons;
                        if (weapons)
                        {
                            var weapon = this.getCurrentVehicleWeapon(_controllable, _char.data.seatIndex);
                            if (weapon && value.pos)
                            {
                                var muzzlePos = this.getVehicleMuzzlePosition(_controllable, _char.data.seatIndex);
                                this.setVehicleWeaponAimRotation(_controllable, _char.data.seatIndex, weapon, this.Angle(muzzlePos[0], muzzlePos[1], value.pos[0], value.pos[1]));
                            }
                        }
                        break;
                }
                break;

            case ObjectType.CAR:
            case ObjectType.TANK:
                var carSpeed = (_controllable.data.speed ? _controllable.data.speed : 100);                
                if (type == ObjectType.TANK)
                {
                    var turnSpeed = 6;                  
                }
                else
                {
                    if (_controllable.mass < Number.MAX_VALUE)
                    {
                        var vel = this.getTotalVelocity(_controllable) * 0.001 / carSpeed;
                        turnSpeed = Math.min(carSpeed * Math.min(1, Math.abs(vel)), 100 / (_controllable.mass * 0.3));
                        turnSpeed = Math.min(30, turnSpeed);
                    }
                    else
                    {
                        turnSpeed = 0;
                    }
                }
                switch (keyId)
                {
                    case Control.WEAPON:
                        this.cycleVehicleWeapon(_controllable, _char.data.seatIndex);
                        break;

                    case Control.SWITCH:
                        this.switchSeats(_char);
                        break;

                    case Control.LOOK:
                        var weapons = _controllable.data.weapons;
                        if (weapons)
                        {
                            var weapon = this.getCurrentVehicleWeapon(_controllable, _char.data.seatIndex);
                            if (weapon && value.pos)
                            {
                                var muzzlePos = this.getVehicleMuzzlePosition(_controllable, _char.data.seatIndex);
                                this.setVehicleWeaponAimRotation(_controllable, _char.data.seatIndex, weapon, this.Angle(muzzlePos[0], muzzlePos[1], value.pos[0], value.pos[1]));
                            }
                        }
                        break;
                }
                break;

            case ObjectType.HELICOPTER:
                var heliSpeed = _controllable.data.speed;
                switch (keyId)
                {
                    case Control.WEAPON:
                        this.cycleVehicleWeapon(_controllable, _char.data.seatIndex);
                        break;

                    case Control.SWITCH:
                        this.switchSeats(_char);
                        break;

                    case Control.LOOK:
                        if (_char.data.seatTimer)
                        {
                            return;
                        }
                        var weapons = _controllable.data.weapons;
                        if (weapons)
                        {
                            var weapon = this.getCurrentVehicleWeapon(_controllable, _char.data.seatIndex);
                            if (weapon && value.pos)
                            {
                                var muzzlePos = this.getVehicleMuzzlePosition(_controllable, _char.data.seatIndex);
                                this.setVehicleWeaponAimRotation(_controllable, _char.data.seatIndex, weapon, this.Angle(muzzlePos[0], muzzlePos[1], value.pos[0], value.pos[1]));
                            }
                        }
                        break;

                    case Control.LEFT:
                        if (_char.data.seatIndex == 0)
                        {
                            if (value && _controllable.position[0] > 0)
                            {
                                _controllable.applyForce([-heliSpeed, 0]);
                            }
                        }
                        break;

                    case Control.RIGHT:
                        if (_char.data.seatIndex == 0)
                        {
                            if (value && _controllable.position[0] < this.getMapWidth())
                            {
                                _controllable.applyForce([heliSpeed, 0]);
                            }
                        }
                        break;

                    case Control.UP:
                        if (_char.data.seatIndex == 0)
                        {
                            if (value && _controllable.position[1] > 0)
                            {
                                _controllable.applyForce([0, -heliSpeed]);
                            }
                        }
                        break;

                    case Control.DOWN:
                        if (_char.data.seatIndex == 0)
                        {
                            if (value && _controllable.position[1] < this.getMapHeight())
                            {
                                _controllable.applyForce([0, heliSpeed]);
                            }
                        }
                        break;
                }
                break;
        }
    }

    toggleUnderbarrelEquipped(_body)
    {
        var item = this.getCurrentCharacterInventoryItem(_body, false);
        if (item)
        {
            if (this.hasUnderbarrelMod(item))
            {
                //if (item.bBarrel || (item.barrel.mag > 0 && item.barrel.ammo > 0))
                var data = _body.data;
                this.requestEvent({
                    eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                    pawnId: data.id,
                    type: GameServer.INV_UNDERBARREL_EQUIP,
                    index: data.currentInventoryIndex,
                    value: !item.bBarrel
                });
            }
        }
    }

    handlePlayerInput(_body, _data)
    {
        if (!_body || !_data)
        {
            return;
        }
        var keyId = _data.keyId;
        var value = _data.value;
        var pawn = _body;
        if (pawn)
        {
            var data = pawn.data;
            if (pawn.data.seatTimer)
            {
                return;
            }
            switch (keyId)
            {
                case Control.SWITCH:
                    var inventory = data.inventory;
                    if (inventory[data.currentInventoryIndex].barrel && inventory[data.currentInventoryIndex].bBarrel)
                    {
                        this.toggleUnderbarrelEquipped(_body);
                    }
                    else if (data.bBot)
                    {
                        if (inventory.length > 1)
                        {
                            this.requestEvent({
                                eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                                pawnId: data.id,
                                type: GameServer.INV_CURRENT_INVENTORY_INDEX,
                                value: data.currentInventoryIndex == 0 ? 1 : 0
                            });
                        }
                    }
                    break;

                case Control.INV_NEXT:
                case Control.INV_PREV:
                    break;

                case Control.WEAPON:
                    this.toggleUnderbarrelEquipped(pawn);
                    break;

                case Control.ITEM:
                    var ps = this.getPlayerById(data.id);
                    if (data.bReloading)
                    {
                        this.cancelCharacterReload(pawn);
                    }
                    if (ps && this.characterIsFree(pawn))
                    {
                        this.useItem(ps.id);
                    }
                    break;

                case Control.ITEM_1:
                    if (data.currentInventoryIndex != 0)
                    {
                        this.requestEvent({
                            eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                            pawnId: data.id,
                            type: GameServer.INV_CURRENT_INVENTORY_INDEX,
                            value: 0
                        });
                    }
                    break;

                case Control.ITEM_2:
                    if (data.currentInventoryIndex != 1)
                    {
                        this.requestEvent({
                            eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                            pawnId: data.id,
                            type: GameServer.INV_CURRENT_INVENTORY_INDEX,
                            value: 1
                        });
                    }
                    break;

                case Control.ITEM_3:
                    if (data.currentInventoryIndex != 2)
                    {
                        this.requestEvent({
                            eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                            pawnId: data.id,
                            type: GameServer.INV_CURRENT_INVENTORY_INDEX,
                            value: 2
                        });
                    }
                    break;

                case Control.LOOK:
                    data.desiredAimRotation = value.angle;
                    data.lookPos = value.pos;
                    data.bAiming = value.bAiming == true ? 1 : 0;
                    if (value.pawn && !data.bBot)
                    {
                        if (this.isValidArray(value.pawn))
                        {
                            data.clientPos = value.pawn;
                            _body.position = value.pawn;
                        }
                        if (this.isValidArray(value.velocity))
                        {
                            _body.velocity = value.velocity;

                        }
                    }
                    break;

                case Control.MELEE:
                    if (pawn.data.type == ObjectType.CHARACTER)
                    {
                        this.triggerCharacterMeleeAttack(pawn);
                    }
                    break;

                case Control.RELOAD:
                    this.reloadCharacterWeapon(pawn, true);
                    break;

                case Control.LEFT:
                    switch (data.type)
                    {
                        case ObjectType.DINOSAUR:
                            data.bWantsToMove = value && this.pawnCanMove(_body);
                            break;
                        case ObjectType.CHARACTER:
                            data.bWantsToMove = value && this.pawnCanMove(_body);
                            if (data.bWantsToMove)
                            {
                                data.moveX = -1;
                            }
                            else
                            {
                                delete data.moveX;
                            }
                            break;
                    }
                    break;

                case Control.RIGHT:
                    switch (data.type)
                    {
                        case ObjectType.DINOSAUR:
                            data.bWantsToMove = value && this.pawnCanMove(_body);
                            break;
                        case ObjectType.CHARACTER:
                            data.bWantsToMove = value && this.pawnCanMove(_body);
                            if (value)
                            {
                                data.moveX = 1;
                            }
                            else
                            {
                                delete data.moveX;
                            }
                            break;
                    }
                    break;

                case Control.UP:
                    switch (data.type)
                    {
                        case ObjectType.DINOSAUR:
                            data.bWantsToMove = value && this.pawnCanMove(_body);
                            break;
                        case ObjectType.CHARACTER:
                            data.bWantsToMove = value && this.pawnCanMove(_body);
                            if (value)
                            {
                                data.moveY = -1;
                            }
                            else
                            {
                                delete data.moveY;
                            }
                            break;
                    }
                    break;

                case Control.DOWN:
                    switch (data.type)
                    {
                        case ObjectType.DINOSAUR:
                            data.bWantsToMove = value && this.pawnCanMove(_body);
                            break;
                        case ObjectType.CHARACTER:
                            data.bWantsToMove = value && this.pawnCanMove(_body);
                            if (value)
                            {
                                data.moveY = 1;
                            }
                            else
                            {
                                delete data.moveY;
                            }
                            break;
                    }
                    break;

                case Control.JUMP:
                    break;

                case Control.CROUCH:
                    switch (data.type)
                    {
                        case ObjectType.CHARACTER:
                            this.setDataValue(pawn, "bCrouching", value && this.characterCanCrouch(pawn));
                            break;
                    }
                    break;

                case Control.SPRINT:
                    switch (data.type)
                    {
                        case ObjectType.CHARACTER:
                            this.setDataValue(pawn, "bSprinting", value && this.characterCanSprint(pawn));
                            break;
                    }
                    break;

                case Control.FIRE:
                    this.triggerCharacterWeapon({
                        playerId: _body.data.id,
                        value: value
                    });
                    break;
            }
        }
    }

    triggerCharacterJump(_body)
    {
        return;
    }

    executeInteractable(_interactable, _playerId)
    {
        if (!this.matchInProgress() || !_interactable || _interactable.data.bPendingRemoval)
        {
            return;
        }
        if (_interactable.data.bLimitInteractions)
        {
            delete _interactable.data.currentPawnId;
        }
        this.onEvent({
            eventId: GameServer.EVENT_PAWN_ACTION,
            pawnId: _playerId,
            type: GameServer.PAWN_INTERACTABLE_USED,
            interactableId: _interactable.data.id
        });
        this.dispatchTrigger({
            event: "objectUsed",
            objectId: _interactable.data.id,
            userId: _playerId
        });
        var pawn = this.getObjectById(_playerId);        
        var data = _interactable.data;
        if (pawn)
        {
            if (pawn.ai)
            {
                if (pawn.ai.desiredItemId == data.id)
                {
                    delete pawn.ai.desiredItemId;
                    delete pawn.ai.bWantsItem;
                }
            }
        }
        try
        {
            if (data)
            {
                switch (data.type)
                {
                    case ObjectType.REVIVER:
                        this.respawnPlayer(data.itemData.playerId, {
                            position: [_interactable.position[0], _interactable.position[1] - 30]
                        });
                        this.onEvent({
                            eventId: GameServer.EVENT_PAWN_ACTION,
                            pawnId: _playerId,
                            type: GameServer.PAWN_END_REVIVE,
                            reviveId: data.itemData.playerId
                        });
                        var ps = this.getPlayerById(_playerId);
                        if (ps)
                        {
                            ps.revives = ps.revives ? (ps.revives + 1) : 1;
                            this.onEvent({
                                eventId: GameServer.EVENT_PLAYER_UPDATE,
                                playerId: _playerId,
                                data: {
                                    revives: ps.revives
                                }
                            });
                            if (this.game.bSurvival)
                            {
                                this.game.gameModeData.waveRevives++;
                                if (this.game.gameModeData.waveRevives < 4)
                                {
                                    this.addPlayerMoney(ps.id, 250);
                                }
                            }
                        }
                        this.removeNextStep(_interactable);
                        break;

                    case ObjectType.LEVER:
                        if (!data.bDisabled && !pawn.data.shieldCooldownTimer)
                        {
                            if (data.targetId)
                            {
                                var target = this.getObjectById(data.targetId);
                                if (target)
                                {
                                    switch (target.data.type)
                                    {
                                        case ObjectType.DOOR:
                                            this.setDoorClosed(target, !target.data.bClosed);
                                            break;
                                    }
                                }
                            }
                            if (data.triggerId)
                            {
                                this.checkTriggerAndExecuteById(data.triggerId, { objectId: pawn.data.id, leverId: data.id });
                            }
                            this.startCharacterShieldCooldown(pawn);
                        }
                        break;

                    case ObjectType.DOOR:
                        if (!data.cooldownTimer && !data.leverId && !data.bDisabled)
                        {
                            this.setDoorClosed(_interactable, !data.bClosed, pawn);
                            this.startCharacterShieldCooldown(pawn);
                        }
                        break;

                    case ObjectType.EQUIPMENT:
                        switch (data.weaponData.id)
                        {
                            case "ammo_box":
                                var inventory = pawn.data.inventory;
                                var numMags = 1;
                                for (var i = 0; i < inventory.length; i++)
                                {
                                    var invItem = inventory[i];
                                    if (invItem && !invItem.bMelee && !invItem.bEquipment && invItem.ammo != null)
                                    {
                                        this.requestEvent({
                                            eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                                            pawnId: pawn.data.id,
                                            index: i,
                                            type: GameServer.INV_AMMO_ADD,
                                            value: invItem.magSize * numMags,
                                            barrelAmmo: invItem.barrel ? invItem.barrel.magSize : 1
                                        });
                                    }
                                }
                                this.requestEvent({
                                    eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                                    pawnId: pawn.data.id,
                                    type: GameServer.INV_EQUIPMENT_ADD,
                                    slot: "grenade",
                                    value: 1
                                });
                                if (pawn.data.equipment && pawn.data.equipment.id != "ammo_box")
                                {
                                    this.requestEvent({
                                        eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                                        pawnId: pawn.data.id,
                                        type: GameServer.INV_EQUIPMENT_ADD,
                                        slot: "equipment",
                                        value: 1
                                    });
                                }
                                break;
                        }
                        break;

                    case ObjectType.CRATE:
                        switch (data.crateType)
                        {
                            case Crate.OBJECTIVE:
                                switch (this.game.gameModeId)
                                {
                                    case GameMode.EXTRACTION:
                                        this.game.gameModeData.numObjectives++;
                                        var gameUpdate = {
                                            bAirdropSecured: 1,
                                            playerId: pawn.data.id,
                                            numObjectives: this.game.gameModeData.numObjectives
                                        };
                                        var ps = this.getPlayerById(pawn.data.id);
                                        if (ps)
                                        {
                                            ps.score++;
                                            this.onEvent({
                                                eventId: GameServer.EVENT_PLAYER_UPDATE,
                                                playerId: ps.id,
                                                data: {
                                                    score: ps.score
                                                }
                                            });
                                        }
                                        if (this.game.gameModeData.numObjectives >= this.game.gameModeData.numTotalAirdrops)
                                        {
                                            //Create extraction helicopter
                                            var teamSpawnPos = this.getCurrentMapData().teamSpawns[0];
                                            var heli = this.createHelicopter([this.RandomBoolean() ? 0 : this.getMapWidth(), this.RandomBoolean() ? 0 : this.getMapHeight()], {
                                                id: "extractHeli",
                                                vehicleId: Helicopter.MH6,
                                                team: 0,
                                                destination: [teamSpawnPos.x + (teamSpawnPos.w * 0.5), teamSpawnPos.y + (teamSpawnPos.h * 0.5)],
                                                items: [
                                                    {
                                                        type: ObjectType.TRIGGER_AREA,
                                                        id: "extractZone",
                                                        team: 0,
                                                        width: 250,
                                                        height: 250,
                                                        attachToId: "extractHeli",
                                                        indicatorData: {
                                                            labelText: "STR_EXTRACTION_HELICOPTER",
                                                            icon: null
                                                        }
                                                    }
                                                ],
                                                defendTimer: 9999999,
                                                bAutomated: true,
                                                bGodMode: true,
                                                bUntargetable: true,
                                                pawnName: "Extraction Helicopter"
                                            });
                                            gameUpdate.bExtractionHeli = 1;
                                            this.removeObjectById("classCrate");
                                        }
                                        this.onEvent({
                                            eventId: GameServer.EVENT_GAME_UPDATE,
                                            data: gameUpdate
                                        });
                                        break;
                                }
                                break;
                            case Crate.STORE:
                                var ps = this.getPlayerById(_playerId);
                                if (ps && ps.bBot)
                                {
                                    //Logic for bots using tactical crate
                                    if (this.needsBetterWeapon(pawn))
                                    {
                                        var weapons = this.clone(this.data.weapons);
                                        this.ShuffleArray(weapons);
                                        weaponLoop: for (var i = 0; i < weapons.length; i++)
                                        {
                                            var curWeapon = weapons[i];
                                            if (!curWeapon.bHidden && !curWeapon.bVehicle && !curWeapon.bExcludeFromStore)
                                            {
                                                if (this.getWeaponMoneyCost(curWeapon) <= ps.money)
                                                {
                                                    typeLoop: switch (curWeapon.type)
                                                    {
                                                        case Weapon.TYPE_RIFLE:
                                                        case Weapon.TYPE_LMG:
                                                        case Weapon.TYPE_SNIPER:
                                                        case Weapon.TYPE_DMR:
                                                            this.requestEvent({
                                                                eventId: GameServer.EVENT_BUY,
                                                                pawnId: ps.id,
                                                                weaponId: curWeapon.id,
                                                                index: 0
                                                            });
                                                            break weaponLoop;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    if (ps.items.length < 3)
                                    {
                                        var items = this.clone(this.data.items);
                                        this.ShuffleArray(items);
                                        for (var i = 0; i < items.length; i++)
                                        {
                                            let curItem = items[i];
                                            if (curItem.cost <= ps.money)
                                            {
                                                switch (curItem.id)
                                                {
                                                    case Item.AMMO_AIRDROP:
                                                        if (this.getDisposableCrates().length >= 2)
                                                        {
                                                            continue;
                                                        }
                                                        break;
                                                }
                                                this.requestEvent({
                                                    eventId: GameServer.EVENT_BUY,
                                                    pawnId: ps.id,
                                                    itemId: curItem.id
                                                });
                                                break;
                                            }
                                        }
                                    }
                                }
                                break;
                            case Crate.BOMB:
                            case Crate.BOMB_GENERIC:
                                if (data.bBombPlanted)
                                {
                                    this.setDataValue(_interactable, "bBombPlanted", false);
                                    data.bombTimer = data.bombTimerMax;
                                    data.itemData.interactTeam = data.team == 0 ? 1 : 0;
                                    this.pushObjectDataUpdate(data.id, ["bBombPlanted", "bombTimer", "itemData"]);
                                    var ps = this.getPlayerById(_playerId);
                                    if (ps)
                                    {
                                        ps.defuses++;
                                        this.onEvent({
                                            eventId: GameServer.EVENT_PLAYER_UPDATE,
                                            playerId: _playerId,
                                            data: {
                                                defuses: ps.defuses
                                            }
                                        });
                                    }
                                    this.onEvent({
                                        eventId: GameServer.EVENT_GAME_UPDATE,
                                        data: {
                                            playerId: _playerId,
                                            defuseTeam: data.team,
                                            bombNum: data.bombNum
                                        }
                                    });
                                }
                                else
                                {
                                    this.setDataValue(_interactable, "bBombPlanted", true);
                                    data.itemData.interactTeam = data.team;
                                    this.pushObjectDataUpdate(data.id, ["bBombPlanted", "itemData"]);
                                    var ps = this.getPlayerById(_playerId);
                                    if (ps)
                                    {
                                        ps.plants++;
                                        this.onEvent({
                                            eventId: GameServer.EVENT_PLAYER_UPDATE,
                                            playerId: _playerId,
                                            data: {
                                                plants: ps.plants
                                            }
                                        });
                                    }
                                    this.onEvent({
                                        eventId: GameServer.EVENT_GAME_UPDATE,
                                        data: {
                                            playerId: _playerId,
                                            plantTeam: data.team == 0 ? 1 : 0,
                                            bombNum: data.bombNum
                                        }
                                    });
                                }
                                break;

                            case Crate.ITEM:
                                var crateItem = this.getItemData(data.itemId);
                                if (crateItem)
                                {
                                    var ps = this.getPlayerById(_playerId);
                                    if (ps)
                                    {
                                        if (ps.items)
                                        {
                                            ps.items.push({
                                                id: data.itemId
                                            });
                                            ps.itemIndex = ps.items.length - 1;
                                            this.requestEvent({
                                                eventId: GameServer.EVENT_PLAYER_UPDATE,
                                                playerId: _playerId,
                                                data: {
                                                    items: ps.items,
                                                    itemIndex: ps.itemIndex,
                                                    itemId: data.itemId
                                                }
                                            });
                                        }
                                    }
                                    else
                                    {
                                        var pawn = this.getObjectById(_playerId);
                                        if (pawn)
                                        {
                                            if (!pawn.data.pawnItems)
                                            {
                                                pawn.data.pawnItems = [];
                                            }
                                            var pawnItems = pawn.data.pawnItems;
                                            if (pawnItems)
                                            {
                                                pawnItems.push({
                                                    id: data.itemId
                                                });
                                            }
                                        }
                                    }
                                }
                                break;

                            case Crate.AMMO:
                                var inventory = pawn.data.inventory;
                                var numMags = 4;
                                for (var i = 0; i < inventory.length; i++)
                                {
                                    var invItem = inventory[i];
                                    if (invItem && !invItem.bMelee && !invItem.bEquipment && invItem.ammo != null)
                                    {
                                        var bWasEmpty = invItem.mag == 0;
                                        this.requestEvent({
                                            eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                                            pawnId: pawn.data.id,
                                            index: i,
                                            type: GameServer.INV_AMMO_ADD,
                                            value: invItem.magSize * numMags,
                                            barrelAmmo: (invItem.barrel ? invItem.barrel.magSize : 1) * numMags
                                        });
                                    }
                                }
                                this.requestEvent({
                                    eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                                    pawnId: pawn.data.id,
                                    type: GameServer.INV_EQUIPMENT_ADD,
                                    slot: "grenade",
                                    value: 4
                                });
                                if (pawn.data.equipment && pawn.data.equipment.id != "ammo_box")
                                {
                                    this.requestEvent({
                                        eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                                        pawnId: pawn.data.id,
                                        type: GameServer.INV_EQUIPMENT_ADD,
                                        slot: "equipment",
                                        value: 4
                                    });
                                }
                                break;
                        }
                        var items = data.items;
                        if (items && items.length > 0)
                        {
                            for (var i = 0; i < items.length; i++)
                            {
                                var crateItem = items[i];
                                if (crateItem)
                                {
                                    this.spawnItem(crateItem, _interactable.position, crateItem.team);
                                }
                            }
                        }
                        break;

                    case ObjectType.MOUNTED_WEAPON:
                    case ObjectType.HELICOPTER:
                    case ObjectType.TANK:
                    case ObjectType.CAR:
                        var seatIndex = this.getAvailableSeatIndex(_interactable);
                        if (seatIndex != null)
                        {
                            this.enterVehicle(pawn, _interactable, seatIndex);
                        }
                        break;

                    case ObjectType.DROPPED_WEAPON:
                        if (pawn)
                        {
                            var weaponData = data.itemData["weaponData"];
                            if (weaponData.type == Weapon.TYPE_MELEE && weaponData.id != "blowtorch")
                            {
                                if (!pawn.data.bNoPickups)
                                {
                                    var curMelee = pawn.data.inventory[2];
                                    if (!curMelee || weaponData.id)
                                    {
                                        this.dropCharacterEquipment(pawn, "melee");
                                        this.requestEvent({
                                            eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                                            pawnId: pawn.data.id,
                                            index: 2,
                                            slot: "melee",
                                            value: weaponData.id,
                                            type: GameServer.INV_EQUIPMENT_SET,
                                            sfxId: "wpn_ammo"
                                        });
                                        this.requestEvent({
                                            eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                                            pawnId: pawn.data.id,
                                            index: 2,
                                            item: weaponData,
                                            type: GameServer.INV_ITEM_REPLACE
                                        });
                                        this.removeNextStep(_interactable);
                                    }
                                }
                            }
                            else if (weaponData.type == Weapon.TYPE_GRENADE)
                            {
                                var grenade = pawn.data.grenade;
                                if (grenade && grenade.id == weaponData.id)
                                {
                                    this.requestEvent({
                                        eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                                        pawnId: pawn.data.id,
                                        slot: "grenade",
                                        value: 1,
                                        type: GameServer.INV_EQUIPMENT_ADD,
                                        sfxId: "wpn_ammo"
                                    });
                                    this.removeNextStep(_interactable);
                                }
                                else if (!pawn.data.bNoPickups)
                                {
                                    this.dropCharacterEquipment(pawn, "grenade");
                                    this.requestEvent({
                                        eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                                        pawnId: pawn.data.id,
                                        slot: "grenade",
                                        value: weaponData.id,
                                        type: GameServer.INV_EQUIPMENT_SET,
                                        sfxId: "wpn_ammo"
                                    });
                                    this.removeNextStep(_interactable);
                                }
                            }
                            else if (weaponData.bEquipment)
                            {
                                var equipment = pawn.data.equipment;
                                if (equipment && equipment.id == weaponData.id)
                                {
                                    this.requestEvent({
                                        eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                                        pawnId: pawn.data.id,
                                        slot: "equipment",
                                        value: 1,
                                        type: GameServer.INV_EQUIPMENT_ADD,
                                        sfxId: "wpn_ammo"
                                    });
                                    this.removeNextStep(_interactable);
                                }
                                else if (!pawn.data.bNoPickups)
                                {
                                    this.dropCharacterEquipment(pawn, "equipment");
                                    this.requestEvent({
                                        eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                                        pawnId: pawn.data.id,
                                        slot: "equipment",
                                        value: weaponData.id,
                                        type: GameServer.INV_EQUIPMENT_SET,
                                        sfxId: "wpn_ammo"
                                    });
                                    this.removeNextStep(_interactable);
                                    if (pawn.data.currentInventoryIndex == Character.INDEX_EQUIPMENT)
                                    {
                                        this.requestEvent({
                                            eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                                            pawnId: pawn.data.id,
                                            type: GameServer.INV_CURRENT_INVENTORY_INDEX,
                                            value: 0
                                        });
                                    }
                                }
                            }
                            else
                            {
                                var inventory = pawn.data.inventory;
                                var itemIndex = this.getCharacterInventoryItemIndex(pawn, weaponData.id);
                                if (itemIndex >= 0)
                                {
                                    if (!this.isMeleeWeapon(weaponData))
                                    {
                                        this.requestEvent({
                                            eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                                            pawnId: pawn.data.id,
                                            index: itemIndex,
                                            value: (weaponData.mag + weaponData.ammo),
                                            type: GameServer.INV_AMMO_ADD,
                                            sfxId: "wpn_ammo",
                                            barrelAmmo: weaponData.barrel ? (weaponData.barrel.mag + weaponData.barrel.ammo) : 0
                                        });
                                        this.removeNextStep(_interactable);
                                    }
                                }
                                else if (!pawn.data["bNoPickups"])
                                {
                                    if (!inventory[0])
                                    {
                                        this.requestEvent({
                                            eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                                            pawnId: pawn.data.id,
                                            index: 0,
                                            item: weaponData,
                                            type: GameServer.INV_ITEM_REPLACE
                                        });
                                        this.requestEvent({
                                            eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                                            pawnId: pawn.data.id,
                                            value: 0,
                                            type: GameServer.INV_CURRENT_INVENTORY_INDEX
                                        });
                                    }
                                    else if (!inventory[1])
                                    {
                                        this.requestEvent({
                                            eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                                            pawnId: pawn.data.id,
                                            index: 1,
                                            item: weaponData,
                                            type: GameServer.INV_ITEM_REPLACE
                                        });
                                        this.requestEvent({
                                            eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                                            pawnId: pawn.data.id,
                                            value: 1,
                                            type: GameServer.INV_CURRENT_INVENTORY_INDEX
                                        });
                                    }
                                    else if (inventory.length <= 1)
                                    {
                                        if (inventory[0] && inventory[0].id == "none")
                                        {
                                            this.requestEvent({
                                                eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                                                pawnId: pawn.data.id,
                                                index: 0,
                                                item: weaponData,
                                                type: GameServer.INV_ITEM_REPLACE
                                            });
                                        }
                                        else
                                        {
                                            this.requestEvent({
                                                eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                                                pawnId: pawn.data.id,
                                                item: weaponData,
                                                type: GameServer.INV_ITEM_ADD,
                                                sfxId: "wpn_ammo"
                                            });
                                        }
                                    }
                                    else
                                    {
                                        var meleeIndex = pawn.data.currentInventoryIndex;
                                        for (var i = 0; i < inventory.length; i++)
                                        {
                                            var item = inventory[i];
                                            if (item && item.id == "none")
                                            {
                                                meleeIndex = i;
                                                break;
                                            }
                                        }
                                        meleeIndex = Math.min(1, meleeIndex);
                                        this.dropCharacterWeapon(pawn, meleeIndex);
                                        this.requestEvent({
                                            eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                                            pawnId: pawn.data.id,
                                            index: meleeIndex,
                                            item: weaponData,
                                            type: GameServer.INV_ITEM_REPLACE
                                        });
                                        if (meleeIndex >= 0)
                                        {
                                            this.requestEvent({
                                                eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                                                pawnId: pawn.data.id,
                                                value: meleeIndex,
                                                type: GameServer.INV_CURRENT_INVENTORY_INDEX
                                            });
                                        }
                                    }
                                    this.removeNextStep(_interactable);
                                }
                            }
                        }
                        break;
                }
                if (data.itemData && data.itemData.uses != null)
                {
                    data.itemData.uses--;
                    if (data.itemData.uses <= 0)
                    {
                        this.removeNextStep(_interactable);
                    }
                    this.pushObjectDataUpdate(data.id, ["itemData"]);
                }
            }
        }
        catch (e)
        {
            console.warn(e);
        }
    }

    setPlayerControllable(_playerId, _controllable)
    {
        var pawn = this.getObjectById(_playerId);
        if (pawn && _controllable)
        {
            _controllable.data.controllerId = _playerId;
        }
        var ps = this.getPlayerById(_playerId);
        if (ps)
        {
            ps.controllableId = _controllable ? _controllable.data.id : null;
            this.onEvent({
                eventId: GameServer.EVENT_PLAYER_UPDATE,
                playerId: ps.id,
                data: {
                    controllableId: ps.controllableId
                }
            });
        }
    }

    getAvailableSeatIndex(_vehicle)
    {
        if (_vehicle)
        {
            var seats = _vehicle.data.seats;
            for (var i = 0; i < seats.length; i++)
            {
                var seat = seats[i];
                if (!seat.pawnId)
                {
                    return i;
                }
            }
        }
        return null;
    }

    hasAvailableSeat(_vehicle)
    {
        if (_vehicle.data.bAutomated || _vehicle.data.bDisabled)
        {
            return false;
        }
        return this.getAvailableSeatIndex(_vehicle) != null;
    }

    clearPlayerControllable(_id, _bEject)
    {
        var pawn = this.getObjectById(_id);
        var controllable = pawn ? this.getObjectById(pawn.data.controllableId) : null;
        if (controllable && pawn)
        {
            if (this.isVehicle(controllable))
            {
                this.exitVehicle(pawn, _bEject);
            }
            delete pawn.data.controllableId;
            controllable.data.controllerId = null;
        }
        var ps = this.getPlayerById(_id);
        if (ps)
        {
            ps.controllableId = null;
            this.onEvent({
                eventId: GameServer.EVENT_PLAYER_UPDATE,
                playerId: _id,
                data: {
                    controllableId: null
                }
            });
        }
        if (pawn)
        {
            pawn.data.bCrouching = false;
        }
    }

    startInteraction(_pawn, _interactable)
    {
        var data = _pawn.data;
        if (_interactable && this.characterCanInteract(_pawn, _interactable))
        {
            if (_interactable.data.bLimitInteractions)
            {
                _interactable.data.currentPawnId = data.id;
            }
            var interactData = _interactable.data.itemData;
            var interactTime = interactData ? interactData["interactTime"] : 0;
            if (interactTime > 0)
            {
                switch (_interactable.data.type)
                {
                    case ObjectType.CRATE:
                        if (interactData["ownerId"] && interactData["ownerId"] != data.id)
                        {
                            //interactTime = this.game.settings.fps * 3;
                        }
                        break;
                    case ObjectType.REVIVER:
                        this.onEvent({
                            eventId: GameServer.EVENT_PAWN_ACTION,
                            pawnId: data.id,
                            type: GameServer.PAWN_START_REVIVE
                        });
                        break;
                }
                this.cancelCharacterBoltPull(_pawn);
                this.cancelCharacterReload(_pawn);
                _pawn.velocity[0] = 0;
                data.bInteracting = true;
                data.interactTimer = interactTime;
                data.interactableId = _interactable.data.id;
                this.requestEvent({
                    eventId: GameServer.EVENT_PAWN_ACTION,
                    pawnId: data.id,
                    type: GameServer.PAWN_START_INTERACTION,
                    interactableId: _interactable.data.id,
                    timer: interactTime
                });
            }
            else
            {
                if (this.isVehicle(_interactable))
                {
                    if (this.canEnterVehicle(_pawn, _interactable))
                    {
                        this.executeInteractable(_interactable, data.id);
                    }
                }
                else
                {
                    this.executeInteractable(_interactable, data.id);
                }
            }
        }
    }

    attemptInteract(_id)
    {
        if (!this.matchInProgress())
        {
            return;
        }
        var pawn = this.getObjectById(_id);
        var ps = this.getPlayerById(_id);
        if (ps && ps.controllableId)
        {
            var controllable = this.getObjectById(ps.controllableId);
            if (controllable)
            {
                switch (controllable.data.type)
                {
                    //TODO
                }
            }
            if (this.canExitVehicle(pawn))
            {
                this.clearPlayerControllable(ps.id);
            }
        }
        else
        {
            if (!pawn)
            {
                return;
            }
            var data = pawn.data;
            var interactable = this.getInteractableForPawn(pawn);
            //If no interactable to interact with
            if (!interactable)
            {
                var equipment = data.equipment;
                if (equipment)
                {
                    switch (equipment.id)
                    {
                        case "c4":
                            if (!pawn.data.weapon.bThrowDelay)
                            {
                                var grenades = this.getGrenades(data.id, "c4");
                                for (var i = 0; i < grenades.length; i++)
                                {
                                    this.detonate(grenades[i]);
                                }
                            }
                            break;
                    }
                }
            }
            else
            {
                if (!data.bBot && data.bInteracting)
                {
                    this.stopCharacterInteract(pawn);
                }
                else
                {
                    this.startInteraction(pawn, interactable);
                }
            }
        }
    }

    getTouchingRepairableObject(_body)
    {
        var objects = this.getTypes([
            ObjectType.CAR,
            ObjectType.TANK,
            ObjectType.HELICOPTER,
            ObjectType.MOUNTED_WEAPON,
            ObjectType.OBSTACLE
        ]);
        for (var i = 0; i < objects.length; i++)
        {
            let obj = objects[i];
            let data = obj.data;
            if (data.bDisableRepair)
            {
                continue;
            }
            if (data.health)
            {
                if (data.team != -1 && data.team != _body.data.team)
                {
                    continue;
                }
                if (data.type == ObjectType.OBSTACLE && data.material != Material.METAL)
                {
                    continue;
                }
                if (this.DistBodies(_body, obj) < 100 || obj.getAABB().overlaps(_body.getAABB()))
                {
                    if (data.health >= data.maxHealth || data.bGodMode)
                    {
                        continue;
                    }
                    return obj;
                }
            }
        }
        return null;
    }

    getNearbyRepairableObject(_body)
    {
        var arr = [];
        var vehicles = this.getVehicles();
        for (var i = 0; i < vehicles.length; i++)
        {
            let obj = vehicles[i];
            let data = obj.data;
            if (!data.bPendingRemoval && !data.bDisableRepair && data.team == _body.data.team && data.health < data.maxHealth && this.DistBodies(obj, _body) < 1000)
            {
                arr.push(obj);
            }
        }
        if (arr.length > 0)
        {
            return arr[this.Random(0, arr.length - 1)];
        }
        return null;
    }

    getNearbyVehicle(_body)
    {
        var arr = [];
        var vehicles = this.getVehicles();
        for (var i = 0; i < vehicles.length; i++)
        {
            let obj = vehicles[i];
            let data = obj.data;
            if (!data.bPendingRemoval && (data.team == -1 || data.team == _body.data.team) && this.hasAvailableSeat(obj) && this.DistBodies(obj, _body) < 1000)
            {
                arr.push(obj);
            }
        }
        if (arr.length > 0)
        {
            return arr[this.Random(0, arr.length - 1)];
        }
        return null;
    }

    getAIBestBombCrate(_body)
    {
        if (!_body.data.bCanInteract)
        {
            return [];
        }
        var arr = [];
        var keys = Object.keys(this.game.objects);
        for (var i = 0; i < keys.length; i++)
        {
            var cur = this.game.objects[keys[i]];
            if (cur.data)
            {
                switch (cur.data.type)
                {
                    case ObjectType.CRATE:
                        if (cur.data.crateType == Crate.BOMB || cur.data.crateType == Crate.BOMB_GENERIC)
                        {
                            if (cur.data.team == _body.data.team)
                            {
                                if (cur.data.bBombPlanted) arr.push(cur);
                            }
                            else
                            {
                                //if (!cur.data.bBombPlanted) 
                                arr.push(cur);
                            }
                        }
                        break;
                }
            }
        }
        arr.sort((a, b) =>
        {
            var distA = this.DistBodies(_body, a);
            var distB = this.DistBodies(_body, b);
            if (distA < distB) return -1;
            if (distA > distB) return 1;
            return 0;
        });
        return arr;
    }    

    getDesiredInteractable(_body, _maxDist = Number.MAX_VALUE)
    {
        var data = _body.data;
        var ai = _body.ai;
        var ps = this.getPlayerById(data.id);       
        var revivers = this.getRevivers(data.team);
        if (revivers.length > 0)
        {
            revivers.sort((a, b) =>
            {
                var distA = this.DistBodies(a, _body);
                var distB = this.DistBodies(b, _body);
                if (distA < distB) return -1;
                if (distA > distB) return 1;
                return 0;
            });
            return revivers[0];
        }
        if (ps && ps.money >= 2500 && (this.needsBetterWeapon(_body) || ps.items.length < 1))
        {
            if (!this.game.bSurvival || this.game.gameModeData.bIntermission)
            {
                return this.getStoreCrate();
            }
        }
        var crate = this.getNearestObjectiveCrate(_body);
        if (crate && this.DistBodies(_body, crate) < _maxDist)
        {
            return crate;
        }
        if (this.needsAmmo(_body))
        {
            var ammoItems = this.getAmmoItems();
            ammoItems.sort((a, b) =>
            {
                var distA = this.DistBodies(a, _body);
                var distB = this.DistBodies(b, _body);
                if (distA < distB) return -1;
                if (distA > distB) return 1;
                return 0;
            });
            return ammoItems[0];
        }
        var crates = this.getDisposableCrates();
        if (crates.length > 0)
        {
            for (var i = crates.length - 1; i >= 0; i--)
            {
                let crate = crates[i];
                if (this.DistBodies(_body, crate) > _maxDist)
                {
                    crates.splice(i, 1);
                }
                else
                {
                    switch (crate.data.crateType)
                    {
                        case Crate.STORE:
                            if (!ps || !ps.money)
                            {
                                crates.splice(i, 1);
                            }
                            break;
                        case Crate.AMMO:
                            if (!this.needsAmmo(_body))
                            {
                                crates.splice(i, 1);
                            }
                            break;
                    }
                }
            }
            crates.sort((a, b) =>
            {
                var distA = this.DistBodies(a, _body);
                var distB = this.DistBodies(b, _body);
                if (distA < distB) return -1;
                if (distA > distB) return 1;
                return 0;
            });
            return crates[0];
        }
    }

    needsBetterWeapon(_body)
    {
        var curItem = this.getCurrentCharacterInventoryItem(_body);
        if (curItem)
        {
            switch (curItem.type)
            {
                case Weapon.TYPE_RIFLE:
                case Weapon.TYPE_LMG:
                case Weapon.TYPE_SNIPER:
                case Weapon.TYPE_DMR:
                    return false;
            }
        }
        return true;
    }

    getTouchingInteractable(_body)
    {
        var data = _body.data;
        var ai = _body.ai;
        if (ai.objectiveItemId)
        {
            var objectiveItem = this.getObjectById(ai.objectiveItemId);
            if (objectiveItem && _body.getAABB().overlaps(objectiveItem.getAABB()))
            {
                return objectiveItem;
            }
        }
        if (!objectiveItem)
        {
            if (ai.desiredItemId)
            {
                var desiredItem = this.getObjectById(ai.desiredItemId);
                if (desiredItem && _body.getAABB().overlaps(desiredItem.getAABB()))
                {
                    return desiredItem;
                }
            }            
        }
        var bNeedsAmmo = this.needsAmmo(_body);
        var objects = this.getTypes([
            ObjectType.CAR,
            ObjectType.TANK,
            ObjectType.HELICOPTER,
            ObjectType.MOUNTED_WEAPON,
            ObjectType.REVIVER,
            ObjectType.CRATE,
            ObjectType.EQUIPMENT
        ]);
        loop: for (var i = 0; i < objects.length; i ++)
        {
            let obj = objects[i];
            if (!obj.data || obj.data.bDisabled || obj.data.bPendingRemoval)
            {
                continue;
            }
            switch (obj.data.type)
            {
                case ObjectType.REVIVER:
                    if (obj.data.team != data.team)
                    {
                        continue loop;
                    }
                    break;
                case ObjectType.CRATE:
                    if (obj.data.crateType == Crate.STORE || obj.data.crateType == Crate.BOMB || obj.data.crateType == Crate.BOMB_GENERIC)
                    {
                        break;
                    }
                    else if (bNeedsAmmo && obj.data.crateType == Crate.AMMO)
                    {
                        break;
                    }
                    else
                    {
                        continue loop;
                    }
                    break;
                case ObjectType.EQUIPMENT:
                    if (bNeedsAmmo && obj.data.weaponData.id == "ammo_box")
                    {
                        break;
                    }
                    else
                    {
                        continue loop;
                    }
                    break;
            }
            let itemData = obj.data.itemData;
            if (itemData)
            {
                if (itemData.interactTeam != null && itemData.interactTeam != data.team)
                {
                    continue;
                }
            }
            if ((this.DistBodies(_body, obj) < 500) && obj.getAABB().overlaps(_body.getAABB()))
            {
                return obj;
            }
        }
        return null;
    }

    getInteractables()
    {
        var arr = [];
        var keys = Object.keys(this.game.objects);
        for (var i = 0; i < keys.length; i++)
        {
            var cur = this.game.objects[keys[i]];
            if (cur.data)
            {
                switch (cur.data.type)
                {
                    case ObjectType.CAR:
                    case ObjectType.HELICOPTER:
                    case ObjectType.TANK:
                    case ObjectType.MOUNTED_WEAPON:
                        if (cur.data.health && this.hasAvailableSeat(cur))
                        {
                            arr.push(cur);
                        }
                        break;
                    case ObjectType.CRATE:
                    case ObjectType.DROPPED_WEAPON:
                    case ObjectType.DOOR:
                    case ObjectType.LEVER:
                    case ObjectType.REVIVER:
                        arr.push(cur);
                        break;
                    case "equipment":
                        if (cur.data.weaponData.id == "ammo_box")
                        {
                            arr.push(cur);
                        }
                        break;
                }
            }
        }
        arr.sort((a, b) =>
        {
            var valA = a.data.value != null ? a.data.value : -1;
            var valB = b.data.value != null ? b.data.value : -1;
            if (valA > valB) return -1;
            if (valA < valB) return 1;
            return 0;
        })
        return arr;
    }

    getInteractableForPawn(_body)
    {
        var objects = this.getInteractables();
        for (var i = 0; i < objects.length; i++)
        {
            var obj = objects[i];
            var data = obj.data;
            if (!data.bPendingRemoval)
            {
                if (data.itemData && data.itemData.interactTeam != null)
                {
                    if (data.itemData.interactTeam != _body.data.team)
                    {
                        continue;
                    }
                }
                if (obj.getAABB().overlaps(_body.getAABB()))
                {
                    if (this.isVehicle(obj) && !this.hasAvailableSeat(obj))
                    {
                        continue;
                    }
                    return obj;
                }
            }
        }
        return null;
    }

    stopCharacterInteract(_pawn)
    {
        if (!_pawn)
        {
            return;
        }
        var data = _pawn.data;
        if (!data)
        {
            return;
        }
        if (data.interactableId)
        {
            var interactable = this.getObjectById(data.interactableId);
            if (interactable && interactable.data.bLimitInteractions)
            {
                delete interactable.data.currentPawnId;
            }
        }
        data.bInteracting = false;
        delete data.interactableId;
        delete data.interactTimer;
        this.requestEvent({
            eventId: GameServer.EVENT_PAWN_ACTION,
            pawnId: data.id,
            type: GameServer.PAWN_END_INTERACTION
        });
        var curItem = this.getCurrentCharacterInventoryItem(_pawn);
        if (curItem)
        {
            if (curItem.mag == 0 && curItem.ammo > 0)
            {
                this.reloadCharacterWeapon(_pawn);
            }
        }
    }

    characterCanCrouch(_body)
    {
        var data = _body.data;
        if (data.bBot)
        {
            return false;
        }
        return true;
    }

    characterCanSprint(_body)
    {
        var data = _body.data;
        return !data.bCrouching && data.bWantsToMove && !data.bStunned && !data.bFlashed && !data.controllableId;
    }

    characterCanClimb(_body)
    {
        var data = _body.data;
        if (data.controllableId)
        {
            return false;
        }
        if (!data.bBot)
        {
            return false;
        }
        return !data.bUseDelay && !data.bEquipmentDelay && !data.bCrouching && !data.controllableId;
    }

    onStartWeaponFire(_body)
    {
        var cur = this.getCurrentCharacterInventoryItem(_body);
        if (cur)
        {
            switch (cur.id)
            {
                case "flamethrower":
                case "minigun":
                    this.requestEvent({
                        eventId: GameServer.EVENT_PAWN_ACTION,
                        pawnId: _body.data.id,
                        type: GameServer.PAWN_START_FLAME
                    });
                    _body.data.weapon.bStartFlame = true;
                    break;
            }
        }
    }

    onEndWeaponFire(_body)
    {
        var cur = this.getCurrentCharacterInventoryItem(_body);
        if (cur)
        {
            switch (cur.id)
            {
                //TODO
            }
        }
    }

    hasMeleeEquipped(_body)
    {
        var item = this.getCurrentCharacterInventoryItem(_body);
        if (item)
        {
            return this.isMeleeWeapon(item);
        }
        return false;
    }

    getCurrentCharacterInventoryItem(_body, _bBarrel = true)
    {
        if (!_body || !_body.data)
        {
            return null;
        }
        var item = _body.data.inventory[_body.data.currentInventoryIndex];
        if (_bBarrel)
        {
            if (item && item.bBarrel && item.barrel)
            {
                return item.barrel;
            }
        }
        return item;
    }

    getCharacterInventoryItemIndex(_body, _itemId)
    {
        var inventory = _body.data.inventory;
        for (var i = 0; i < inventory.length; i++)
        {
            var item = inventory[i];
            if (item && item.id == _itemId)
            {
                return i;
            }
        }
        return -1;
    }

    hasItemInInventory(_body, _itemId)
    {
        var index = this.getCharacterInventoryItemIndex(_body, _itemId);
        return index >= 0;
    }

    reloadCharacterWeapon(_body, _bManual)
    {
        if (this.characterCanReload(_body))
        {
            var data = _body.data;
            var item = this.getCurrentCharacterInventoryItem(_body, false);
            data.reloadTimer = Math.round(data.reloadTimerMax * data.reloadMultiplier);
            data.bReloading = true;
            this.requestEvent({
                eventId: GameServer.EVENT_PAWN_ACTION,
                pawnId: data.id,
                type: GameServer.PAWN_RELOAD,
                bManual: _bManual,
                bBarrel: item && item.bBarrel
            });
        }
    }

    seatCanInput(_body)
    {
        var seat = this.getSeatData(_body);
        if (seat)
        {
            return seat.bInput;
        }
        return true;
    }

    characterCanReload(_body)
    {
        var data = _body.data;
        var ps = this.getPlayerById(data.id);
        if (!this.seatCanInput(_body))
        {
            return false;
        }
        var item = this.getCurrentCharacterInventoryItem(_body);
        if (item && item.bMelee)
        {
            return false;
        }
        var weapon = data.weapon;
        var bAmmoCheck = item && (item.mag < item.magSize) && (item.ammo > 0 || weapon.bUnlimitedAmmo);
        return !data.bInteracting && !this.characterHasWeaponDelay(_body) && !data.bReloading && bAmmoCheck;
    }

    triggerCharacterEquipment(_data, _slot)
    {
        if (!this.matchInProgress())
        {
            return;
        }
        var pawn = this.getObjectById(_data.playerId);
        if (pawn)
        {
            var item = pawn.data[_slot];
            if (item)
            {
                if (item.ammo > 0)
                {
                    this.useCharacterEquipment(pawn, _slot, _data.worldX, _data.worldY);
                }
                else
                {
                    switch (item.id)
                    {
                        case "c4":
                            var grenades = this.getGrenades(pawn.data.id, "c4");
                            for (var i = 0; i < grenades.length; i++)
                            {
                                this.detonate(grenades[i]);
                            }
                            break;
                        case "blowtorch":
                            this.requestEvent({
                                eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                                pawnId: pawn.data.id,
                                type: GameServer.INV_CURRENT_INVENTORY_INDEX,
                                value: Character.INDEX_EQUIPMENT
                            });
                            break;
                    }
                }
            }
        }
    }

    getNumCharactersOnTeam(_team)
    {
        var world = this.game.world;
        var num = 0;
        var keys = Object.keys(this.game.objects);
        for (var i = 0; i < keys.length; i++)
        {
            var cur = this.game.objects[keys[i]];
            if (cur.data && !cur.data.bPendingRemoval)
            {
                switch (cur.data.type)
                {
                    case ObjectType.CHARACTER:
                        if (cur.data.health && cur.data.team == _team)
                        {
                            num++;
                        }
                        break;
                }
            }
        }
        return num;
    }

    getNumPawnsOnTeam(_team, _bPlayersOnly)
    {
        var num = 0;
        var keys = Object.keys(this.game.objects);
        for (var i = 0; i < keys.length; i++)
        {
            let cur = this.game.objects[keys[i]];
            if (cur.data && cur.data.health && !cur.data.bPendingRemoval)
            {
                if (_bPlayersOnly)
                {
                    if (!this.getPlayerById(cur.data.id))
                    {
                        continue;
                    }
                }
                switch (cur.data.type)
                {
                    case ObjectType.CHARACTER:
                    case ObjectType.DINOSAUR:
                        if (cur.data.team == _team || _team == null)
                        {
                            num++;
                        }
                        break;
                    case ObjectType.EGG:
                        if (cur.data.team == _team || _team == null)
                        {
                            var items = cur.data.items;
                            for (var j = 0; j < items.length; j++)
                            {
                                switch (items[j].type)
                                {
                                    case ObjectType.CHARACTER:
                                    case ObjectType.DINOSAUR:
                                        num++;
                                        break;
                                }
                            }
                        }
                        break;
                }
            }
        }
        return num;
    }

    getNumDinosaursOnTeam(_team, _types)
    {
        var num = 0;
        var keys = Object.keys(this.game.objects);
        for (var i = 0; i < keys.length; i++)
        {
            var cur = this.game.objects[keys[i]];
            if (cur.data)
            {
                switch (cur.data.type)
                {
                    case ObjectType.DINOSAUR:
                        if (cur.data.health && cur.data.team == _team)
                        {
                            if (_types)
                            {
                                if (_types.indexOf(cur.data.dinoType) >= 0)
                                {
                                    num++;
                                }
                            }
                            else
                            {
                                num++;
                            }
                        }
                        break;
                    case ObjectType.EGG:
                        if (cur.data.health && cur.data.team == _team && cur.data.items)
                        {
                            var items = cur.data.items;
                            for (var j = 0; j < items.length; j++)
                            {
                                var curItem = items[j];
                                if (_types)
                                {
                                    if (_types.indexOf(curItem.dinoType) >= 0)
                                    {
                                        num++;
                                    }
                                }
                                else if (curItem.type == ObjectType.DINOSAUR)
                                {
                                    num += cur.data.items.length;
                                }
                            }
                        }
                        break;
                }
            }
        }
        return num;
    }

    getFlames(_playerId)
    {
        var arr = [];
        var keys = Object.keys(this.game.objects);
        for (var i = 0; i < keys.length; i++)
        {
            var cur = this.game.objects[keys[i]];
            if (cur.data && !cur.data.bPendingRemoval)
            {
                if (cur.data.type == ObjectType.FLAME)
                {
                    if (!_playerId || cur.data.playerId == _playerId)
                    {
                        arr.push(cur);
                    }
                }
            }
        }
        return arr;
    }

    getCharactersAndDinosaurs()
    {
        return this.getTypes([ObjectType.CHARACTER, ObjectType.DINOSAUR, ObjectType.FLYING_DINOSAUR]);
    }

    getEggs()
    {
        return this.getTypeArray(ObjectType.EGG);
    }

    getNodeBodies(_position)
    {
        var arr = [];
        var keys = Object.keys(this.game.objects);
        loop: for (var i = 0; i < keys.length; i++)
        {
            let key = keys[i];
            let body = this.game.objects[key];
            let data = body ? body.data : null;   
            if (data && !data.bPendingRemoval)
            {
                if (!body.shapes.length)
                {
                    continue;
                }
                let aabb = body.getAABB();
                if (aabb && !aabb.containsPoint(_position))
                {
                    continue;
                }
                /*
                let dist = this.DistPositions(_position, body.position);     
                switch (data.type)
                {
                    case ObjectType.GROUND:
                        if (dist > 2000)
                        {
                            continue loop;
                        }
                        break;
                    default:
                        if (dist > 500)
                        {
                            continue loop;
                        }
                        break;
                }   
                */
                switch (data.type)
                {
                    case ObjectType.GROUND:
                        if (data.spriteId || data.shape)
                        {
                            arr.push(body);
                        }
                        break;
                    case ObjectType.OBSTACLE:
                    case ObjectType.MOUNTED_WEAPON:
                        arr.push(body);
                        break;
                    case ObjectType.CRATE:
                    case ObjectType.CAR:
                    case ObjectType.TANK:
                        if (body.mass == Number.MAX_VALUE || data.crateType == Crate.BOMB)
                        {
                            arr.push(body);
                        }
                        break;
                    case ObjectType.DOOR:
                        arr.push(body);
                        break;
                }
                if (arr.length > 30)
                {
                    console.warn("Max objects at node", _position, arr.length);
                    break;
                }
            }
        }
        return arr;
    }

    getTypeArray(_val)
    {
        var arr = this.game ? this.game.types[_val] : null;
        if (arr)
        {
            for (var i = arr.length - 1; i >= 0; i --)
            {
                let object = arr[i];
                if (!object || !object.data || object.data.bPendingRemoval)
                {
                    arr.splice(i, 1);
                }
            }
            return arr;
        }
        return [];
    }

    getTypes(_types)
    {
        if (!_types)
        {
            return [];
        }
        var arr = [];        
        for (var i = 0; i < _types.length; i++)
        {
            let types = this.getTypeArray(_types[i]);
            for (var j = 0; j < types.length; j++)
            {
                let object = types[j];
                if (object && object.data && !object.data.bPendingRemoval)
                {
                    arr.push(object);
                }
            }
        }
        return arr;
    }

    getCharacters()
    {
        return this.getTypeArray(ObjectType.CHARACTER);
    }

    getStructures()
    {
        return this.getTypeArray(ObjectType.GROUND);
        var arr = [];
        for (var key in this.game.objects)
        {
            let cur = this.game.objects[key];
            if (cur.data && !cur.data.bPendingRemoval)
            {
                switch (cur.data.type)
                {
                    case ObjectType.GROUND:
                        if (cur.data.spriteId || cur.data.shape)
                        {
                            arr.push(cur);
                        }
                        break;
                }
            }
        }
        return arr;
    }

    getMapStructure()
    {
        for (var key in this.game.objects)
        {
            let cur = this.game.objects[key];
            if (cur.data && cur.data.spriteId == this.game.mapId)
            {
                return cur;
            }
        }
        return null;
    }

    getGrounds()
    {
        var arr = [];
        for (var key in this.game.objects)
        {
            let cur = this.game.objects[key];
            if (cur.data && !cur.data.bPendingRemoval)
            {
                switch (cur.data.type)
                {
                    case ObjectType.GROUND:
                        if (cur.data.width < 20 || cur.data.height < 20)
                        {
                            continue;
                        }
                        arr.push(cur);
                        break;
                }
            }
        }
        return arr;
    }

    getDinosaurs()
    {
        return this.getTypes([ObjectType.DINOSAUR, ObjectType.FLYING_DINOSAUR]);
    }

    getNearbyRequest(_body, _request, _dist = 500, _fromPlayerId = null)
    {
        if (this.game.cinematic)
        {
            return null;
        }        
        var data = _body.data;
        if (data.type != ObjectType.CHARACTER)
        {
            return;
        }
        if (!this.getPlayersOnTeam(data.team))
        {
            return null;
        }
        var chars = this.getCharacters();
        for (var i = 0; i < chars.length; i ++)
        {
            let ally = chars[i];
            if (!ally.data || ally.data.team != data.team)
            {
                continue;
            }
            if (ally.data.id != data.id)
            {
                if (ally.data.currentRequest == _request)
                {
                    if (!data.controllableId || _request == Commands.REQUEST_VEHICLE)
                    {
                        if (data.type == ObjectType.DINOSAUR && (_fromPlayerId && data.playerId != _fromPlayerId))
                        {
                            continue;
                        }
                        var dist = this.Dist(ally.position[0], ally.position[1], _body.position[0], _body.position[1]);
                        if (dist < _dist)
                        {
                            return {
                                dist: dist,
                                position: ally.position
                            }
                        }
                    }
                }
            }
        }
        return null;
    }

    getCharactersOnTeam(_team)
    {
        var arr = [];
        var chars = this.getCharacters();
        for (var i = 0; i < chars.length; i ++)
        {
            let cur = chars[i];
            if (cur.data)
            {
                if (cur.data.team == _team)
                {
                    arr.push(cur);
                }
            }
        }
        return arr;
    }

    hasPawnOccupants(_body)
    {
        if (_body)
        {
            var seats = _body.data.seats;
            if (seats)
            {
                for (var i = 0; i < seats.length; i++)
                {
                    let seat = seats[i];
                    if (seat.pawnId && this.getObjectById(seat.pawnId))
                    {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    getNumHelicoptersOnTeam(_team, _types, _bEnabled)
    {
        var num = 0;
        var helis = this.getHelicopters();
        for (var key in this.game.objects)
        {
            let cur = this.game.objects[key];
            if (cur.data && cur.data.health && !cur.data.bDisabled)
            {
                switch (cur.data.type)
                {
                    case ObjectType.HELICOPTER:
                        if (_team == null || cur.data.team == _team)
                        {
                            if (_types)
                            {
                                if (_types.indexOf(cur.data.vehicleId) >= 0)
                                {
                                    num++;
                                }
                            }
                            else
                            {
                                num++;
                            }
                        }
                        break;
                }
            }
        }
        return num;
    }

    getAttackHelicopters(_playerId)
    {
        var arr = [];
        var helis = this.getTypeArray(ObjectType.HELICOPTER);
        for (var i = 0; i < helis.length; i++)
        {
            let cur = helis[i];
            if (cur.data && cur.data.health)
            {
                switch (cur.data.vehicleId)
                {
                    case Helicopter.APACHE:
                    case Helicopter.COBRA:
                    case Helicopter.KIOWA:
                        if (_playerId)
                        {
                            if (cur.data.playerId == _playerId) arr.push(cur);
                        }
                        else
                        {
                            arr.push(cur);
                        }
                        break;
                }
            }
        }
        return arr;
    }

    getHelicopters(_playerId)
    {
        var arr = [];
        var helis = this.getTypeArray(ObjectType.HELICOPTER);
        for (var i = 0; i < helis.length; i++)
        {
            let cur = helis[i];
            if (cur.data && cur.data.health)
            {
                if (_playerId)
                {
                    if (cur.data.playerId == _playerId) arr.push(cur);
                }
                else
                {
                    arr.push(cur);
                }
            }
        }
        return arr;
    }

    getDoors()
    {
        return this.getTypeArray(ObjectType.DOOR);
    }

    getOpenedDoors()
    {
        var arr = [];
        var doors = this.getDoors();
        for (var i = 0; i < doors.length; i++)
        {
            let cur = doors[i];
            if (cur.data)
            {
                if (!cur.data.bClosed)
                {
                    arr.push(cur);
                }
            }
        }
        return arr;
    }

    getLevers()
    {
        return this.getTypeArray(ObjectType.LEVER);
    }

    getRevivers(_team)
    {
        var arr = [];
        var revivers = this.getTypeArray(ObjectType.REVIVER);
        for (var i = 0; i < revivers.length; i++)
        {
            let cur = revivers[i];
            if (cur.data && !cur.data.bPendingRemoval)
            {
                if (_team == null)
                {
                    arr.push(cur);
                }
                else if (_team == cur.data.team)
                {
                    arr.push(cur);
                }
            }
        }
        return arr;
    }

    getReviverByPlayerId(_playerId)
    {
        var revivers = this.getRevivers();
        if (revivers)
        {
            for (var i = 0; i < revivers.length; i++)
            {
                let reviver = revivers[i];
                if (reviver.data.itemData.playerId == _playerId)
                {
                    return reviver;
                }
            }
        }
        return null;
    }

    getCrates()
    {
        return this.getTypeArray(ObjectType.CRATE);
    }    

    getNearestObjectiveCrate(_body)
    {
        var arr = [];
        var crates = this.getCrates();
        for (var i = 0; i < crates.length; i++)
        {
            let crate = crates[i];
            if (crate.data.crateType == Crate.OBJECTIVE)
            {
                arr.push(crate);
            }
        }
        if (arr.length > 0)
        {
            arr.sort((a, b) =>
            {
                var distA = this.DistBodies(_body, a);
                var distB = this.DistBodies(_body, b);
                if (distA < distB) return -1;
                if (distA > distB) return 1;
                return 0;
            });
            return arr[0];
        }
        return null;
    }

    getStoreCrate()
    {
        var crates = this.getCrates();
        for (var i = 0; i < crates.length; i ++)
        {
            let cur = crates[i];
            if (cur.data)
            {
                if (cur.data.crateType == Crate.STORE)
                {
                    return cur;
                }
            }
        }
        return null;
    }

    getBomb(_team, _num)
    {
        var crates = this.getCrates();
        for (var i = 0; i < crates.length; i++)
        {
            let cur = crates[i];
            if (cur.data)
            {
                if (cur.data.crateType == Crate.STORE && cur.data.team == _team && cur.data.num == _num)
                {
                    return cur;
                }
            }
        }
        return null;
    }

    getRescueZonePosition()
    {
        var pos = this.getCurrentMapData().teamSpawns[0];
        return [pos.x + (pos.w * 0.5), pos.y + (pos.h * 0.5)];
    }

    getRescueZone()
    {
        return this.getObjectById("rescueZone");
    }

    getBombCrates(_team)
    {
        var arr = [];
        var crates = this.getCrates();
        for (var i = 0; i < crates.length; i ++)
        {
            let cur = crates[i];
            if (cur.data)
            {
                if (cur.data.crateType == Crate.BOMB || cur.data.crateType == Crate.BOMB_GENERIC)
                {
                    if (_team != null)
                    {
                        if (cur.data.team == _team)
                        {
                            arr.push(cur);
                        }
                    }
                    else
                    {
                        arr.push(cur);
                    }
                }
            }
        }
        return arr;
    }

    changeTeam(_id)
    {
        var ps = this.getPlayerById(_id);
        if (ps)
        {
            ps.team = ps.team == 0 ? 1 : 0;
            this.setCurrentClass(ps, ps.currentClass);
            this.onEvent({
                eventId: GameServer.EVENT_MESSAGE_ADD,
                data: {
                    bInfofeed: true,
                    message: "STR_X_SWITCHED_TEAM",
                    messageParams: [ps.name]
                }
            });
            this.onEvent({
                eventId: GameServer.EVENT_PLAYER_UPDATE,
                playerId: ps.id,
                data: {
                    team: ps.team
                }
            });
            var pawn = this.getObjectById(_id);
            if (pawn)
            {
                this.setDataValue(pawn, "team", ps.team);
                this.setDataValue(pawn, "avatar", ps.avatar);
                var controllable = this.getObjectById(pawn.data.controllableId);
                if (controllable)
                {
                    this.setDataValue(controllable, "team", ps.team);
                }
                this.killPawn(pawn.data.id);
            }
        }
    }

    playerCanRespawn(_player)
    {
        if (_player && this.game.gameModeData.respawnTeam != null)
        {
            return _player.team == this.game.gameModeData.respawnTeam;
        }
        if (this.game.gameModeData.bAllowRespawns)
        {
            return true;
        }
        return false;
    }

    getDisposableCrates()
    {
        var arr = [];
        var crates = this.getCrates();
        for (var i = 0; i < crates.length; i++)
        {
            let cur = crates[i];
            if (cur.data)
            {
                if (cur.data.bDisposable)
                {
                    arr.push(cur);
                }
            }
        }
        return arr;
    }

    getAmmoItems()
    {
        var arr = [];
        var crates = this.getCrates();        
        for (var i = 0; i < crates.length; i++)
        {
            let cur = crates[i];
            if (cur.data && cur.data.crateType == Crate.AMMO)
            {
                arr.push(cur);
            }
        }
        var ammo = this.getEquipment("ammo_box");
        for (var i = 0; i < ammo.length; i++)
        {
            let cur = ammo[i];
            arr.push(cur);
        }
        return arr;
    }

    getFlagCTF(_team)
    {
        var flags = this.getFlags();
        for (var i = 0; i < flags.length; i++)
        {
            let cur = flags[i];
            if (cur.data && cur.data.team == _team)
            {
                return cur;
            }
        }
        return null;
    }

    getFlagDomination(_num)
    {
        var flags = this.getFlags();
        for (var i = 0; i < flags.length; i++)
        {
            let cur = flags[i];
            if (cur.data && cur.data.num == _num)
            {
                return cur;
            }
        }
        return null;
    }

    getFlags()
    {
        return this.getTypeArray(ObjectType.FLAG);
    }

    getDroppedWeapons()
    {
        return this.getTypeArray(ObjectType.DROPPED_WEAPON);
    }

    getSpawners()
    {
        return this.getTypeArray(ObjectType.SPAWNER);
    }

    getAutomatedTurrets(_playerId)
    {
        var arr = [];
        var mounted = this.getMountedWeapons(_playerId);
        for (var i = 0; i < mounted.length; i++)
        {
            let cur = mounted[i];
            if (cur.data)
            {
                if (cur.data.bAutomated)
                {
                    if (_playerId)
                    {
                        if (cur.data.playerId == _playerId)
                        {
                            arr.push(cur);
                        }
                    }
                    else
                    {
                        arr.push(cur);
                    }
                }
            }
        }
        return arr;
    }

    getMountedWeapons(_playerId)
    {
        var arr = [];
        var mounted = this.getTypeArray(ObjectType.MOUNTED_WEAPON);
        for (var i = 0; i < mounted.length; i++)
        {
            let cur = mounted[i];
            if (cur.data)
            {
                if (_playerId)
                {
                    if (cur.data.playerId == _playerId)
                    {
                        arr.push(cur);
                    }
                }
                else
                {
                    arr.push(cur);
                }
            }
        }
        return arr;
    }

    getNumAutomatedTurrets(_playerId)
    {
        var arr = [];
        var mounted = this.getTypeArray(ObjectType.MOUNTED_WEAPON);
        for (var i = 0; i < mounted.length; i++)
        {
            let cur = mounted[i];
            if (cur.data && cur.data.bAutomated)
            {
                if (_playerId)
                {
                    if (cur.data.playerId == _playerId)
                    {
                        arr.push(cur);
                    }
                }
                else
                {
                    arr.push(cur);
                }
            }
        }
        return arr;
    }

    getNumMountedTurrets(_playerId)
    {
        var arr = [];
        var mounted = this.getTypeArray(ObjectType.MOUNTED_WEAPON);
        for (var i = 0; i < mounted.length; i++)
        {
            let cur = mounted[i];
            if (cur.data && !cur.data.bAutomated)
            {
                if (_playerId)
                {
                    if (cur.data.playerId == _playerId)
                    {
                        arr.push(cur);
                    }
                }
                else
                {
                    arr.push(cur);
                }
            }
        }
        return arr;
    }

    getNumMountedWeaponsOnTeam(_team)
    {
        var num = 0;
        var mounted = this.getTypeArray(ObjectType.MOUNTED_WEAPON);
        for (var i = 0; i < mounted.length; i++)
        {
            let cur = mounted[i];
            if (cur.data && !cur.data.bDisabled)
            {
                if (cur.data.team == _team)
                {
                    num++;
                }
            }
        }
        return num;
    }

    getAvailableVehicles(_body)
    {
        var arr = [];
        for (var key in this.game.objects)
        {
            let cur = this.game.objects[key];
            if (cur.data && cur.data.health && !cur.data.bDisabled && (cur.data.team == -1 || cur.data.team == _body.data.team))
            {
                if (this.isVehicle(cur) && this.hasAvailableSeat(cur))
                {
                    arr.push(cur);
                }
            }
        }
        return arr;
    }

    useItem(_playerId)
    {
        var ps = this.getPlayerById(_playerId);
        if (!ps)
        {
            //return false;
        }
        var pawn = this.getObjectById(_playerId);
        if (!pawn)
        {
            return false;
        }        
        var data = pawn.data;
        var team = ps ? ps.team : data.team;
        var bUse = true;
        var items = ps ? ps.items : data.pawnItems;
        if (items && items.length > 0)
        {
            var itemIndex = ps ? (ps.itemIndex != null ? ps.itemIndex : 0) : 0;
            var itemId = items[itemIndex].id;
            var item = this.getItemData(itemId);
            if (!item)
            {
                console.warn("Invalid item");
                return false;
            }
            if (item.bAirdrop)
            {
                if (this.getNumHelicoptersOnTeam(team, [Helicopter.MH6]) >= 5 || this.getNumHelicoptersOnTeam(team, [Helicopter.SEAKNIGHT, Helicopter.OSPREY]) >= 3)
                {
                    bUse = false;
                }
            }
            if (item.type == ObjectType.TANK && this.getTanks(0, true).length >= (this.game.scenario ? this.settings.maxSurvivalTanks : 1))
            {
                bUse = false;
            }
            if (item.type == ObjectType.CAR && this.getNumCars() >= this.settings.maxSurvivalCars)
            {
                bUse = false;
            }
            if (item.type == ObjectType.MOUNTED_WEAPON && this.getNumMountedWeaponsOnTeam(team) >= this.settings.maxSurvivalTurrets)
            {
                bUse = false;
            }
            if (item.id == Item.BLACKHAWK && this.getNumHelicoptersOnTeam(0, [Helicopter.BLACKHAWK]) >= 2)
            {
                bUse = false;
            }
            if ((item.type == ObjectType.HELICOPTER && !item.bAirdrop) && this.getNumHelicoptersOnTeam(team, [Helicopter.COBRA, Helicopter.APACHE, Helicopter.KIOWA, Helicopter.BLACKHAWK]) >= this.settings.maxSurvivalHelicopters)
            {
                bUse = false;
            }
            if ((item.type == ObjectType.EGG || item.type == ObjectType.DINOSAUR))
            {
                var dinoDamageMults = {
                    1: 0.25,
                    2: 0.25,
                    3: 0.5,
                    4: 0.5
                };
                if (this.getNumDinosaursOnTeam(team) >= this.settings.maxSurvivalDinosaurs)
                {
                    bUse = false;
                }
            }
            if (item.type == "airstrike" && this.game.supportItems.length >= 3)
            {
                bUse = false;
            }
            if (bUse)
            {
                if (item.bAirdrop || item.type == "airstrike")
                {
                    switch (item.id)
                    {
                        case Item.QUAD:
                        case Item.GROWLER:
                        case Item.MRAP:
                        case Item.LAV25:                        
                            var areaSize = 200;
                            break;
                        case Item.ESCORT_AIRDROP:
                        case Item.SUPPORT_AIRDROP:
                        case Item.ABRAMS:
                        case Item.T90:
                            areaSize = 250;
                            break;
                        case Item.AIRSTRIKE:
                            areaSize = 250;
                            break;
                        case Item.AIRSTRIKE_NAPALM:
                            areaSize = 300;
                            break;
                        default:
                            areaSize = 150;
                            break;
                    }
                    var targetPos = item.type == "airstrike" ? pawn.data.lookPos : pawn.position;
                    var area = this.createTriggerArea({
                        position: targetPos,
                        width: areaSize,
                        height: areaSize,
                        team: pawn.data.team,
                        icon: item.id
                    });
                    area.data.destroyTimer = this.game.settings.fps * 6;
                    var emitter = this.createEmitter({
                        position: area.position,
                        attachToId: area.data.id,
                        team: pawn.data.team,
                        opacity: 0.5,
                        gravityX: 20,
                        gravityY: -20,
                        speedMaxX: 20,
                        speedMaxY: -20,
                        bHideWhenPerformanceMode: true
                    });
                }
                var offset = 20;
                switch (itemId)
                {
                    case Item.EGG_COMPY:
                        this.createEgg([pawn.position[0] + (Math.cos(pawn.data.aimRotation) * offset), pawn.position[1] + (Math.sin(pawn.data.aimRotation) * offset)], {
                            eggType: Egg.LARGE,
                            team: pawn.data.team,
                            playerId: _playerId,
                            hatchTimer: 3,
                            items: [
                                {
                                    type: ObjectType.DINOSAUR,
                                    dinoType: Dinosaur.COMPY,
                                    bRegenHealth: true,
                                    bBot: true,
                                    playerId: pawn.data.id,
                                    damageMultipliers: dinoDamageMults
                                },
                                {
                                    type: ObjectType.DINOSAUR,
                                    dinoType: Dinosaur.COMPY,
                                    bRegenHealth: true,
                                    bBot: true,
                                    playerId: pawn.data.id,
                                    damageMultipliers: dinoDamageMults
                                },
                                {
                                    type: ObjectType.DINOSAUR,
                                    dinoType: Dinosaur.COMPY,
                                    bRegenHealth: true,
                                    bBot: true,
                                    playerId: pawn.data.id,
                                    damageMultipliers: dinoDamageMults
                                }
                            ]
                        });
                        break;
                    case Item.EGG_DILO:
                        this.createEgg([pawn.position[0] + (Math.cos(pawn.data.aimRotation) * offset), pawn.position[1] + (Math.sin(pawn.data.aimRotation) * offset)], {
                            eggType: Egg.LARGE,
                            team: pawn.data.team,
                            playerId: _playerId,
                            hatchTimer: 3,
                            items: [
                                {
                                    type: ObjectType.DINOSAUR,
                                    dinoType: Dinosaur.DILO,
                                    bRegenHealth: true,
                                    bBot: true,
                                    botSkill: BotSkill.SKILL_NORMAL,
                                    playerId: pawn.data.id,
                                    damageMultipliers: dinoDamageMults
                                },
                                {
                                    type: ObjectType.DINOSAUR,
                                    dinoType: Dinosaur.DILO,
                                    bRegenHealth: true,
                                    botSkill: BotSkill.SKILL_NORMAL,
                                    bBot: true,
                                    playerId: pawn.data.id,
                                    damageMultipliers: dinoDamageMults
                                }
                            ]
                        });
                        break;
                    case Item.EGG_RAPTOR:
                        this.createEgg([pawn.position[0] + (Math.cos(pawn.data.aimRotation) * offset), pawn.position[1] + (Math.sin(pawn.data.aimRotation) * offset)], {
                            eggType: Egg.LARGE,
                            team: pawn.data.team,
                            playerId: _playerId,
                            hatchTimer: 3,
                            items: [
                                {
                                    type: ObjectType.DINOSAUR,
                                    dinoType: Dinosaur.RAPTOR,
                                    bRegenHealth: true,
                                    bBot: true,
                                    botSkill: BotSkill.SKILL_INSANE,
                                    playerId: pawn.data.id,
                                    damageMultipliers: dinoDamageMults
                                }
                            ]
                        });
                        break;
                    case Item.EGG_NEEDLER:
                        this.createEgg([pawn.position[0] + (Math.cos(pawn.data.aimRotation) * offset), pawn.position[1] + (Math.sin(pawn.data.aimRotation) * offset)], {
                            eggType: Egg.LARGE,
                            team: pawn.data.team,
                            playerId: _playerId,
                            hatchTimer: 3,
                            items: [
                                {
                                    type: ObjectType.DINOSAUR,
                                    dinoType: Dinosaur.NEEDLER,
                                    bRegenHealth: true,
                                    bBot: true,
                                    botSkill: BotSkill.SKILL_HARD,
                                    playerId: pawn.data.id,
                                    damageMultipliers: dinoDamageMults
                                },
                                {
                                    type: ObjectType.DINOSAUR,
                                    dinoType: Dinosaur.NEEDLER,
                                    bRegenHealth: true,
                                    bBot: true,
                                    botSkill: BotSkill.SKILL_HARD,
                                    playerId: pawn.data.id,
                                    damageMultipliers: dinoDamageMults
                                }
                            ]
                        });
                        break;
                    case Item.EGG_ALLOSAURUS:
                        this.createEgg([pawn.position[0] + (Math.cos(pawn.data.aimRotation) * offset), pawn.position[1] + (Math.sin(pawn.data.aimRotation) * offset)], {
                            eggType: Egg.HUGE,
                            team: pawn.data.team,
                            playerId: _playerId,
                            hatchTimer: 5,
                            items: [
                                {
                                    type: ObjectType.DINOSAUR,
                                    dinoType: Dinosaur.ALLOSAURUS,
                                    bRegenHealth: true,
                                    bBot: true,
                                    botSkill: BotSkill.SKILL_INSANE,
                                    playerId: pawn.data.id,
                                    damageMultipliers: dinoDamageMults
                                }
                            ]
                        });
                        break;
                    case Item.EGG_SPINOSAURUS:
                        this.createEgg([pawn.position[0] + (Math.cos(pawn.data.aimRotation) * offset), pawn.position[1] + (Math.sin(pawn.data.aimRotation) * offset)], {
                            eggType: Egg.HUGE,
                            team: pawn.data.team,
                            playerId: _playerId,
                            hatchTimer: 5,
                            items: [
                                {
                                    type: ObjectType.DINOSAUR,
                                    dinoType: Dinosaur.SPINOSAURUS,
                                    bRegenHealth: true,
                                    bBot: true,
                                    botSkill: BotSkill.SKILL_INSANE,
                                    playerId: pawn.data.id,
                                    damageMultipliers: dinoDamageMults
                                }
                            ]
                        });
                        break;
                    case Item.SENTRY:
                    case Item.SENTRY_SAM:
                    case Item.SENTRY_FLAME:
                    case Item.SENTRY_SHOTGUN:
                    case Item.SENTRY_GRENADE:
                    case Item.SENTRY_SNIPER:
                    case Item.SENTRY_RAILGUN:
                        var turret = this.createMountedWeapon([pawn.position[0] + (Math.cos(pawn.data.aimRotation) * offset), pawn.position[1] + (Math.sin(pawn.data.aimRotation) * offset)], {
                            team: data.team,
                            playerId: data.id,
                            vehicleId: itemId.substr(5),
                            bAutomated: true,
                            bUnlimitedAmmo: false
                        });
                        if (this.game.gameModeId == GameMode.EVOLUTION)
                        {
                            this.setDataValue(turret, "ammo", Math.round(turret.data.ammo * 0.25));
                            this.setDataValue(turret, "ammoMax", Math.round(turret.data.ammoMax * 0.25));
                        }
                        break;
                    case Item.M2:
                        var mounted = this.createMountedWeapon([pawn.position[0] + (Math.cos(pawn.data.aimRotation) * offset), pawn.position[1] + (Math.sin(pawn.data.aimRotation) * offset)], {
                            angle: pawn.angle,
                            team: data.team,
                            playerId: data.id,
                            vehicleId: itemId.substr(5),
                            bUnlimitedAmmo: false,
                            ammo: 1000
                        });
                        break;
                    case Item.BGM71:
                        var mounted = this.createMountedWeapon([pawn.position[0] + (Math.cos(pawn.data.aimRotation) * offset), pawn.position[1] + (Math.sin(pawn.data.aimRotation) * offset)], {
                            angle: pawn.angle,
                            team: data.team,
                            playerId: data.id,
                            vehicleId: itemId.substr(5),
                            bUnlimitedAmmo: false,
                            ammo: 20
                        });
                        break;
                    case Item.M242:
                        var mounted = this.createMountedWeapon([pawn.position[0] + (Math.cos(pawn.data.aimRotation) * offset), pawn.position[1] + (Math.sin(pawn.data.aimRotation) * offset)], {
                            angle: pawn.angle,
                            team: data.team,
                            playerId: data.id,
                            vehicleId: itemId.substr(5),
                            bUnlimitedAmmo: false,
                            ammo: 500
                        });
                        break;
                    case Item.COBRA:
                    case Item.BLACKHAWK:
                    case Item.APACHE:
                    case Item.KIOWA:
                        if (this.getAttackHelicopters(data.id).length < 2)
                        {
                            var heli = this.createHelicopter([this.RandomBoolean() ? 0 : this.getMapWidth(), this.RandomBoolean() ? 0 : this.getMapHeight()], {
                                team: data.team,
                                playerId: data.id,
                                vehicleId: itemId.substr(5),
                                bAutomated: true
                            });
                            if (heli)
                            {
                                heli.data.regenThreshold = 0.5;
                                heli.data.enemyThreshold = 600;
                                switch (itemId)
                                {
                                    case Item.KIOWA:
                                        heli.data.bKillOccupantsWhenDestroyed = true;
                                        heli.data.bLeaveWhenNoOccupants = true;
                                        for (var i = 0; i < 2; i++)
                                        {
                                            let wpn = this.getWeaponData(i == 0 ? "m249" : "l115a3");
                                            this.setRandomWeaponMods(wpn);
                                            let char = this.createCharacter({
                                                position: heli.position,
                                                team: data.team,
                                                inventory: [
                                                    {
                                                        id: wpn.id,
                                                        mods: wpn.mods
                                                    }
                                                ],
                                                equipment: "kevlar",
                                                damageMultipliers: {
                                                    1: 0.5,
                                                    2: 0.5,
                                                    3: 0.5,
                                                    4: 0.5
                                                },
                                                bUnlimitedAmmo: true,
                                                bBot: true,
                                                botSkill: BotSkill.SKILL_HARD,
                                                bInteract: false,
                                                bCanInteract: false,
                                                avatarId: AvatarPresets.DINOGEN_RANDOM
                                            });
                                            if (char)
                                            {
                                                char.data.playerId = pawn.data.id;
                                                this.enterVehicle(char, heli, i + 1);
                                            }
                                        }
                                        break;
                                    case Item.BLACKHAWK:
                                        heli.data.bKillOccupantsWhenDestroyed = true;
                                        heli.data.bLeaveWhenNoOccupants = true;
                                        heli.data.seats[1].bInput = true;
                                        delete heli.data.weapons[1][0].weaponData;
                                        heli.data.seats[2].bInput = true;
                                        delete heli.data.weapons[2][0].weaponData;
                                        let soldiers = [
                                            {
                                                weaponId: this.getRandomWeaponByType(Weapon.TYPE_LMG).id,
                                                avatarId: AvatarPresets.DINOGEN_RANDOM
                                            },
                                            {
                                                weaponId: this.getRandomWeaponByType(Weapon.TYPE_LMG).id,
                                                avatarId: AvatarPresets.DINOGEN_RANDOM
                                            },
                                            {
                                                weaponId: "rpg",
                                                avatarId: AvatarPresets.DINOGEN_HEAVY
                                            },
                                            {
                                                weaponId: "rpg",
                                                avatarId: AvatarPresets.DINOGEN_HEAVY
                                            }
                                        ]
                                        for (var i = 0; i < soldiers.length; i++)
                                        {
                                            let soldier = soldiers[i];
                                            let wpn = this.getWeaponData(soldier.weaponId);
                                            this.setRandomWeaponMods(wpn);
                                            let char = this.createCharacter({
                                                position: heli.position,
                                                team: data.team,
                                                inventory: [
                                                    {
                                                        id: wpn.id,
                                                        mods: wpn.mods
                                                    }
                                                ],
                                                equipment: "kevlar",
                                                damageMultipliers: {
                                                    1: 0.5,
                                                    2: 0.5,
                                                    3: 0.5,
                                                    4: 0.5
                                                },
                                                bUnlimitedAmmo: true,
                                                bBot: true,
                                                botSkill: BotSkill.SKILL_INSANE,
                                                bInteract: false,
                                                bCanInteract: false,
                                                pawnName: soldier.name,
                                                avatarId: soldier.avatarId,
                                                avatar: soldier.avatar
                                            });
                                            if (char)
                                            {
                                                char.data.playerId = pawn.data.id;
                                                this.enterVehicle(char, heli, i + 1);
                                            }
                                        }
                                        break;
                                }
                            }
                        }
                        else
                        {
                            bUse = false;
                        }
                        break;
                    case Item.SUPPORT_AIRDROP:
                        var supportItems = [
                            {
                                type: ObjectType.EQUIPMENT,
                                team: data.team,
                                weaponId: "health_box"
                            },
                            {
                                type: ObjectType.EQUIPMENT,
                                team: data.team,
                                weaponId: "trophy",
                                offset: 50
                            },
                            {
                                type: ObjectType.EQUIPMENT,
                                team: data.team,
                                weaponId: this.RandomBoolean() ? "jammer" : "sensor",
                                offset: 50
                            }
                        ];
                        this.createHelicopter([this.RandomBoolean() ? 0 : this.getMapWidth(), this.RandomBoolean() ? 0 : this.getMapHeight()], {
                            team: data.team,
                            playerId: data.id,
                            vehicleId: Helicopter.MH6,
                            weapons: [
                                [
                                    {
                                        id: "m240"
                                    }
                                ]
                            ],
                            bAutomated: true,
                            items: supportItems,
                            destination: this.clone(pawn.position),
                            defendTimer: 5 * this.game.settings.fps
                        });
                        break;
                    case Item.ESCORT_AIRDROP:
                        var ospreyItems = [];
                        for (var i = 0; i < 3; i++)
                        {
                            switch (i)
                            {
                                case 1:
                                    var curItem = {
                                        type: ObjectType.CRATE,
                                        crateType: Crate.WEAPON,
                                        items: [
                                            {
                                                type: ObjectType.DROPPED_WEAPON,
                                                weaponData: this.getRandomWeapon(),
                                                bRandomVelocity: true
                                            },
                                            {
                                                type: ObjectType.DROPPED_WEAPON,
                                                weaponData: this.getRandomWeapon(),
                                                bRandomVelocity: true
                                            },
                                            {
                                                type: ObjectType.DROPPED_WEAPON,
                                                weaponData: this.getRandomWeapon(),
                                                bRandomVelocity: true
                                            },
                                            {
                                                type: ObjectType.DROPPED_WEAPON,
                                                weaponData: this.getRandomWeapon(),
                                                bRandomVelocity: true
                                            },
                                            {
                                                type: ObjectType.DROPPED_WEAPON,
                                                weaponData: this.getRandomWeapon(),
                                                bRandomVelocity: true
                                            }
                                        ]
                                    }
                                    break;
                                case 2:
                                    curItem = {
                                        type: ObjectType.CRATE,
                                        crateType: Crate.ITEM,
                                        itemId: this.getRandomItemId()
                                    };
                                    break;
                                default:
                                    curItem = {
                                        type: ObjectType.CRATE,
                                        crateType: Crate.AMMO
                                    };
                                    break;
                            }
                            ospreyItems.push(curItem);
                        }
                        this.createHelicopter([this.RandomBoolean() ? 0 : this.getMapWidth(), this.RandomBoolean() ? 0 : this.getMapHeight()], {
                            team: data.team,
                            playerId: data.id,
                            vehicleId: Helicopter.OSPREY,
                            bAutomated: true,
                            items: ospreyItems,
                            destination: this.clone(pawn.position),
                            defendTimer: 10 * this.game.settings.fps
                        });
                        break;
                    case Item.AMMO_AIRDROP:
                        var map = this.getCurrentMapData();
                        this.createHelicopter([this.RandomBoolean() ? 0 : this.getMapWidth(), this.RandomBoolean() ? 0 : this.getMapHeight()], {
                            team: data.team,
                            playerId: data.id,
                            vehicleId: Helicopter.MH6,
                            bAutomated: true,
                            items: [
                                {
                                    type: ObjectType.CRATE,
                                    crateType: Crate.AMMO
                                }
                            ],
                            destination: this.clone(pawn.position)
                        });
                        break;
                    case Item.WEAPON_AIRDROP:
                        this.createHelicopter([this.RandomBoolean() ? 0 : this.getMapWidth(), this.RandomBoolean() ? 0 : this.getMapHeight()], {
                            team: data.team,
                            playerId: data.id,
                            vehicleId: Helicopter.MH6,
                            bAutomated: true,
                            items: [
                                {
                                    type: ObjectType.CRATE,
                                    crateType: Crate.WEAPON,
                                    items: [
                                        {
                                            type: ObjectType.DROPPED_WEAPON,
                                            weaponData: this.getRandomWeapon(),
                                            bRandomVelocity: true
                                        },
                                        {
                                            type: ObjectType.DROPPED_WEAPON,
                                            weaponData: this.getRandomWeapon(),
                                            bRandomVelocity: true
                                        },
                                        {
                                            type: ObjectType.DROPPED_WEAPON,
                                            weaponData: this.getRandomWeapon(),
                                            bRandomVelocity: true
                                        },
                                        {
                                            type: ObjectType.DROPPED_WEAPON,
                                            weaponData: this.getRandomWeapon(),
                                            bRandomVelocity: true
                                        },
                                        {
                                            type: ObjectType.DROPPED_WEAPON,
                                            weaponData: this.getRandomWeapon(),
                                            bRandomVelocity: true
                                        }
                                    ]
                                }
                            ],
                            destination: this.clone(pawn.position)
                        });
                        break;
                    case Item.HEAVY_AIRDROP:
                        this.createHelicopter([this.RandomBoolean() ? 0 : this.getMapWidth(), this.RandomBoolean() ? 0 : this.getMapHeight()], {
                            team: data.team,
                            playerId: data.id,
                            vehicleId: Helicopter.MH6,
                            bAutomated: true,
                            items: [
                                {
                                    type: ObjectType.CRATE,
                                    crateType: Crate.WEAPON,
                                    items: [
                                        {
                                            type: ObjectType.DROPPED_WEAPON,
                                            weaponData: this.getRandomHeavyWeapon(),
                                            bRandomVelocity: true
                                        },
                                        {
                                            type: ObjectType.DROPPED_WEAPON,
                                            weaponData: this.getRandomHeavyWeapon(),
                                            bRandomVelocity: true
                                        },
                                        {
                                            type: ObjectType.DROPPED_WEAPON,
                                            weaponData: this.getRandomHeavyWeapon(),
                                            bRandomVelocity: true
                                        }
                                    ]
                                }
                            ],
                            destination: this.clone(pawn.position)
                        });
                        break;
                    case Item.AIRSTRIKE:
                        this.game.supportItems.push({
                            id: itemId,
                            playerId: data.id,
                            position: pawn.data.lookPos ? pawn.data.lookPos : pawn.position,
                            team: data.team,
                            timer: this.game.settings.fps * 5,
                            explosions: [
                                {
                                    timer: this.game.settings.fps * 3
                                },
                                {
                                    timer: this.game.settings.fps * 3.25
                                },
                                {
                                    timer: this.game.settings.fps * 3.5
                                }
                            ],
                            damage: 800,
                            radius: 500
                        });
                        break;
                    case Item.AIRSTRIKE_NAPALM:                        
                        this.game.supportItems.push({
                            id: itemId,
                            playerId: data.id,
                            position: pawn.data.lookPos ? pawn.data.lookPos : pawn.position,
                            team: data.team,
                            timer: this.game.settings.fps * 5,
                            explosions: [
                                {
                                    timer: this.game.settings.fps * 3,
                                    bFire: true
                                },
                                {
                                    timer: this.game.settings.fps * 3.25,
                                    bFire: true
                                },
                                {
                                    timer: this.game.settings.fps * 3.5,
                                    bFire: true
                                }
                            ],
                            damage: 500,
                            radius: 350
                        });
                        break;
                    case Item.ABRAMS:
                    case Item.T90:
                        switch (itemId)
                        {
                            case Item.ABRAMS:
                                var tankType = Tank.ABRAMS;
                                break;
                            case Item.T90:
                                tankType = Tank.T90;
                                break;
                        }
                        this.createHelicopter([this.RandomBoolean() ? 0 : this.getMapWidth(), this.RandomBoolean() ? 0 : this.getMapHeight()], {
                            team: data.team,
                            playerId: data.id,
                            vehicleId: Helicopter.SEAKNIGHT,
                            bAutomated: true,
                            items: [
                                {
                                    type: ObjectType.TANK,
                                    vehicleId: tankType
                                }
                            ],
                            destination: this.clone(pawn.position)
                        });
                        break;
                    case Item.QUAD:
                    case Item.GROWLER:
                    case Item.MRAP:
                    case Item.LAV25:
                        if (this.getCars().length < this.settings.maxSurvivalCars)
                        {
                            var map = this.getCurrentMapData();
                            switch (itemId)
                            {
                                case Item.QUAD:
                                    var carType = Car.QUAD;
                                    break;
                                case Item.GROWLER:
                                    carType = Car.GROWLER;
                                    break;
                                case Item.MRAP:
                                    carType = Car.MRAP;
                                    break;
                                case Item.LAV25:
                                    carType = Car.LAV25;
                                    break;
                            }
                            this.createHelicopter([this.RandomBoolean() ? 0 : this.getMapWidth(), this.RandomBoolean() ? 0 : this.getMapHeight()], {
                                team: data.team,
                                playerId: data.id,
                                vehicleId: Helicopter.SEAKNIGHT,
                                bAutomated: true,
                                items: [
                                    {
                                        type: ObjectType.CAR,
                                        vehicleId: carType
                                    }
                                ],
                                destination: this.clone(pawn.position)
                            });
                        }
                        else
                        {
                            bUse = false;
                        }
                        break;
                    default:
                        console.warn("Unhandled item", itemId);
                        break;
                }
            }
            if (ps)
            {
                if (ps.bBot && !bUse)
                {
                    if (items.length > 1)
                    {
                        ps.itemIndex++;
                        if (ps.itemIndex >= items.length)
                        {
                            ps.itemIndex = 0;
                        }
                    }
                    return false;
                }
            }
            this.onEvent({
                eventId: GameServer.EVENT_USE_ITEM,
                playerId: _playerId,
                itemId: itemId,
                team: team,
                bUnavailable: !bUse
            });
            if (bUse)
            {                
                if (ps)
                {
                    items.splice(ps.itemIndex, 1);
                    ps.itemIndex = Math.max(0, Math.min(ps.items.length - 1, ps.itemIndex));
                    this.requestEvent({
                        eventId: GameServer.EVENT_PLAYER_UPDATE,
                        playerId: ps.id,
                        data: {
                            items: ps.items,
                            itemIndex: ps.itemIndex
                        }
                    });
                }
                else
                {
                    data.pawnItems.splice(0, 1);
                }
            }
            if (pawn)
            {
                data.weapon["bEquipmentDelay"] = true;
                data.weapon["equipmentDelayTimer"] = Math.round(this.game.settings.fps * 0.3);
                this.requestEvent({
                    eventId: GameServer.EVENT_PAWN_ACTION,
                    pawnId: data.id,
                    type: GameServer.PAWN_PLACE_EQUIPMENT,
                    itemId: itemId
                });
            }
        }
        return bUse;
    }

    getDrivableVehicles(_playerId)
    {
        var arr = [];
        var keys = Object.keys(this.game.objects);
        for (var i = 0; i < keys.length; i++)
        {
            let cur = this.game.objects[keys[i]];
            if (cur.data && cur.data.health)
            {
                if (this.isVehicle(cur, false))
                {
                    if (_playerId)
                    {
                        if (cur.data.playerId == _playerId) arr.push(cur);
                    }
                    else
                    {
                        arr.push(cur);
                    }
                }
            }
        }
        return arr;
    }

    onTickRateChanged(_mult)
    {
        console.log("onTickRateChanged", _mult);
        for (var key in this.game.objects)
        {
            let cur = this.game.objects[key];
            if (cur.data && cur.data.health)
            {
                let data = cur.data;
                switch (data.type)
                {
                    case ObjectType.HELICOPTER:
                    case ObjectType.CAR:
                    case ObjectType.TANK:
                        if (data.speed)
                        {
                            data.speed = Math.round(data.speed / _mult);
                        }   
                        break;
                    case ObjectType.FLAG:
                        if (data.captureTimerMax)
                        {
                            this.setDataValue(cur, "captureTimerMax", Math.round(data.captureTimerMax * _mult));
                        }
                        break;
                }
                if (data.regenTimerMax)
                {
                    data.regenTimerMax = Math.round(data.regenTimerMax * _mult);
                }
                if (data.itemData)
                {
                    if (data.itemData.interactTime)
                    {
                        data.itemData.interactTime = Math.round(data.itemData.interactTime * _mult);
                    }
                }
                if (data.destroyTimer)
                {
                    data.destroyTimer = Math.ceil(data.destroyTimer * _mult);
                }
                switch (data.type)
                {
                    case ObjectType.CHARACTER:
                        let inventory = data.inventory;
                        let item = inventory[data.currentInventoryIndex]; 
                        if (item && item.reloadTime)
                        {
                            data.reloadTimerMax = Math.round(Math.ceil(item.reloadTime * this.game.settings.fps) * data.reloadMultiplier);
                            if (data.bReloading)
                            {
                                data.reloadTimer = Math.min(data.reloadTimer, data.reloadTimerMax);
                            }
                            else
                            {
                                data.reloadTimer = data.reloadTimerMax;
                            }
                        }
                        break;
                }
            }
        }
    }

    getVehicles(_playerId)
    {
        var arr = [];
        var vehicles = this.getTypes([
            ObjectType.CAR,
            ObjectType.TANK,
            ObjectType.HELICOPTER,
            ObjectType.MOUNTED_WEAPON
        ]);
        for (var i = 0; i < vehicles.length; i++)
        {
            let cur = vehicles[i];
            if (cur.data && cur.data.health)
            {
                if (_playerId)
                {
                    if (cur.data.playerId == _playerId) arr.push(cur);
                }
                else
                {
                    arr.push(cur);
                }
            }
        }
        return arr;
    }

    getNumCars(_types)
    {
        var num = 0;
        var objects = this.getTypes([ObjectType.CAR, ObjectType.HELICOPTER]);
        for (var i = 0; i < objects.length; i++)
        {
            let cur = objects[i];
            if (cur.data && cur.data.health && !cur.data.bDisabled)
            {
                switch (cur.data.type)
                {
                    case ObjectType.HELICOPTER:
                        if (cur.data.items)
                        {
                            for (var j = 0; j < cur.data.items.length; j++)
                            {
                                let curItem = cur.data.items[i];
                                if (curItem && curItem.type == ObjectType.CAR)
                                {
                                    if (_types)
                                    {
                                        if (_types.indexOf(curItem.vehicleId) >= 0)
                                        {
                                            num++;
                                        }
                                    }
                                    else
                                    {
                                        num++;
                                    }
                                }
                            }
                        }
                        break;
                    case ObjectType.CAR:
                        if (_types)
                        {
                            if (_types.indexOf(cur.data.vehicleId) >= 0)
                            {
                                num++;
                            }
                        }
                        else
                        {
                            num++;
                        }
                        break;
                }
            }
        }
        return num;
    }

    getCars(_types, _team)
    {
        var arr = [];
        var cars = this.getTypeArray(ObjectType.CAR);
        for (var i = 0; i < cars; i++)
        {
            let cur = cars[i];
            if (cur.data && cur.data.health)
            {
                switch (cur.data.type)
                {
                    case ObjectType.CAR:
                        if (_types)
                        {
                            if (_types.indexOf(cur.data.vehicleId) >= 0)
                            {
                                if (_team == null || cur.data.team == _team)
                                {
                                    arr.push(cur);
                                }
                            }
                        }
                        else
                        {
                            if (_team == null || cur.data.team == _team)
                            {
                                arr.push(cur);
                            }
                        }
                        break;
                }
            }
        }
        return arr;
    }

    getTanks(_team, _bIgnoreDisabled)
    {
        var arr = [];
        var objects = this.getTypes([ObjectType.TANK, ObjectType.HELICOPTER]);
        for (var i = 0; i < objects.length; i++)
        {
            let cur = objects[i];
            if (cur.data)
            {                
                switch (cur.data.type)
                {
                    case ObjectType.TANK:
                        if (_bIgnoreDisabled && cur.data.bDisabled)
                        {
                            continue;
                        }
                        if (_team == null || cur.data.team == _team || !this.vehicleHasOccupant(cur))
                        {
                            arr.push(cur);
                        }
                        break;
                    default:
                        let items = cur.data.items;
                        if (items)
                        {
                            for (var j = 0; j < items.length; j++)
                            {
                                let curItem = items[j];
                                if (curItem.type == ObjectType.TANK)
                                {
                                    if (_bIgnoreDisabled && curItem.bDisabled)
                                    {
                                        continue;
                                    }
                                    if (_team == null || cur.data.team == _team)
                                    {
                                        arr.push(cur);
                                    }
                                }
                            }
                        }
                        break;
                }
            }
        }
        return arr;
    }

    getTriggerAreas()
    {
        return this.getTypeArray(ObjectType.TRIGGER_AREA);
    }

    getObstacles()
    {
        return this.getTypeArray(ObjectType.OBSTACLE);
    }

    getTrees()
    {
        return this.getTypeArray(ObjectType.TREE);
    }

    getObstaclesWithHealth(_playerId)
    {
        var arr = [];
        var obstacles = this.getObstacles();
        for (var i = 0; i < obstacles.length; i++)
        {
            let cur = obstacles[i];
            if (cur.data)
            {
                if (!cur.data.bPendingRemoval && cur.data.health && !cur.data.bGodMode)
                {
                    if (!_playerId || _playerId == cur.data.playerId)
                    {
                        arr.push(cur);
                    }
                }
            }
        }
        return arr;
    }

    hasNearbyJammer(_body)
    {
        var equipment = this.getEquipment("jammer");
        for (var i = 0; i < equipment.length; i++)
        {
            let cur = equipment[i];
            if (cur.data)
            {
                if (cur.data.team != _body.data.team)
                {
                    if (this.DistBodies(_body, cur) <= (cur.data.weaponData.radius * 0.5))
                    {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    hasNearbyMotionSensor(_body)
    {
        var equipment = this.getEquipment("sensor");
        for (var i = 0; i < equipment.length; i++)
        {
            let cur = equipment[i];
            if (cur.data)
            {
                if (cur.data.team != _body.data.team)
                {
                    if (this.DistBodies(_body, cur) <= (cur.data.weaponData.radius * 0.5) && this.checkLineOfSight(_body.position[0], _body.position[1], cur.position[0], cur.position[1]))
                    {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    getMines(_team)
    {
        var arr = [];
        var equipment = this.getEquipment();
        for (var i = 0; i < equipment.length; i++)
        {
            let cur = equipment[i];
            if (cur.data && cur.data.weaponData.bMine)
            {
                arr.push(cur);
            }
        }
        return arr;
    }

    getEquipment(_weaponId)
    {
        var arr = [];
        var equipment = this.getTypeArray(ObjectType.EQUIPMENT);
        for (var i = 0; i < equipment.length; i++)
        {
            var cur = equipment[i];
            if (cur.data)
            {
                if (!_weaponId || cur.data.weaponData.id == _weaponId)
                {
                    arr.push(cur);
                }
            }
        }
        return arr;
    }

    ejectFlare(_body, _rocket)
    {
        var data = _body.data;
        var weaponData = this.getWeaponData("rocket_flare");
        this.createRocket(_body.position, {
            rocketType: Rocket.DEFAULT,
            team: data.team,
            playerId: data.playerId ? data.playerId : data.id,
            causerId: data.id,
            angle: _rocket ? this.Angle(_body.position[0], _body.position[1], _rocket.position[0], _rocket.position[1]) + this.ToRad(90) : this.RandomAngle(),
            weaponId: weaponData.id,
            damage: weaponData.damage,
            radius: weaponData.radius
        });
    }

    getIncomingGuidedRocket(_body)
    {
        var rockets = this.getRockets();
        for (var i = 0; i < rockets.length; i++)
        {
            let cur = rockets[i];
            let data = cur.data;
            if (data)
            {
                if (data.enemyId == _body.data.id)
                {
                    if (this.DistBodies(_body, cur) < 1500)
                    {
                        return cur;
                    }
                }
            }
        }
        return null;
    }

    getNearbyFlare(_body)
    {
        var rockets = this.getRockets();
        for (var i = 0; i < rockets.length; i++)
        {
            let cur = rockets[i];
            if (cur.data)
            {
                if (cur.data.weaponId == "rocket_flare" && cur.data.team != _body.data.team)
                {
                    if (this.DistBodies(_body, cur) < 1500)
                    {
                        return cur;
                    }
                }
            }
        }
        return null;
    }

    getRockets()
    {
        return this.getTypeArray(ObjectType.ROCKET);
    }

    getSmokeGrenades()
    {
        var arr = [];
        var grenades = this.getGrenades(null, "smoke");
        for (var i = 0; i < grenades.length; i++)
        {
            let cur = grenades[i];
            if (cur.data)
            {
                if (cur.data.weaponId == "smoke" && cur.data.bActivated)
                {
                    arr.push(cur);
                }
            }
        }
        return arr;
    }

    getGrenades(_playerId, _weaponId)
    {
        var arr = [];
        var grenades = this.getTypeArray(ObjectType.GRENADE);
        for (var i = 0; i < grenades.length; i++)
        {
            var cur = grenades[i];
            if (cur.data)
            {
                if (_weaponId && cur.data.weaponId != _weaponId)
                {
                    continue;
                }
                if (_playerId)
                {
                    if (_playerId == cur.data.playerId)
                    {
                        arr.push(cur);
                    }
                }
                else
                {
                    arr.push(cur);
                }
            }
        }
        return arr;
    }

    useCharacterEquipment(_body, _slot, _worldX, _worldY)
    {
        if (!this.characterCanUseEquipment(_body, _slot))
        {
            return;
        }
        var data = _body.data;
        var item = data[_slot];
        var bUse = true;
        var equipmentRot = data.desiredAimRotation ? data.desiredAimRotation : data.aimRotation;
        switch (item.type)
        {
            case Weapon.TYPE_GRENADE:
                data.weapon.bThrowDelay = true;
                data.weapon.throwDelayTimer = Math.round(this.game.settings.fps * 0.4);
                var velocity = Math.min(1200, this.Dist(_worldX, _worldY, _body.position[0], _body.position[1]) * 1.5);
                var offset = 50; //60;
                var grenadeRad = data.bBot ? this.Angle(_body.position[0], _body.position[1], _worldX, _worldY) : equipmentRot;
                this.createGrenade([_body.position[0] + (Math.cos(grenadeRad) * offset), _body.position[1] + (Math.sin(grenadeRad) * offset)], {
                    team: data.team,
                    playerId: data.id,
                    causerId: data.id,
                    rotation: grenadeRad,
                    velocity: velocity,
                    damage: item.damage,
                    weaponData: item,
                    weaponId: item.id,
                    bStartDetonationAfterHit: item.bStartDetonationAfterHit,
                    bImpact: item.bImpact
                });
                this.requestEvent({
                    eventId: GameServer.EVENT_PAWN_ACTION,
                    pawnId: data.id,
                    type: GameServer.PAWN_THROW_GRENADE,
                    weaponId: item.id
                });
                break;

            default:
                switch (item.id)
                {
                    case "blowtorch":
                        console.log(item);
                        break;
                    case "ammo_box":
                        var ammoBox = this.createEquipment(this.clone(_body.position), {
                            team: data.team,
                            angle: data.aimRotation,
                            ownerId: data.id,
                            weaponData: item,
                            itemData: {
                                uses: 10,
                                maxUses: 10,
                                interactTime: 0.5
                            }
                        });
                        ammoBox.data.destroyTimer = this.game.settings.fps * 180;
                        var force = Math.min(400, this.Dist(_worldX, _worldY, _body.position[0], _body.position[1]) * 5);
                        ammoBox.applyImpulse([Math.cos(equipmentRot) * force, Math.sin(equipmentRot) * force], 0, 0);
                        data.weapon.bThrowDelay = true;
                        data.weapon.throwDelayTimer = Math.round(this.game.settings.fps * 0.5);
                        this.requestEvent({
                            eventId: GameServer.EVENT_PAWN_ACTION,
                            pawnId: data.id,
                            type: GameServer.PAWN_THROW_GRENADE,
                            weaponId: item.id
                        });
                        break;

                    case "molotov":
                        data.weapon.bThrowDelay = true;
                        data.weapon.throwDelayTimer = Math.round(this.game.settings.fps * 0.4);
                        var velocity = Math.min(1200, this.Dist(_worldX, _worldY, _body.position[0], _body.position[1]) * 2);
                        offset = 0; //60;
                        var grenadeRad = data.bBot ? this.Angle(_body.position[0], _body.position[1], _worldX, _worldY) : equipmentRot;
                        this.createGrenade([_body.position[0] + (Math.cos(grenadeRad) * offset), (_body.position[1] - 30) + (Math.sin(grenadeRad) * offset)], {
                            team: data.team,
                            playerId: data.id,
                            causerId: data.id,
                            rotation: grenadeRad,
                            velocity: velocity,
                            damage: item.damage,
                            weaponData: item,
                            weaponId: item.id,
                            bStartDetonationAfterHit: item.bStartDetonationAfterHit,
                            bImpact: item.bImpact
                        });
                        this.requestEvent({
                            eventId: GameServer.EVENT_PAWN_ACTION,
                            pawnId: data.id,
                            type: GameServer.PAWN_THROW_GRENADE,
                            weaponId: item.id
                        });
                        break;

                    case "c4":
                        let curC4s = this.getGrenades(data.id, "c4");
                        if (curC4s.length >= 4)
                        {
                            this.removeNextStep(curC4s[0]);
                        }
                        data.weapon.bThrowDelay = true;
                        data.weapon.throwDelayTimer = Math.round(this.game.settings.fps * 0.3);
                        var velocity = Math.min(600, this.Dist(_worldX, _worldY, _body.position[0], _body.position[1]) * 4);
                        offset = 0; //60;
                        this.createGrenade([_body.position[0] + (Math.cos(equipmentRot) * offset), _body.position[1] + (Math.sin(equipmentRot) * offset)], {
                            team: data.team,
                            playerId: data.id,
                            causerId: data.id,
                            rotation: equipmentRot,
                            velocity: velocity,
                            weaponData: item,
                            damage: item.damage,
                            weaponId: item.id
                        });
                        this.requestEvent({
                            eventId: GameServer.EVENT_PAWN_ACTION,
                            pawnId: data.id,
                            type: GameServer.PAWN_THROW_GRENADE,
                            weaponId: item.id
                        });
                        break;

                    case "juice":
                        this.setDataValue(_body, "health", Math.max(data.health, data.maxHealth * 0.5));
                        this.setDataValue(_body, "bJuiced", true);
                        this.setDataValue(_body, "reloadMultiplier", 0.5);
                        data.juiceTimer = this.game.settings.fps * (this.game.bSurvival ? 10 : 5);
                        data.weapon.bThrowDelay = true;
                        data.weapon.throwDelayTimer = Math.round(this.game.settings.fps * 0.5);
                        this.requestEvent({
                            eventId: GameServer.EVENT_PAWN_ACTION,
                            pawnId: data.id,
                            type: GameServer.PAWN_USE_STIM,
                            weaponId: item.id
                        });
                        break;

                    case "stim":
                        if (data.health >= data.maxHealth)
                        {
                            bUse = false;
                            var ally = this.getNearestFriendlyPawn(_body, { maxRange: 100, bInjured: true, pawnTypes: [ObjectType.CHARACTER, ObjectType.DINOSAUR, ObjectType.FLYING_DINOSAUR] });
                            if (ally)
                            {
                                bUse = true;
                                var allyData = ally.data;
                                allyData.health = allyData.maxHealth;
                                this.pushObjectDataUpdate(allyData.id, ["health"]);
                                data.weapon.bThrowDelay = true;
                                data.weapon.throwDelayTimer = Math.round(this.game.settings.fps * 0.5);
                                this.requestEvent({
                                    eventId: GameServer.EVENT_PAWN_ACTION,
                                    pawnId: data.id,
                                    type: GameServer.PAWN_USE_STIM,
                                    bAlly: true
                                });
                                this.requestEvent({
                                    eventId: GameServer.EVENT_PAWN_ACTION,
                                    pawnId: allyData.id,
                                    type: GameServer.PAWN_RECEIVE_STIM
                                });
                            }
                        }
                        else
                        {
                            data.health = data.maxHealth;
                            this.pushObjectDataUpdate(data.id, ["health"]);
                            data.weapon.bThrowDelay = true;
                            data.weapon.throwDelayTimer = Math.round(this.game.settings.fps * 0.5);
                            this.requestEvent({
                                eventId: GameServer.EVENT_PAWN_ACTION,
                                pawnId: data.id,
                                type: GameServer.PAWN_USE_STIM,
                                weaponId: item.id
                            });
                        }
                        break;

                    case "knife":
                    case "spear":
                        data.weapon.bThrowDelay = true;
                        data.weapon.throwDelayTimer = Math.round(this.game.settings.fps * 0.5);
                        var velocity = 200;
                        var offset = 0;
                        this.createProjectile([_body.position[0] + (Math.cos(equipmentRot) * offset), _body.position[1] + (Math.sin(equipmentRot) * offset)], equipmentRot, data.team, {
                            playerId: data.id,
                            causerId: data.id,
                            rotation: equipmentRot,
                            velocity: velocity,
                            damage: item.damage,
                            weaponId: item.id
                        });
                        this.requestEvent({
                            eventId: GameServer.EVENT_PAWN_ACTION,
                            pawnId: data.id,
                            type: GameServer.PAWN_THROW_GRENADE,
                            weaponId: item.id
                        });
                        break;

                    case "deployable_cover":
                        var deployables = this.getObstaclesWithHealth(data.id);
                        if (deployables.length >= 2)
                        {
                            this.removeNextStep(deployables[0])
                        }
                        data.weapon.bEquipmentDelay = true;
                        data.weapon.equipmentDelayTimer = Math.round(this.game.settings.fps * 0.3);
                        offset = 30;
                        this.createObstacle({
                            type: ObjectType.OBSTACLE,
                            position: [_body.position[0] + (Math.cos(equipmentRot) * offset), _body.position[1] + (Math.sin(equipmentRot) * offset)],
                            angle: data.aimRotation,
                            obstacleId: "deployable_cover",
                            playerId: data.id,
                            health: this.game.bSurvival ? 5000 : 1000
                        });
                        this.requestEvent({
                            eventId: GameServer.EVENT_PAWN_ACTION,
                            pawnId: data.id,
                            type: GameServer.PAWN_PLACE_EQUIPMENT,
                            weaponId: item.id
                        });
                        break;

                    default:
                        if (item.id == "beacon" || item.id == "tac_insert")
                        {
                            this.removeEquipmentByPlayerId(data.id, item.id);
                        }
                        if (item.bPassive)
                        {
                            bUse = false;
                        }
                        else if (item.bThrowable)
                        {
                            data.weapon.bThrowDelay = true;
                            data.weapon.throwDelayTimer = Math.round(this.game.settings.fps * 0.3);
                            var throwable = this.createEquipment(this.clone(_body.position), {
                                team: data.team,
                                angle: data.aimRotation,
                                ownerId: data.id,
                                weaponData: item
                            });
                            if (throwable)
                            {
                                var force = Math.min(400, this.Dist(_worldX, _worldY, _body.position[0], _body.position[1]) * 4);
                                var rad = equipmentRot;
                                throwable.applyImpulse([Math.cos(rad) * force, Math.sin(rad) * force], 0, 0);
                            }
                            this.requestEvent({
                                eventId: GameServer.EVENT_PAWN_ACTION,
                                pawnId: data.id,
                                type: GameServer.PAWN_THROW_GRENADE,
                                weaponId: item.id
                            });
                        }
                        else
                        {
                            data.weapon.bEquipmentDelay = true;
                            data.weapon.equipmentDelayTimer = Math.round(this.game.settings.fps * 0.3);
                            var placeablePos = [_body.position[0], _body.position[1]];
                            this.createEquipment(placeablePos, {
                                team: data.team,
                                angle: data.aimRotation,
                                ownerId: data.id,
                                weaponData: item
                            });
                            this.requestEvent({
                                eventId: GameServer.EVENT_PAWN_ACTION,
                                pawnId: data.id,
                                type: GameServer.PAWN_PLACE_EQUIPMENT,
                                weaponId: item.id
                            });
                        }
                        break;
                }
                break;
        }
        if (!bUse)
        {
            return;
        }
        this.cancelCharacterReload(_body);
        this.cancelCharacterBoltPull(_body);
        //if (data.bBot || !data.weapon.bUnlimitedAmmo)
        item.ammo--;
        this.requestEvent({
            eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
            pawnId: data.id,
            type: GameServer.INV_EQUIPMENT,
            slot: _slot
        });
    }

    deployParachute(_body)
    {
        var data = _body.data;
        if (!data.bParachute)
        {
            this.cancelCharacterBoltPull(_body);
            this.cancelCharacterReload(_body);
            data.bParachute = true;
            _body.damping = this.getSharedData(ObjectType.CHARACTER).parachuteDamping;
            this.requestEvent({
                eventId: GameServer.EVENT_PAWN_ACTION,
                pawnId: data.id,
                type: GameServer.PAWN_PARACHUTE,
                value: true
            });
        }
    }

    removeParachute(_body)
    {
        var data = _body.data;
        if (data.bParachute)
        {
            data.bParachute = false;
            _body.damping = this.getSharedData(ObjectType.CHARACTER).damping;
            this.requestEvent({
                eventId: GameServer.EVENT_PAWN_ACTION,
                pawnId: data.id,
                type: GameServer.PAWN_PARACHUTE,
                value: false
            });
        }
    }

    triggerCharacterWeapon(_data)
    {
        var value = _data.value;
        if (this.matchHasEnded())
        {
            value = false;
        }
        var pawn = this.getObjectById(_data.playerId);
        var ps = this.getPlayerById(_data.playerId);
        var controllable = ps ? this.getObjectById(ps.controllableId) : null;
        if (controllable)
        {
            switch (controllable.data.type)
            {
                case ObjectType.ROCKET:
                    if (value)
                    {
                        this.detonate(controllable);
                    }
                    return;

                case ObjectType.MOUNTED_WEAPON:
                case ObjectType.HELICOPTER:
                case ObjectType.TANK:
                case ObjectType.CAR:
                    if (pawn && pawn.data.seatIndex != null)
                    {
                        var weapons = controllable.data.weapons;
                        if (weapons)
                        {
                            var weapon = this.getCurrentVehicleWeapon(controllable, pawn.data.seatIndex);
                            if (weapon)
                            {
                                weapon.bWantsToFire = value && !pawn.data.seatTimer;
                                if (value && !pawn.data.bBot && weapon.ammo != null && weapon.ammo == 0)
                                {
                                    this.requestEvent({
                                        eventId: GameServer.EVENT_PAWN_ACTION,
                                        pawnId: pawn.data.id,
                                        type: GameServer.PAWN_NO_AMMO
                                    });
                                }
                            }
                        }
                        var seat = this.getSeatData(pawn);
                        if (!seat || !seat.bInput)
                        {
                            return;
                        }
                    }
                    break;
            }
        }
        if (pawn)
        {
            if (_data["worldPosition"])
            {
                pawn.data["inputPosition"] = _data["worldPosition"];
            }            
            if (_data.value && !pawn.data.seatTimer)
            {
                var bPrev = pawn.data.bWantsToFire;
                pawn.data.bWantsToFire = true;
                var cur = this.getCurrentCharacterInventoryItem(pawn);
                if (cur && cur.mag > 0)
                {
                    if (!bPrev && !pawn.data.bReloading)
                    {
                        this.onStartWeaponFire(pawn);
                    }
                    pawn.data.weapon.bFireHandler = true;
                }
                else
                {
                    if (cur && cur.ammo == 0 && !pawn.data.weapon.bUnlimitedAmmo)
                    {
                        var actual = this.getCurrentCharacterInventoryItem(pawn, false);
                        if (actual.bBarrel)
                        {
                            this.toggleUnderbarrelEquipped(pawn);
                        }
                        else if (pawn.data.bBot)
                        {
                            var otherIndex = pawn.data.currentInventoryIndex == 1 ? 0 : 1;
                            var otherItem = pawn.data.inventory[otherIndex];
                            if (otherItem)
                            {
                                if (otherItem.mag > 0 || otherItem.ammo > 0)
                                {
                                    this.requestEvent({
                                        eventId: GameServer.EVENT_PLAYER_UPDATE_INVENTORY,
                                        pawnId: pawn.data.id,
                                        type: GameServer.INV_CURRENT_INVENTORY_INDEX,
                                        value: otherIndex
                                    });
                                }
                            }
                        }
                        if (!pawn.data.bBot)
                        {
                            if (this.characterIsFree(pawn))
                            {
                                this.requestEvent({
                                    eventId: GameServer.EVENT_PAWN_ACTION,
                                    pawnId: pawn.data.id,
                                    type: GameServer.PAWN_NO_AMMO
                                });
                            }
                        }
                    }
                    else
                    {
                        this.reloadCharacterWeapon(pawn);
                    }
                }
            }
            else
            {
                if (pawn.data.bWantsToFire)
                {
                    this.onEndWeaponFire(pawn);
                }
                pawn.data.bWantsToFire = false;
            }
        }
    }

    onPlayerKill(_playerId, _damageAmount, _victimId, _causerId, _damageInfo)
    {
        var game = this.game;
        var causer = this.getObjectById(_causerId);
        var ps = this.getPlayerById(_playerId);        
        var killer = this.getObjectById(_playerId);    
        if (!ps && killer && killer.data.playerId)
        {
            ps = this.getPlayerById(killer.data.playerId);
        }
        if (!ps && killer && this.game.scenario)
        {
            ps = {
                id: _playerId,
                team: killer.data.team
            };
        }
        var bSuicide = _playerId == _victimId;
        var bAddToKills = true;
        var victim = this.getObjectById(_victimId);
        if (ps)
        {
            var killedBy = ps.killedBy;
            if (killedBy)
            {
                var index = killedBy.indexOf(_victimId);
                if (index >= 0)
                {
                    var bRevenge = true;
                    killedBy.splice(index);
                }
            }
            var bTeamKill = !bSuicide && (victim ? ps.team == victim.data.team : false);
            if (!bSuicide && !bTeamKill)
            {
                var bVictimIsCharacter = victim ? (victim.data.type == ObjectType.CHARACTER || victim.data.type == ObjectType.DINOSAUR || victim.data.type == ObjectType.DUMMY) : false;
                bAddToKills = bVictimIsCharacter;
                if (bAddToKills)
                {
                    ps.kills++;
                    if (_damageInfo.bHeadshot)
                    {
                        ps.headshots++;
                    }
                    if (_damageInfo.bMelee)
                    {
                        ps.melees++;
                    }
                    ps.multiKillTimer = this.game.settings.fps;
                    if (!ps.multiKillCount)
                    {
                        ps.multiKillCount = 0;
                    }
                    ps.multiKillCount++;
                    if (ps.bBot && this.Random(1, 10 - ps.botSkill) == 1)
                    {
                        this.setPawnRequest(this.getObjectById(ps.id), Commands.TAUNT);
                    }
                    var victimPlayerState = this.getPlayerById(_victimId);
                    if (this.isTeamGameMode())
                    {
                        ps.avengerTimer = this.game.settings.fps * 3;
                        if (victimPlayerState)
                        {
                            if (victimPlayerState.avengerTimer > 0)
                            {
                                var bAvenger = true;
                            }
                        }
                        if (victim)
                        {
                            var damagedBy = victim.data.damagedBy;
                            if (damagedBy && damagedBy.length > 0)
                            {
                                for (var i = 0; i < damagedBy.length; i++)
                                {
                                    if (damagedBy[i] != _playerId)
                                    {
                                        let assistPlayer = this.getPlayerById(damagedBy[i]);
                                        if (assistPlayer)
                                        {
                                            assistPlayer.assists++;
                                            this.onEvent({
                                                eventId: GameServer.EVENT_PLAYER_UPDATE,
                                                playerId: damagedBy[i],
                                                data: {
                                                    assists: assistPlayer.assists,
                                                }
                                            });
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                var eventObj = {
                    eventId: GameServer.EVENT_PLAYER_UPDATE,
                    playerId: _playerId,
                    data: {
                        kills: ps.kills,
                        headshots: ps["headshots"],
                        melees: ps["melees"],
                        currentKillstreak: ps["currentKillstreak"],
                        bRevenge: bRevenge,
                        bAvenger: bAvenger
                    }
                };
                if (!game.bSurvival && !game.bOpenWorld)
                {
                    var gameModeData = {};
                    if (!this.game.bScenario)
                    {
                        if (victim && (victim.data.type == ObjectType.CHARACTER || victim.data.type == ObjectType.DINOSAUR))
                        {
                            if (!game.gameModeData.bFirstBlood)
                            {
                                gameModeData.firstBloodPlayerId = _playerId;
                                game.gameModeData.bFirstBlood = true;
                            }
                        }
                    }
                    switch (game.gameModeId)
                    {
                        case GameMode.FREE_FOR_ALL:
                            if (bAddToKills)
                            {
                                gameModeData["bPlayerKill"] = true;
                                if (ps.kills >= game.gameModeData.scoreLimit)
                                {
                                    this.requestEvent({
                                        eventId: GameServer.EVENT_GAME_END,
                                        condition: MatchState.END_CONDITION_SCORE,
                                        winningTeam: ps.team,
                                        //playerId: ps.id,
                                        cameraTargetId: ps.id
                                    });
                                }
                            }
                            break;
                        case GameMode.EVOLUTION:
                            if (bAddToKills)
                            {
                                if (ps.team == 1)
                                {
                                    this.addEvolutionKill(ps ? ps.id : null);
                                }
                            }
                            break;
                        case GameMode.TEAM_DEATHMATCH:
                        case GameMode.TYRANT:
                        case GameMode.RAPTOR_HUNT:
                        case GameMode.HUMANS_VS_DINOSAURS:
                            if (bAddToKills)
                            {
                                var scores = game.gameModeData.scores;
                                scores[ps.team]++;
                                gameModeData.scores = scores;
                                this.dispatchTrigger({ event: "gameScoreUpdated", team: ps.team, score: scores[ps.team] });
                                if (game.gameModeId == GameMode.TYRANT)
                                {
                                    if (ps.team == 0)
                                    {
                                        this.requestEvent({
                                            eventId: GameServer.EVENT_GAME_END,
                                            condition: MatchState.END_CONDITION_TREX_KILLED,
                                            winningTeam: ps.team,
                                            playerId: ps.id,
                                            cameraTargetId: ps.id
                                        });
                                    }
                                    else if (scores[ps.team] >= game.gameModeData.scoreLimit)
                                    {
                                        let rexes = this.getPlayersOnTeam(1);
                                        this.requestEvent({
                                            eventId: GameServer.EVENT_GAME_END,
                                            condition: MatchState.END_CONDITION_SCORE,
                                            winningTeam: ps.team,
                                            playerId: rexes[0] ? rexes[0].id : null,
                                            cameraTargetId: ps.id
                                        });
                                    }
                                }
                                else if (scores[ps.team] >= game.gameModeData.scoreLimit)
                                {
                                    this.requestEvent({
                                        eventId: GameServer.EVENT_GAME_END,
                                        condition: MatchState.END_CONDITION_SCORE,
                                        winningTeam: ps.team,
                                        cameraTargetId: ps.id
                                    });
                                }
                            }
                            break;
                    }
                }
                if ((game.bSurvival || game.gameSettings.bEarnMoneyForKills) && victim)
                {
                    //Add kill reward              
                    switch (victim.data.type)
                    {
                        case ObjectType.CHARACTER:
                        case ObjectType.CAR:
                        case ObjectType.HELICOPTER:
                        case ObjectType.MOUNTED_WEAPON:
                        case ObjectType.TANK:
                        case ObjectType.DINOSAUR:
                        case ObjectType.EGG:
                            var reward = victim.data.reward ? victim.data.reward : 100;
                            if (_damageInfo.bMelee)
                            {
                                reward *= 2;
                            }
                            else if (_damageInfo.bHeadshot)
                            {
                                reward *= 1.5;
                            }
                            this.addPlayerMoney(ps.id, reward);
                            break;
                    }
                }
                this.onEvent(eventObj);
                if (gameModeData)
                {
                    if (Object.keys(gameModeData).length > 0)
                    {
                        this.onEvent({
                            eventId: GameServer.EVENT_GAME_UPDATE,
                            data: gameModeData
                        });
                    }
                }
            }
        }
    }

    triggerCallback(_id, _data)
    {
        if (this.game && this.game.callbacks && this.game.callbacks[_id])
        {
            this.game.callbacks[_id](_data);
        }
    }

    onObjectDeath(_objectId, _damageAmount, _killerId, _causerId, _damageInfo)
    {
        var ps = this.getPlayerById(_objectId);
        var killedObject = this.getObjectById(_objectId);
        var data = killedObject.data;
        var objectTeam = data.team;
        var ragdoll = null;
        var vx = 0;
        var vy = 0;
        var angularForce = Math.min(1000, _damageAmount * 5);
        var va = this.Random(-angularForce, angularForce);
        var rad = 0;
        var causer = this.getObjectById(_causerId);
        if (causer)
        {
            rad = this.Angle(causer.position[0], causer.position[1], killedObject.position[0], killedObject.position[1]) + this.ToRad(this.Random(-15, 15));
            if (isNaN(rad))
            {
                console.warn("Invalid ragdoll rad");
            }
            var force = Math.max(100, (_damageAmount * 30));
            var maxForce = _damageInfo.damageType == DamageType.DAMAGE_EXPLOSIVE ? 10000 : 8000;
            force = Math.max(2000, Math.min(force, maxForce));
            vx = Math.round(Math.cos(rad) * force);
            vy = Math.round(Math.sin(rad) * force);
        }
        this.clearPlayerControllable(_objectId);
        if (killedObject.constraint)
        {
            this.game.world.removeConstraint(killedObject.constraint);
            delete killedObject.constraint;
        }
        switch (data.type)
        {
            case ObjectType.CHARACTER:
                this.triggerCallback("onPlayerKill");
                break;
            case ObjectType.DINOSAUR:
            case ObjectType.FLYING_DINOSAUR:
                this.triggerCallback("onDinoKill");
                break;
            case ObjectType.HELICOPTER:
                this.triggerCallback("onHeliKill");
                break;
            case ObjectType.CAR:
            case ObjectType.TANK:
                this.triggerCallback("onVehicleKill");
                break;
            case ObjectType.EGG:
                this.triggerCallback("onEggKill");
                break;
        }   
        var killer = this.getPlayerById(_killerId);
        this.dispatchTrigger({
            event: "objectKilled",
            objectId: _objectId,
            type: data.type,
            team: data.team,
            killerId: _killerId,
            killerTeam: killer ? killer.team : null,
            playerId: ps ? ps.id : null,
            playerIndex: ps ? this.game.players.indexOf(ps) : null,
            playerName: ps ? ps.name : null
        });
        switch (data.type)
        {
            case ObjectType.OBSTACLE:
                switch (data.obstacleId)
                {
                    case "barrel_explosive":
                    case "barrel_poison":
                    case "barrel_oil":
                        this.detonate(killedObject);
                        break;
                    default:
                        this.removeNextStep(killedObject);
                        break;
                }
                break;

            case ObjectType.ROCKET:
                this.detonate(killedObject);
                break;

            case ObjectType.GRENADE:
                if (data.weaponId == "c4" && !_data.bMelee)
                {
                    this.detonate(killedObject);
                }
                this.removeNextStep(killedObject);
                break;

            case ObjectType.TANK:
            case ObjectType.CAR:
            case ObjectType.MOUNTED_WEAPON:
                var seats = data.seats;
                for (var i = 0; i < seats.length; i++)
                {
                    let seat = seats[i];
                    if (seat.pawnId)
                    {
                        let seatPawnId = seat.pawnId;
                        this.exitVehicle(this.getObjectById(seatPawnId));
                        this.clearPlayerControllable(seatPawnId);
                        if (data.bKillOccupantsWhenDestroyed)
                        {
                            this.killPawn(seatPawnId);
                        }
                        else if (!this.game.bSurvival || killedObject.data.team >= 1)
                        {
                            this.requestEvent({
                                eventId: GameServer.EVENT_PAWN_DAMAGE,
                                damageType: DamageType.DAMAGE_EXPLOSIVE,
                                damageAmount: killedObject.data.maxHealth,
                                pawnId: seatPawnId,
                                attackerId: _killerId,
                                causerId: _causerId,
                                weaponId: _damageInfo.weaponId
                            });
                        }
                    }
                }
                var shared = this.getSharedData(killedObject.data.vehicleId);
                this.createExplosion({
                    eventId: GameServer.EVENT_SPAWN_EXPLOSION,
                    position: killedObject.position,
                    radius: Math.max(shared ? shared.width : 150, 150),
                    damage: this.settings.vehicleExplosionDamage,
                    playerId: null,
                    causerId: null,
                    weaponId: null
                });
                this.removeNextStep(killedObject)
                break;

            case ObjectType.HELICOPTER:
                var seats = data.seats;
                for (var i = 0; i < seats.length; i++)
                {
                    let seat = seats[i];
                    if (seat.pawnId)
                    {
                        let seatPawnId = seat.pawnId;
                        this.exitVehicle(this.getObjectById(seatPawnId));
                        this.clearPlayerControllable(seatPawnId);
                        if (data.bKillOccupantsWhenDestroyed)
                        {
                            this.killPawn(seatPawnId);
                        }
                        else if (!this.game.bSurvival || killedObject.data.team >= 1)
                        {
                            this.requestEvent({
                                eventId: GameServer.EVENT_PAWN_DAMAGE,
                                damageType: DamageType.DAMAGE_EXPLOSIVE,
                                damageAmount: killedObject.data.maxHealth,
                                pawnId: seatPawnId,
                                attackerId: _killerId,
                                causerId: _causerId,
                                weaponId: _damageInfo.weaponId
                            });
                        }
                    }
                }
                this.createExplosion({
                    eventId: GameServer.EVENT_SPAWN_EXPLOSION,
                    position: killedObject.position,
                    radius: 400,
                    damage: this.settings.vehicleExplosionDamage,
                    playerId: null,
                    causerId: null,
                    weaponId: null
                });
                this.removeNextStep(killedObject);
                break;

            case ObjectType.CHARACTER:
            case ObjectType.DINOSAUR:
            case ObjectType.FLYING_DINOSAUR:
                this.stopCharacterInteract(killedObject);
                var weapon = this.getWeaponData(_damageInfo.weaponId);
                var bGib = killedObject.data.bZombie == true;
                if (_damageInfo.damageType == DamageType.DAMAGE_EXPLOSIVE)
                {
                    bGib = _damageAmount >= 100;
                }
                if (weapon && !bGib)
                {
                    switch (weapon.round)
                    {
                        case "50bmg":
                        case "408":
                        case "25mm":
                            bGib = true;
                            break;
                    }
                    switch (weapon.type)
                    {
                        case Weapon.TYPE_SHOTGUN:
                            bGib = _damageInfo.bNearshot;
                            break;
                        default:
                            bGib = _damageAmount > 200;
                            break;
                    }
                    switch (weapon.id)
                    {
                        case "melee_katana":
                        case "melee_machete":
                        case "melee_hatchet":
                        case "minigun":
                        case "gatling":
                        case "m2":
                        case "mg42":
                        case "m242":
                            bGib = true;
                            break;
                    }
                    if (weapon.bDinosaur && weapon.type == Weapon.TYPE_MELEE && _damageAmount > 100)
                    {
                        bGib = true;
                    }
                }
                ragdoll = {
                    id: this.getRandomUniqueId(),
                    x: Math.round(killedObject.position[0]),
                    y: Math.round(killedObject.position[1]),
                    rotation: rad,
                    type: "ragdoll",
                    vx: -vx,
                    vy: -vy,
                    va: va,
                    data: {
                        damageAmount: _damageAmount,
                        damageType: _damageInfo.damageType,
                        type: killedObject.data.type,
                        bGib: bGib && !killedObject.data.bJuggernaut,
                        dinoType: killedObject.data.dinoType,
                        bSavage: killedObject.data.bSavage,
                        objectScale: killedObject.data.objectScale,
                        team: killedObject.data.team,
                        tint: killedObject.data.colour
                    },
                    playerId: _objectId
                };
                if (data.interactableId)
                {
                    var interactable = this.getObjectById(killedObject.data.interactableId);
                    if (interactable && interactable.data.bLimitInteractions)
                    {
                        delete interactable.data.currentPawnId;
                    }
                }
                if (killedObject.data.type == ObjectType.CHARACTER)
                {
                    if (killedObject.data.bDropAllWeapons)
                    {
                        this.dropAllCharacterWeapons(killedObject);
                    }
                    else
                    {
                        var bDrop = this.game.bSurvival ? killedObject.data.team != 0 : true;
                        if (this.game.gameModeData.bAllowRevives && ps)
                        {
                            bDrop = false;
                        }
                        else if (killedObject.data.bDropWeapons != null)
                        {
                            bDrop = killedObject.data.bDropWeapons == true;
                        }
                        if (bDrop)
                        {
                            var dropChance = 30;
                            if (this.game.bOpenWorld)
                            {
                                dropChance = 10;
                            }
                            else if (this.game.bSurvival)
                            {
                                dropChance = 30;
                            }
                            if (killedObject.data.bDropWeapons || this.Random(1, dropChance) == 1)
                            {
                                this.dropCharacterWeapon(killedObject, killedObject.data.currentInventoryIndex);
                            }
                        }
                    }
                }
                if (this.game.bSurvival && killedObject.data.team != 0 && !this.game.gameSettings.bDisableMoneyDrops)
                {
                    if (killedObject.data.bSavage || killedObject.data.bJuggernaut)
                    {
                        var numBills = 5;
                        for (var i = 0; i < numBills; i++)
                        {
                            var money = this.createMoney(killedObject.position, {
                                value: Math.min(500, this.RoundToNearest(killedObject.data.maxHealth / numBills)),
                                destroyTimer: 60
                            });
                            money.applyImpulse([this.Random(-500, 500), this.Random(-500, 500)]);
                            money.angularVelocity = this.Random(-10, 10);
                        }
                    }
                }
                this.removeNextStep(killedObject);
                break;

            case ObjectType.EGG:
                if (this.game.bSurvival && killedObject.data.team != 0 && !this.game.gameSettings.bDisableMoneyDrops)
                {
                    var numBills = 5;
                    for (var i = 0; i < numBills; i++)
                    {
                        var money = this.createMoney(killedObject.position, {
                            value: Math.min(500, this.RoundToNearest(killedObject.data.maxHealth / numBills)),
                            destroyTimer: 60
                        });
                        money.applyImpulse([this.Random(-500, 500), this.Random(-500, 500)]);
                        money.angularVelocity = this.Random(-10, 10);
                    }
                }
                this.removeNextStep(killedObject);
                break;

            default:
                this.removeNextStep(killedObject);
                break;
        }
        var items = data.items;
        if (items)
        {
            if (data.bDropItemsWhenDestroyed != false)
            {
                for (var i = 0; i < items.length; i++)
                {
                    let item = items[i];
                    this.spawnItem(item, killedObject.position, data.team);
                }
                data.items = null;
            }
        }
        if (ps)
        {
            ps.deaths++;
            var killedBy = ps.killedBy;
            if (killedBy)
            {
                if (_killerId)
                {
                    if (killedBy.indexOf(_killerId) == -1)
                    {
                        killedBy.push(_killerId);
                    }
                }
            }
            this.endMultiKill(ps);
            this.onEvent({
                eventId: GameServer.EVENT_PLAYER_UPDATE,
                playerId: _objectId,
                data: {
                    deaths: ps.deaths,
                    currentKillstreak: ps.currentKillstreak,
                    bHasPawn: false
                }
            });
            if (ps.controllableId)
            {
                var controllable = this.getObjectById(ps.controllableId);
                if (controllable)
                {
                    switch (controllable.data.type)
                    {
                        case ObjectType.MOUNTED_WEAPON:
                            this.clearPlayerControllable(ps.id);
                            break;
                    }
                }
            }
            if (!killedObject.data.bDropAllWeapons && (this.game.bSurvival || this.game.gameModeData.bAllowRevives))
            {
                ps.inventory = [killedObject.data.inventory[0], killedObject.data.inventory[1]];
                ps.melee = killedObject.data.inventory[Character.INDEX_MELEE] ? killedObject.data.inventory[Character.INDEX_MELEE].id : killedObject.data.melee;
                ps.equipment = killedObject.data.equipment ? killedObject.data.equipment : null;
                ps.grenade = killedObject.data.grenade ? killedObject.data.grenade : null;
            }
        }
        var useCauserId = _causerId;
        if (causer)
        {
            switch (causer.data.type)
            {
                case ObjectType.ROCKET:
                    useCauserId = causer.data.causerId;
                    break;
                case ObjectType.GRENADE:
                    useCauserId = causer.data.playerId;
                    break;
            }
        }
        var bReviver = ps != null && (killedObject.data.type == ObjectType.CHARACTER || killedObject.data.type == ObjectType.DINOSAUR) && this.game.gameModeData.bAllowRevives;
        switch (this.game.gameModeId)
        {
            case GameMode.OPEN_WORLD:                
                break;
            default:
                bReviver = bReviver && objectTeam == 0 && this.getNumPawnsOnTeam(0) >= 1;
                break;
        }
        if (this.game.bScenario)
        {
            //
        }
        this.onEvent({
            eventId: GameServer.EVENT_PAWN_DIE,
            data: {
                id: _objectId,
                damageAmount: _damageAmount,
                killerId: _killerId,
                causerId: useCauserId,
                damageInfo: _damageInfo,
                ragdoll: ragdoll,
                bReviver: bReviver
            }
        });
        if (bReviver)
        {
            var ragdollDestroyTimer = null;
            if (this.game.bOpenWorld)
            {
                ragdollDestroyTimer = this.game.gameModeData.respawnTime + 1;
            }
            var reviver = this.createReviver([killedObject.position[0], killedObject.position[1] - 30], [vx * 0.5, vy * 0.5], va, this.game.bOperation, {
                playerId: _objectId,                
                interactTime: this.game.settings.fps * 1,
                interactTeam: data.team,
                ragdoll: ragdoll.data,
                destroyTimer: ragdollDestroyTimer
            });
            if (ps.money > 0 && !this.game.gameSettings.bDisableMoneyDrops)
            {
                var costToDie = Math.max(this.game.bOpenWorld ? this.settings.maxPlayerMoney : 1000, Math.round(ps.money * 0.1)); //Money lost when killed
                var dif = Math.min(0, ps.money - costToDie);
                this.addPlayerMoney(ps.id, -costToDie);
                var numBills = Math.min(10, Math.round(5 + (ps.money / 5000)));
                for (var i = 0; i < numBills; i++)
                {
                    var money = this.createMoney(killedObject.position, {
                        value: this.RoundToNearest((costToDie + dif) / numBills),
                        destroyTimer: 60
                    });
                    money.applyImpulse([this.Random(-500, 500), this.Random(-500, 500)]);
                    money.angularVelocity = this.Random(-10, 10);
                }
            }
        }
        if (this.game.bScenario)
        {
            if (this.getNumPawnsOnTeam(0, true) <= 0)
            {
                if (!this.game.gameModeData.bAllowRespawns && !this.game.gameSettings.bDeathmatch)
                {
                    this.requestEvent({
                        eventId: GameServer.EVENT_GAME_END,
                        condition: MatchState.END_CONDITION_KIA,
                        result: MatchState.END_RESULT_LOSS
                    });
                }
            }
        }
        else if (this.game.bSurvival)
        {
            if (objectTeam == 0)
            {
                if (this.getNumPawnsOnTeam(0, true) <= 0)
                {
                    this.requestEvent({
                        eventId: GameServer.EVENT_GAME_END,
                        condition: MatchState.END_CONDITION_KIA,
                        result: MatchState.END_RESULT_LOSS,
                        winningTeam: 1,
                        cameraTargetId: killedObject.data.id
                    });
                }
            }
            else if (objectTeam == 1)
            {
                this.game.gameModeData.kills++;
                this.game.gameModeData.waveKills++;
                if (_damageInfo.bMelee)
                {
                    this.game.gameModeData.waveMelees++;
                }
                else if (_damageInfo.bHeadshot)
                {
                    this.game.gameModeData.waveHeadshots++;
                }
                if (this.game.gameModeData.killTypes)
                {
                    if (this.game.gameModeData.killTypes[killedObject.data.type] == null)
                    {
                        this.game.gameModeData.killTypes[killedObject.data.type] = 0;
                    }
                    this.game.gameModeData.killTypes[killedObject.data.type]++;
                }
                var numEnemies = 0;
                switch (killedObject.data.type)
                {
                    case ObjectType.CHARACTER:
                    case ObjectType.DINOSAUR:
                    case ObjectType.FLYING_DINOSAUR:
                        numEnemies++;
                        break;
                    case ObjectType.EGG:
                    case ObjectType.HELICOPTER:
                        var items = killedObject.data.items;
                        if (items)
                        {
                            for (var i = 0; i < items.length; i++)
                            {
                                let curItem = items[i];
                                switch (curItem.type)
                                {
                                    case ObjectType.MOUNTED_WEAPON:
                                    case ObjectType.CHARACTER:
                                    case ObjectType.DINOSAUR:
                                    case ObjectType.FLYING_DINOSAUR:
                                        numEnemies++;
                                        break;
                                    case ObjectType.CAR:
                                        if (curItem.bAutomated)
                                        {
                                            numEnemies++
                                        }
                                        if (curItem.characters)
                                        {
                                            numEnemies += curItem.characters.length;
                                        }
                                        break;
                                }
                            }
                        }
                        break;
                }
                if (killedObject.data.bAutomated)
                {
                    if (killedObject.data.items)
                    {
                        console.log(killedObject.data.items);
                    }
                    else
                    {
                        numEnemies++;
                    }
                }
                if (numEnemies > 0)
                {
                    this.game.gameModeData.enemiesRemaining = Math.max(0, this.game.gameModeData.enemiesRemaining - numEnemies);
                    this.onEvent({
                        eventId: GameServer.EVENT_GAME_UPDATE,
                        data: {
                            enemiesRemaining: this.game.gameModeData.enemiesRemaining,
                            kills: this.game.gameModeData.kills
                        }
                    });
                    if (this.game.gameModeData.enemiesRemaining <= 0)
                    {
                        this.onSurvivalWaveComplete();
                    }
                }
            }
        }
        else
        {
            switch (this.game.gameModeId)
            {
                case GameMode.EXTRACTION:
                    if (this.getNumPawnsOnTeam(0, true) <= 0)
                    {
                        this.addScore(1, 1);
                        this.requestEvent({
                            eventId: GameServer.EVENT_GAME_END,
                            condition: MatchState.END_CONDITION_HUMANS_KILLED,
                            winningTeam: 1,
                            cameraTargetId: killedObject.data.id
                        });
                    }
                    break;
            }
        }
    }

    createReviver(_position, _velocity, _angularVelocity, _bBleedTimer, _data)
    {
        var shared = this.getSharedData(ObjectType.REVIVER);
        var body = new this.p2.Body({
            mass: shared.mass,
            damping: shared.damping,
            position: _position,
            allowSleep: true,
            sleepSpeedLimit: 1,
            fixedRotation: true
        });
        body.data = {
            id: this.getRandomUniqueId(),
            x: _position[0],
            y: _position[1],
            type: ObjectType.REVIVER,
            bLimitInteractions: true,
            team: _data.interactTeam,
            playerId: _data.playerId,
            itemData: _data,
            value: 10,
            destroyTimer: _data.destroyTimer ? (_data.destroyTimer * this.game.settings.fps) : null
        };
        var data = body.data;
        if (data.destroyTimer)
        {
            data.destroyTimerMax = data.destroyTimer;
        }
        if (_bBleedTimer)
        {
            var bleedTimerMax = 30;
            if (this.game.bOperation)
            {
                bleedTimerMax = 30 - (this.game.gameModeData.difficulty * 5);
            }
            data.bleedTimerMax = this.game.settings.fps * bleedTimerMax;
            data.bleedTimer = data.bleedTimerMax;
        }
        var shape = new this.p2.Circle({
            radius: shared.size ? shared.size : shared.width,
            collisionGroup: CollisionGroups.PAWN,
            collisionMask: CollisionGroups.GROUND | CollisionGroups.BOUNDS
        });
        body.addShape(shape);
        this.addWorldBody(body);

        body.applyImpulse([_velocity[0], _velocity[1]], 0, 0);
        body.angularVelocity = _angularVelocity;

        this.onEvent({
            eventId: GameServer.EVENT_SPAWN_OBJECT,
            type: ObjectType.REVIVER,
            position: body.position,
            velocity: body.velocity,
            data: data
        });
        return body;
    }

    dropPlayerWeapons(_playerId, _position)
    {
        var ps = this.getPlayerById(_playerId);
        if (ps)
        {
            var inventory = ps.inventory;
            if (inventory)
            {
                var angle = this.RandomAngle();
                for (var i = 0; i < inventory.length; i++)
                {
                    let item = inventory[i];
                    if (item)
                    {
                        if (item.bZombie || item.id == "none")
                        {
                            continue;
                        }
                        let force = this.Random(100, 150);                        
                        let vx = (Math.cos(angle) * force);
                        let vy = (Math.sin(angle) * force);
                        let dropped = this.createDroppedWeapon(
                            _position,
                            {
                                angle: angle + this.ToRad(i * 30),
                                weaponData: item,
                                velocity: [vx, vy],
                                angularVelocity: this.Random(0, 5)
                            }
                        );
                        if (dropped)
                        {
                            dropped.applyImpulse([this.Random(-500, 500), this.Random(-500, 500)], [0, 0]);
                            dropped.angularVelocity = this.Random(-10, 10);
                        }
                    }
                }
            }
            delete ps.inventory;
        }
    }

    dropAllCharacterWeapons(_body)
    {
        //this.dropCharacterEquipment(_body, "melee");
        //this.dropCharacterEquipment(_body, "grenade");
        //this.dropCharacterEquipment(_body, "equipment");
        var data = _body.data;
        var rad = data.aimRotation;
        if (data.scale == -1)
        {
            rad += this.ToRad(-180);
        }
        var inventory = data.inventory;
        for (var i = 0; i < inventory.length; i++)
        {
            let item = inventory[i];
            if (item)
            {
                if (item.bZombie || item.id == "none")
                {
                    continue;
                }
                let force = this.Random(100, 150);
                let vx = (Math.cos(data.aimRotation) * force);
                let vy = (Math.sin(data.aimRotation) * force);
                let dropped = this.createDroppedWeapon(
                    [_body.position[0], _body.position[1]],
                    {
                        angle: rad + this.ToRad(i * 30),
                        scale: data.scale,
                        weaponData: item,
                        velocity: [vx, vy],
                        angularVelocity: this.Random(0, 5)
                    }
                );
                if (dropped)
                {
                    dropped.applyImpulse([this.Random(-500, 500), this.Random(-500, 500)], [0, 0]);
                    dropped.angularVelocity = this.Random(-10, 10);
                }
            }
        }
    }

    dropCharacterEquipment(_body, _slot)
    {
        var data = _body.data;
        var rad = data.aimRotation;
        if (data.scale == -1)
        {
            rad += this.ToRad(-180);
        }
        var item = data[_slot];
        if (item && (item.ammo > 0 || item.type == Weapon.TYPE_MELEE))
        {
            if (item.id == "none")
            {
                return;
            }
            var force = this.Random(100, 150);
            var vx = (Math.cos(data.aimRotation) * force);
            var vy = (Math.sin(data.aimRotation) * force);
            this.createDroppedWeapon(
                [_body.position[0], _body.position[1]],
                {
                    angle: rad,
                    scale: data.scale,
                    weaponData: this.clone(item),
                    velocity: [vx, vy],
                    angularVelocity: this.Random(0, 5)
                }
            );
        }
    }

    dropCharacterWeapon(_body, _index)
    {
        var data = _body.data;
        var rad = data.aimRotation;
        if (data.scale == -1)
        {
            rad += this.ToRad(-180);
        }
        var item = data.inventory[_index];
        if (!item || item.bZombie || item.id == "none")
        {
            return;
        }
        var force = this.Random(120, 150);
        var vx = (Math.cos(data.aimRotation) * force);
        var vy = (Math.sin(data.aimRotation) * force);
        this.createDroppedWeapon(
            [_body.position[0], _body.position[1]],
            {
                angle: rad,
                scale: data.scale,
                weaponData: item,
                velocity: [vx, vy],
                angularVelocity: this.Random(0, 5)
            }
        );
    }

    characterCanInteract(_body, _interactable)
    {
        var data = _body.data;
        var ps = this.getPlayerById(data.id);
        if (ps && ps.controllableId)
        {
            return false;
        }
        if (_interactable)
        {
            switch (_interactable.data.type)
            {
                case ObjectType.DROPPED_WEAPON:
                    if (data.type == ObjectType.DINOSAUR)
                    {
                        return this.game.gameSettings.bAllowDinosaurPickups == true;
                    }
                    break;
            }
            if (_interactable.data.bDisabled)
            {
                return false;
            }
            if (_interactable.data.interactTeam != null)
            {
                if (_interactable.data.interactTeam != data.team)
                {
                    return false;
                }
            }
            if (_interactable.data.bLimitInteractions)
            {
                if (_interactable.data.currentPawnId)
                {
                    return false;
                }
            }
        }
        //var dist = this.Dist(_body.position[0], _body.position[1], _interactable.position[0], _interactable.position[1]);
        return !data.bInteracting; // && dist < 200;
    }

    characterIsFree(_body)
    {
        var data = _body.data;
        if (!this.seatCanInput(_body))
        {
            return false;
        }
        if (data.bShieldCooldown)
        {
            return false;
        }
        return !data.bInteracting && !this.characterHasWeaponDelay(_body) && !data.bReloading;
    }

    onVehicleImpact(_victim, _vehicle)
    {
        var victimData = _victim.data;
        var vehicleData = _vehicle.data;
        if (this.vehicleHasOccupant(_vehicle))
        {
            var vel = (_vehicle.velocity[0] * _vehicle.velocity[0]) + (_vehicle.velocity[1] * _vehicle.velocity[1]);
            var damage = vel * 0.00005 * _vehicle.mass; //Impact damage
            if (damage >= 50)
            {
                this.requestEvent({
                    eventId: GameServer.EVENT_PAWN_DAMAGE,
                    damageType: DamageType.DAMAGE_WORLD,
                    damageAmount: damage,
                    pawnId: victimData.id,
                    attackerId: this.getVehicleDriverId(_vehicle),
                    causerId: vehicleData.id,
                    weaponId: vehicleData.vehicleId
                });
                //Impact kill
                if (!victimData.health)
                {
                    this.requestEvent({
                        eventId: GameServer.EVENT_PAWN_ACTION,
                        pawnId: vehicleData.id,
                        type: GameServer.PAWN_VEHICLE_UPDATE,
                        decal: {
                            angle: this.Angle(_victim.position[0], _victim.position[1], _vehicle.position[0], _vehicle.position[1])
                        }
                    });
                }
            }
        }
    }

    characterCanUseEquipment(_body, _slot)
    {
        var data = _body.data;
        var controllable = this.getObjectById(data.controllableId);
        if (controllable)
        {
            if (this.isVehicle(controllable))
            {
                if (_body)
                {
                    var seat = this.getSeatData(_body);
                    if (!seat || !seat.bInput)
                    {
                        return false;
                    }
                }
            }
        }
        var item = data[_slot];
        if (!item)
        {
            return false;
        }
        if (!item.bSprintUse && data.bSprinting)
        {
            //return false;
        }
        return !data.bInteracting && !this.characterHasWeaponDelay(_body) && !data.bShieldCooldown;
    }

    characterCanFire(_body, _bCheckMag)
    {
        if (!this.matchInProgress())
        {
            return false;
        }
        if (!this.seatCanInput(_body))
        {
            return false;
        }
        var item = this.getCurrentCharacterInventoryItem(_body);
        if (!item)
        {
            return false;
        }
        if (_bCheckMag)
        {
            var bHasMag = item.bDinosaur || (this.isMeleeWeapon(item) ? true : (item.mag > 0));
            if (!bHasMag)
            {
                return false;
            }
        }
        var data = _body.data;
        if (item.bRequireLock)
        {
            if (!data.lockOnTargetId)
            {
                return false;
            }
        }
        var weapon = data.weapon;
        return !data.bInteracting && !data.bReloading && !this.characterHasWeaponDelay(_body) && !weapon.bBoltDelay && !data.bSprinting && !data.bShieldCooldown;
    }

    createImpactEffect(_x, _y, _rotation, _impactType, _intensity, _objectId)
    {
        var data = {
            id: this.getRandomUniqueId(),
            x: Math.round(_x),
            y: Math.round(_y),
            type: "impactEffect",
            rotation: this.RoundDecimal(_rotation),
            impactType: _impactType,
            intensity: _intensity
        };
        if (_objectId)
        {
            data.objectId = _objectId;
        }
        this.requestEvent({
            eventId: GameServer.EVENT_SPAWN_OBJECT,
            data: data
        });
    }

    createImpactEffects(_items)
    {
        if (this.batchData.length >= this.settings.maxBatchItems)
        {
            return;
        }
        if (_items && _items.length > 0)
        {
            this.requestEvent({
                eventId: GameServer.EVENT_SPAWN_OBJECT,
                data: {
                    type: "impactEffect",
                    items: _items
                }
            });
        }
    }

    startSurvivalWaveIntermission()
    {
        var gameData = this.game.gameModeData;
        gameData.intermissionTimer = this.settings.intermissionTimer * (gameData.wave >= 10 ? 2 : 1);
        gameData.waveTimer = this.game.settings.fps;
        gameData.bIntermission = true;
        this.onEvent({
            eventId: GameServer.EVENT_GAME_UPDATE,
            data: {
                timer: gameData.intermissionTimer,
                bIntermission: gameData.bIntermission
            }
        });
        this.dispatchTrigger({
            event: "survivalIntermissionStarted",
            wave: gameData.wave
        });
    }

    startSurvivalWave()
    {
        var gameData = this.game.gameModeData;
        gameData.bIntermission = false;
        gameData.wave++;
        gameData.waveKills = 0;
        gameData.waveHeadshots = 0;
        gameData.waveMelees = 0;
        gameData.waveRevives = 0;
        gameData.killTypes = {};
        var wave = gameData.wave;
        var waveType;
        var tipId;
        gameData.numEnemies = Math.min(100, 15 * wave);
        switch (this.game.gameModeId)
        {
            case GameMode.SURVIVAL_PANDEMONIUM:
                //Random enemy types
                var enemies = [
                    {
                        type: ObjectType.CHARACTER
                    },
                    {
                        type: ObjectType.CHARACTER,
                        bZombie: true
                    }                    
                ];
                //Add basic dinos
                var dinoTypes = [Dinosaur.LIZARD, Dinosaur.CHICKEN, Dinosaur.COMPY, Dinosaur.PACHY];
                enemies.push({
                    type: ObjectType.DINOSAUR,
                    dinoType: dinoTypes[this.Random(0, dinoTypes.length - 1)]
                });
                //Add advanced dinos
                dinoTypes = [];
                if (wave >= 3)
                {
                    dinoTypes.push(Dinosaur.DILO, Dinosaur.RAPTOR);
                }
                if (wave >= 5)
                {
                    dinoTypes.push(Dinosaur.NEEDLER, Dinosaur.STEGOSAURUS);
                }
                if (wave >= 10)
                {
                    dinoTypes.push(Dinosaur.CARNOTAURUS, Dinosaur.ALLOSAURUS);
                }
                if (wave >= 15)
                {
                    dinoTypes.push(Dinosaur.SPINOSAURUS);
                    enemies.push({
                        type: ObjectType.DINOSAUR,
                        dinoType: Dinosaur.PTERODACTYL
                    });
                }
                if (wave >= 25)
                {
                    dinoTypes.push(Dinosaur.TREX);
                }
                if (dinoTypes.length)
                {
                    enemies.push({
                        type: ObjectType.DINOSAUR,
                        dinoType: dinoTypes[this.Random(0, dinoTypes.length - 1)]
                    });
                }
                if (wave >= 5)
                {
                    enemies.push(
                        {
                            type: ObjectType.MOUNTED_WEAPON
                        },
                        {
                            type: ObjectType.CHARACTER,
                            bZombie: true,
                            bJuggernaut: true
                        }
                    );
                    var cars = [Car.QUAD, Car.GROWLER, Car.PICKUP];
                    if (wave >= 10)
                    {
                        cars.push(Car.MRAP);
                    }
                    if (wave >= 15)
                    {
                        cars.push(Car.LAV25);
                    }
                    enemies.push({
                        type: ObjectType.CAR,
                        vehicleId: cars[this.Random(0, cars.length - 1)]
                    });
                }
                if (wave >= 10)
                {
                    enemies.push(
                        {
                            type: ObjectType.CHARACTER,
                            bBigfoot: true
                        },
                        {
                            type: ObjectType.CHARACTER,
                            bJuggernaut: true
                        }
                    );
                    var helis = [Helicopter.COBRA, Helicopter.KIOWA];
                    if (wave >= 15)
                    {
                        helis.push(Helicopter.APACHE, Helicopter.CHICKENCOPTER);
                    }
                    if (wave >= 20)
                    {
                        helis.push(Helicopter.BLACKHAWK);
                    }
                    if (wave >= 25)
                    {
                        helis.push(Helicopter.OSPREY);
                    }
                    enemies.push({
                        type: ObjectType.HELICOPTER,
                        vehicleId: helis[this.Random(0, helis.length - 1)]
                    });
                }
                if (wave >= 25)
                {
                    var tanks = [Tank.T90, Tank.ABRAMS];
                    enemies.push({
                        type: ObjectType.TANK,
                        vehicleId: tanks[this.Random(0, tanks.length - 1)]
                    });
                }
                gameData.waveEnemyData = enemies[this.Random(0, enemies.length - 1)];
                console.log(gameData.waveEnemyData);
                let waveEnemyData = gameData.waveEnemyData;
                if (waveEnemyData.bJuggernaut)
                {
                    gameData.numEnemies = Math.max(1, Math.ceil(gameData.numEnemies * 0.15));
                    waveType = "juggernaut";
                }
                else if (waveEnemyData.bBigfoot)
                {
                    gameData.numEnemies = Math.max(1, Math.ceil(gameData.numEnemies * 0.035));
                    waveEnemyData.spawnTimer = Math.round((this.game.settings.fps * 3) - (wave * 0.1));
                }
                else if (waveEnemyData.vehicleId)
                {
                    switch (waveEnemyData.type)
                    {
                        case ObjectType.TANK:
                            gameData.numEnemies = Math.max(1, Math.ceil(gameData.numEnemies * 0.1));
                            waveEnemyData.spawnTimer = Math.round((this.game.settings.fps * 5) - (wave * 0.1));
                            break;
                        case ObjectType.HELICOPTER:
                            gameData.numEnemies = Math.max(1, Math.ceil(gameData.numEnemies * 0.2));
                            if (wave >= 15)
                            {
                                tipId = "TIP_SURVIVAL_FLARES";
                            }
                            let time = 3;
                            if (waveEnemyData.vehicleId == Helicopter.CHICKENCOPTER)
                            {
                                time = 1;
                            }
                            waveEnemyData.spawnTimer = Math.round((this.game.settings.fps * time) - (wave * 0.1));
                            break;
                        default:
                            gameData.numEnemies = Math.max(1, Math.ceil(gameData.numEnemies * 0.25));
                            break;
                    }                    
                }
                else if (waveEnemyData.type == ObjectType.DINOSAUR)
                {
                    switch (waveEnemyData.dinoType)
                    {
                        case Dinosaur.TREX:
                            gameData.numEnemies = Math.max(1, Math.ceil(gameData.numEnemies * 0.1));
                            waveEnemyData.spawnTimer = Math.round((this.game.settings.fps * 5) - (wave * 0.1));
                            break;
                        case Dinosaur.CARNOTAURUS:
                        case Dinosaur.ALLOSAURUS:
                        case Dinosaur.SPINOSAURUS:
                            gameData.numEnemies = Math.max(1, Math.ceil(gameData.numEnemies * 0.15));
                            break;
                        case Dinosaur.STEGOSAURUS:
                            gameData.numEnemies = Math.max(1, Math.ceil(gameData.numEnemies * 0.2));
                            break;
                        case Dinosaur.LIZARD:
                            waveEnemyData.spawnTimer = Math.round(this.game.settings.fps * 0.1);
                            break;
                    }
                    waveType = waveEnemyData.dinoType;
                }
                else if (waveEnemyData.type == ObjectType.MOUNTED_WEAPON)
                {
                    gameData.numEnemies = Math.max(1, Math.ceil(gameData.numEnemies * 0.25));
                    waveEnemyData.spawnTimer = Math.round(this.game.settings.fps * 3);
                }
                if (waveEnemyData.spawnTimer)
                {
                    gameData.spawnTimer = Math.max(0.05, waveEnemyData.spawnTimer);
                }
                else
                {
                    gameData.spawnTimer = Math.round(this.game.settings.fps * Math.max(0.05, 1 - (wave * 0.1)));
                }
                break;
            case GameMode.SURVIVAL_CHAOS:
                if (wave == 18)
                {
                    gameData.numEnemies = 50;
                    waveType = Dinosaur.PTERODACTYL;
                }                
                else if (wave == 12)
                {
                    gameData.numEnemies = 8;
                    waveType = Dinosaur.CARNOTAURUS;
                }
                else if (wave == 8)
                {                   
                    gameData.numEnemies = 10;
                    waveType = Dinosaur.STEGOSAURUS;
                }
                else if (wave == 3)
                {
                    waveType = "helicopter";
                    gameData.numEnemies = 5;
                }
                else if (wave % 25 == 0)
                {
                    waveType = Dinosaur.TREX;
                    gameData.numEnemies = Math.min(10, Math.round(wave / 25) + 2);
                }
                else if (wave % 5 == 0)
                {
                    waveType = wave == 10 ? Dinosaur.NEEDLER : "juggernaut";
                    gameData.numEnemies = Math.min(10, 5 * Math.round(wave / 5));
                    if (wave == 15)
                    {
                        tipId = "TIP_SURVIVAL_FLARES";
                    }
                }                
                break;
            case GameMode.SURVIVAL_MILITIA:
                if (wave == 15)
                {
                    tipId = "TIP_SURVIVAL_FLARES";
                }
                if (wave == 30)
                {
                    gameData.numEnemies = 3;
                }
                else if (wave == 12)
                {
                    gameData.numEnemies = 5;
                }
                else if (wave == 3)
                {
                    waveType = "helicopter";
                    gameData.numEnemies = 1;
                }
                else if (wave % 5 == 0)
                {
                    waveType = "juggernaut";
                    gameData.numEnemies = Math.round(wave / 5) + 1;
                }
                break;
            case GameMode.SURVIVAL_DINO:
                if (wave == 3)
                {
                    gameData.numEnemies = 5;
                    waveType = Dinosaur.DILO;
                }
                else if (wave == 5)
                {
                    waveType = Dinosaur.RAPTOR;
                    gameData.numEnemies = 5;
                }
                else if (wave == 8)
                {
                    gameData.numEnemies = 5;
                    waveType = Dinosaur.STEGOSAURUS;
                }
                else if (wave == 10)
                {
                    waveType = Dinosaur.NEEDLER;
                    gameData.numEnemies = 8;
                }
                else if (wave == 12)
                {
                    waveType = Dinosaur.CARNOTAURUS;
                    gameData.numEnemies = 5;
                }
                else if (wave == 15)
                {
                    waveType = Dinosaur.ALLOSAURUS;
                    gameData.numEnemies = 5;
                }
                else if (wave == 18)
                {
                    waveType = Dinosaur.PTERODACTYL;
                    gameData.numEnemies = 30;
                }
                else if (wave == 20)
                {
                    waveType = Dinosaur.SPINOSAURUS;
                    gameData.numEnemies = 5;
                }
                else if (wave % 25 == 0)
                {
                    waveType = "trex";
                    gameData.numEnemies = Math.round((wave / 25));
                }
                else if (wave > 25 && wave % 5 == 0)
                {
                    gameData.numEnemies = 50;
                }
                break;
            case GameMode.SURVIVAL_ZOMBIE:
                if (wave % 5 == 0)
                {
                    waveType = "juggernaut";
                    gameData.numEnemies = Math.min(100, 2 * (wave / 5));
                }
                gameData.spawnTimer = Math.round(this.game.settings.fps * Math.max(0.1, 1.5 - (wave * 0.1)));
                break;
            case GameMode.SURVIVAL_CHICKEN:
                if (wave % 5 == 0)
                {
                    waveType = "helicopter";
                    gameData.numEnemies = Math.min(100, 2 * (wave / 5));
                }
                else
                {
                    gameData.numEnemies = 25 * wave;
                }
                gameData.spawnTimer = Math.round(this.game.settings.fps * 0.1);
                break;
        }
        gameData.numEnemies = Math.min(100, gameData.numEnemies);
        gameData.enemiesSpawned = 0;
        gameData.enemiesRemaining = gameData.numEnemies;
        gameData.spawnTimer = gameData.spawnTimer ? gameData.spawnTimer : Math.round(this.game.settings.fps * Math.max(0.05, 1.5 - (wave * 0.05)));
        gameData.spawnTimerMax = gameData.spawnTimer;
        var waveData = {
            intermissionTimer: gameData.intermissionTimer,
            wave: gameData.wave,
            enemies: gameData.enemies,
            enemiesRemaining: gameData.enemiesRemaining,
            bWaveStart: true,
            waveType: waveType,
            tipId: tipId,
            timer: -1
        };
        switch (this.game.gameModeId)
        {
            case GameMode.SURVIVAL_PANDEMONIUM:
                waveData.waveEnemyData = gameData.waveEnemyData
                break;
        }
        this.optimizeKeys(waveData);
        this.onEvent({
            eventId: GameServer.EVENT_GAME_UPDATE,
            data: waveData
        });
        this.dispatchTrigger({
            event: "survivalWaveStarted",
            wave: gameData.wave,
            numEnemies: gameData.numEnemies,
            waveType: waveType
        });
    }

    spawnSurvivalEnemyVehicle(_types)
    {
        var wave = this.game.gameModeData.wave;
        var types = _types ? _types : [];
        if (!_types)
        {
            if (wave == 10)
            {
                types = [Helicopter.APACHE];
            }
            else if (wave == 15)
            {
                types = [Helicopter.OSPREY];
            }
            else
            {
                if (wave % 5 == 0)
                {
                    if (wave == 30 && this.game.gameModeData.enemiesSpawned == 0)
                    {
                        types = [Tank.ABRAMS];
                    }
                    else if (wave >= 15)
                    {
                        types = [Helicopter.OSPREY];
                    }
                    else if (wave >= 10)
                    {
                        types = [Helicopter.APACHE];
                    }
                    else if (wave >= 5)
                    {
                        types = [Helicopter.COBRA];
                    }
                }
                else
                {
                    if (wave >= 3)
                    {
                        types.push(Helicopter.COBRA);
                    }
                    if (wave >= 10)
                    {
                        types.push(Helicopter.APACHE);
                        types.push(MountedWeapon.BGM71);
                        types.push(Helicopter.OSPREY);
                        if (this.getCars([Car.GROWLER], 1).length <= 1)
                        {
                            types.push(Car.GROWLER);
                        }
                    }
                    if (wave >= 15)
                    {
                        if (this.getCars([Car.MRAP], 1).length <= 1)
                        {
                            types.push(Car.MRAP);
                        }
                    }
                    if (wave >= 20)
                    {
                        if (this.getCars([Car.LAV25], 1).length <= 1)
                        {
                            types.push(Car.LAV25);
                        }
                    }
                    if (wave >= 25)
                    {
                        types.push(Helicopter.BLACKHAWK);
                    }
                    else if (wave >= 5)
                    {
                        types.push(Helicopter.KIOWA);
                    }
                    if (wave >= 30)
                    {
                        if (this.getTanks(1).length == 0)
                        {
                            types.push(Tank.ABRAMS);
                        }
                    }
                }
            }
        }
        if (types.length > 0)
        {
            var vehicleId = types[this.Random(0, types.length - 1)];
            var veh = this.getVehicleData(vehicleId);
            if (!veh)
            {
                console.warn("Invalid vehicle", vehicleId);
                return;
            }
            var spawnPos = this.getSpawnPointForTeam(1);
            var spawnAngle = this.Angle(spawnPos[0], spawnPos[1], this.getMapWidth() * 0.5, this.getMapHeight() * 0.5);
            switch (veh.type)
            {
                case ObjectType.HELICOPTER:
                    spawnPos = [this.RandomBoolean() ? 0 : this.getMapWidth(), this.RandomBoolean() ? 0 : this.getMapHeight()];
                    spawnAngle = this.Angle(spawnPos[0], spawnPos[1], this.getMapWidth() * 0.5, this.getMapHeight() * 0.5);
                    var vehicle = this.createHelicopter(spawnPos, {
                        vehicleId: veh.id,
                        team: 1,
                        bAutomated: [Helicopter.KIOWA, Helicopter.BLACKHAWK].indexOf(veh.id) == -1,
                        angle: spawnAngle,
                        tint: 0x666666
                    });
                    if (vehicle)
                    {
                        vehicle.data.bKillOccupantsWhenDestroyed = true;
                        switch (veh.id)
                        {
                            case Helicopter.OSPREY:
                                this.setDataValue(vehicle, "enemyTypes", [ObjectType.HELICOPTER, ObjectType.CHARACTER, ObjectType.DINOSAUR, ObjectType.CAR, ObjectType.TANK, ObjectType.EGG]);
                                break;
                        }
                        if (!vehicle.data.bAutomated)
                        {
                            var mainWeapon = vehicle.data.weapons[0] ? vehicle.data.weapons[0][0] : null;
                            if (mainWeapon)
                            {
                                if (mainWeapon.weaponData)
                                {
                                    mainWeapon.weaponData.ammoMax = mainWeapon.weaponData.ammo;
                                }
                                this.initVehicleWeapons(vehicle, vehicle.data.weapons);
                            }
                        }
                        if (wave < 15)
                        {
                            vehicle.data.speed *= 0.5;
                        }
                        else
                        {
                            var speedMult = Math.min(1.25, 0.5 + ((wave - 15) * 0.05));
                            vehicle.data.speed = vehicle.data.speed * speedMult;
                            vehicle.data.flares = 1 + Math.max(0, Math.floor((wave - 15) / 5));
                            vehicle.data.enemyThreshold = Math.min(1000, 600 + ((wave - 15) + 50));
                        }
                    }
                    break;
                case ObjectType.TANK:
                    vehicle = this.createTank(spawnPos, {
                        vehicleId: veh.id,
                        team: 1,
                        bAutomated: false,
                        angle: spawnAngle,
                        tint: 0x999999
                    });
                    if (vehicle)
                    {
                        vehicle.data.weapons[0][0].weaponData.damage *= 2;
                        vehicle.data.damageMultipliers = {
                            1: 0.05,
                            2: 0.05,
                            3: 0.75,
                            4: 0.025
                        }
                    }
                    break;
                case ObjectType.CAR:
                    vehicle = this.createCar(spawnPos, {
                        vehicleId: veh.id,
                        team: 1,
                        bAutomated: false,
                        angle: spawnAngle,
                        tint: 0x999999
                    });
                    break;
                case ObjectType.MOUNTED_WEAPON:
                    vehicle = this.createMountedWeapon(spawnPos, {
                        vehicleId: veh.id,
                        team: 1,
                        bAutomated: veh.id != MountedWeapon.BGM71,
                        bAutoLock: veh.id == MountedWeapon.BGM71
                    });
                    break;
            }
            if (vehicle)
            {
                if (!vehicle.data.bAutomated)
                {
                    var seats = vehicle.data.seats
                    if (seats)
                    {
                        for (var i = 0; i < seats.length; i++)
                        {
                            if (this.game.gameModeData.enemiesSpawned < this.game.gameModeData.numEnemies)
                            {
                                var char = this.spawnSurvivalEnemyCharacter();
                                this.executeInteractable(vehicle, char.data.id);
                                this.game.gameModeData.enemiesSpawned++;
                            }
                            else
                            {
                                break;
                            }
                        }
                    }
                }
                else
                {
                    this.game.gameModeData.enemiesSpawned++;
                }
            }
        }
        if (vehicle)
        {
            vehicle.data.bRegenHealth = false;
            if (vehicle.data.vehicleId == MountedWeapon.BGM71)
            {
                var bgm = vehicle.data.weapons[0][0].weaponData;
                if (wave < 50)
                {
                    bgm.damage *= 0.3;
                    bgm.range = Math.min(3000, 2000 + (wave * 50));
                    bgm.overheatNum = bgm.overheatMax = 180;
                }
                else
                {
                    bgm.damage *= 2;
                    bgm.range = this.settings.maxWorldSize;
                    bgm.overheatNum = bgm.overheatMax = 120;
                }
                this.initVehicleWeapons(vehicle, vehicle.data.weapons);
            }
            if (vehicle.data.type == ObjectType.HELICOPTER)
            {
                if (wave >= 20)
                {
                    vehicle.data.health = vehicle.data.maxHealth = vehicle.data.health + (Math.max(0, (wave - 20)) * 100);
                    this.pushObjectDataUpdate(vehicle, ["health", "maxHealth"]);
                }
            }
        }
        return vehicle;
    }

    spawnSurvivalEnemyChicken(_position)
    {
        var wave = this.game.gameModeData.wave;
        if (wave % 5 == 0 || wave > 5 && this.Random(1, Math.max(5, 50 - wave)) == 1)
        {
            var heli = this.createHelicopter([this.RandomBoolean() ? 0 : this.getMapWidth(), this.RandomBoolean() ? 0 : this.getMapHeight()], {
                vehicleId: Helicopter.CHICKENCOPTER,
                team: 1,
                bAutomated: true
            });
            this.applyCustomVehicleWeapons(heli, [
                [
                    {
                        id: this.getRandomFirearm().id
                    }
                ]
            ]);
            return heli;
        }
        else
        {
            var spawnPos = _position ? _position : this.getBestSpawnPosition(1);
            var botSkill = botSkill = Math.min(BotSkill.SKILL_GOD, Math.floor(wave * 0.5));
            var waveMult = 0.8 + (wave * 0.025);
            var multiplier = wave <= 25 ? 0.05 : 0.1;
            var healthMultiplier = Math.min(5, 0.35 + (wave * multiplier)) * (this.Random(10, 20) * 0.1);
            var bSavage = wave > 5 && this.Random(1, Math.max(5, 50 - wave)) == 1;
            var dino = this.createDinosaur({
                id: this.getRandomUniqueId(),
                x: spawnPos[0],
                y: spawnPos[1],
                team: 1,
                dinoType: Dinosaur.CHICKEN,
                bBot: true,
                botSkill: botSkill,
                bRegenHealth: false,
                speedMultiplier: Math.min(1.2, waveMult * (this.Random(50, 100) * 0.01)),
                healthMultiplier: healthMultiplier,
                bSavage: bSavage,
                objectScale: bSavage ? 2 : (this.Random(10, 15) * 0.1)
            });
            if (bSavage && wave >= 10)
            {
                dino.data.inventory[0] = this.getWeaponData("flamethrower");
            }
            return dino;
        }
    }

    spawnSurvivalEnemyDinosaur(_position, _bEgg, _dinoTypes)
    {
        var wave = this.game.gameModeData.wave;
        if (_dinoTypes)
        {
            var dinos = _dinoTypes;
        }
        else
        {
            if (wave == 3)
            {
                var dinos = [Dinosaur.DILO];
            }
            else if (wave == 5)
            {
                dinos = [Dinosaur.RAPTOR];
            }
            else if (wave == 8)
            {
                dinos = [Dinosaur.STEGOSAURUS];
            }
            else if (wave == 10)
            {
                dinos = [Dinosaur.NEEDLER];
            }
            else if (wave == 12)
            {
                dinos = [Dinosaur.CARNOTAURUS];
            }
            else if (wave == 15)
            {
                dinos = [Dinosaur.ALLOSAURUS];
            }
            else if (wave == 18)
            {
                dinos = [Dinosaur.PTERODACTYL];
            }
            else if (wave == 20)
            {
                dinos = [Dinosaur.SPINOSAURUS];
            }
            else if (wave % 25 == 0)
            {
                dinos = [Dinosaur.TREX];
            }
            else
            {
                dinos = [Dinosaur.COMPY];
                if (wave < 25)
                {
                    dinos.push(Dinosaur.COMPY);
                }
                if (wave >= 3)
                {
                    if (this.Random(1, 2) == 1) dinos.push(Dinosaur.DILO);
                    if (this.Random(1, 2) == 1) dinos.push(Dinosaur.PACHY);
                }
                if (wave >= 5)
                {
                    if (this.Random(1, 10) == 1) dinos.push(Dinosaur.RAPTOR);
                    if (this.Random(1, 5) == 1) dinos.push(Dinosaur.ANKYLOSAURUS);
                }
                if (wave >= 8)
                {
                    if (this.Random(1, 10) == 1) dinos.push(Dinosaur.STEGOSAURUS);
                }
                if (wave >= 10)
                {
                    if (this.Random(1, 3) == 1) dinos.push(Dinosaur.NEEDLER);
                }
                if (wave >= 12)
                {
                    if (this.Random(1, _bEgg ? 8 : 12) == 1) dinos.push(Dinosaur.CARNOTAURUS);
                }
                if (wave >= 15)
                {
                    if (this.Random(1, _bEgg ? 10 : 20) == 1) dinos.push(Dinosaur.ALLOSAURUS);
                }
                if (wave >= 18)
                {
                    dinos.push(Dinosaur.PTERODACTYL);
                }
                if (wave >= 20)
                {
                    if (this.Random(1, _bEgg ? 10 : 20) == 1) dinos.push(Dinosaur.SPINOSAURUS);
                }
                if (wave >= 25)
                {
                    if (this.Random(1, 75 - Math.max(10, (wave - 25))) == 1) dinos.push(Dinosaur.TREX);
                }
            }
        }
        var spawnPos = _position ? _position : this.getBestSpawnPosition(1);
        var botSkill = botSkill = Math.min(BotSkill.SKILL_GOD, Math.floor(wave * 0.5));
        var waveMult = 0.35 + (wave * 0.025);
        var multiplier = wave <= 25 ? 0.05 : 0.1;
        var healthMultiplier = Math.min(10, 0.35 + (wave * multiplier));
        var bSavage = wave > 5 && (_bEgg ? this.Random(1, 2) == 1 : this.Random(1, Math.max(5, ((this.game.gameModeId == GameMode.SURVIVAL_CHAOS ? 20 : 30) - wave))) == 1);
        if (wave >= 30)
        {
            bSavage = true;
        }
        else if (wave == 25)
        {
            bSavage = false; //First T-Rex wave
        }
        if (_bEgg && wave > 25)
        {
            bSavage = true;
        }
        var objectScale = this.Random(9, 11) * 0.1;
        var maxSpeedMult = 1.2;
        var dinoType = dinos[this.Random(0, dinos.length - 1)];
        switch (dinoType)
        {
            case Dinosaur.LIZARD:
                waveMult = Math.max(2, waveMult);
                maxSpeedMult = 10;
                objectScale = this.Random(10, 15) * 0.1;
                break;
            case Dinosaur.CHICKEN:
                waveMult = Math.max(0.5, waveMult);
                objectScale = this.Random(10, 15) * 0.1;
                break;
            case Dinosaur.PTERODACTYL:
                spawnPos = [this.RandomBoolean() ? 0 : this.getMapWidth(), this.RandomBoolean() ? 0 : this.getMapHeight()];
                maxSpeedMult = 1.5;
                waveMult = Math.max(1, waveMult);
                break;
        }
        var indicatorData = null;
        if (bSavage)
        {
            indicatorData = {
                icon: "icon_indicator_decoy",
                iconTint: 0xFF0000,
                bClamp: false
            }
        }
        else if (dinoType == Dinosaur.TREX)
        {
            indicatorData = {
                icon: "item_trex",
                bgIcon: "icon_triangle_bg",
                iconTint: Colours.ENEMY,
                bClamp: false
            }
        }
        var dino = this.createDinosaur({
            id: this.getRandomUniqueId(),
            x: spawnPos[0],
            y: spawnPos[1],
            team: 1,
            dinoType: dinoType,
            bBot: true,
            botSkill: botSkill,
            bRegenHealth: false,
            speedMultiplier: Math.min(maxSpeedMult, waveMult * (this.Random(90, 100) * 0.01)),
            healthMultiplier: healthMultiplier,
            bSavage: bSavage,
            objectScale: bSavage ? Math.min(1.5, 1.1 + (wave * 0.01)) : objectScale,
            indicatorData: indicatorData
        });
        if (bSavage)
        {
            dino.data.bImmuneToStun = wave > 25;
        }
        else if (dino.data.dinoType != Dinosaur.CHICKEN)
        {
            var colours = [
                (Math.random() * 16777215),
                0xFFFF00,
                0x00FFFF,
                0x0000FF,
                0xA020F0,
                0xFF00FF
            ];
            dino.data.colour = colours[this.Random(0, colours.length - 1)];
        }
        dino.data.maxHealth = dino.data.health;
        this.pushObjectDataUpdate(dino.data.id, ["health", "maxHealth", "colour", "bSavage"]);
        if (this.game.gameModeId)
        {

        }
        return dino;
    }

    addEvolutionKill(_killerId)
    {
        if (this.game.gameModeId != GameMode.EVOLUTION)
        {
            return;
        }
        var ps = this.getPlayerById(_killerId);
        var curDino = this.getObjectById(_killerId);
        this.game.gameModeData.dinoKills++;
        if (this.game.gameModeData.dinoKills >= this.game.gameModeData.dinoKillsMax)
        {
            this.game.gameModeData.dinoIndex++;
            if (this.game.gameModeData.dinoIndex >= this.game.gameModeData.dinos.length)
            {
                var scores = this.game.gameModeData.scores;
                var team = ps ? ps.team : (curDino ? curDino.data.team : null);
                if (team != null)
                {
                    scores[team]++;
                    this.game.gameModeData.scores = scores;
                    this.onEvent({
                        eventId: GameServer.EVENT_GAME_UPDATE,
                        data: {
                            scores: scores
                        }
                    });
                    this.requestEvent({
                        eventId: GameServer.EVENT_GAME_END,
                        condition: MatchState.END_CONDITION_SCORE,
                        winningTeam: team,
                        cameraTargetId: ps.id
                    });
                }
            }
            else
            {
                this.game.gameModeData.dinoKills = 0;
                this.game.gameModeData.dinoPos = curDino ? curDino.position : null;
                this.game.gameModeData.bEvolve = true;
                var curDinoLevel = this.game.gameModeData.dinos[this.game.gameModeData.dinoIndex];
                this.game.gameModeData.dino = curDinoLevel.id;
                this.game.gameModeData.dinoKillsMax = curDinoLevel.kills;
                if (ps)
                {
                    this.setCurrentDinosaur(ps, this.game.gameModeData.dino);
                }
                var players = this.getPlayersOnTeam(1);
                for (var i = 0; i < players.length; i++)
                {
                    var curPlayer = players[i];
                    if (curPlayer.id != _killerId)
                    {
                        curPlayer.currentDino = this.game.gameModeData.dino;
                        this.onEvent({
                            eventId: GameServer.EVENT_PLAYER_UPDATE,
                            playerId: curPlayer.id,
                            data: {
                                currentDino: curPlayer.currentDino
                            }
                        });
                    }
                }
                this.removeNextStep(curDino);                
                //Spawn airdrop
                var map = this.getCurrentMapData();
                var sentryItems = [
                    Item.SENTRY,
                    Item.SENTRY,
                    Item.SENTRY,
                    Item.SENTRY_FLAME
                ];
                var chars = this.getCharactersOnTeam(0);
                var airdropItems = [];
                if (this.getNumMountedWeaponsOnTeam(0) < 5)
                {
                    airdropItems.push({
                        type: ObjectType.CRATE,
                        crateType: Crate.ITEM,
                        itemId: sentryItems[this.Random(0, sentryItems.length - 1)]
                    });
                }
                var bOsprey = this.game.gameModeData.dinoIndex > Math.ceil(this.game.gameModeData.dinos.length * 0.5);
                if (bOsprey)
                {
                    airdropItems.push({
                        type: ObjectType.CRATE,
                        crateType: Crate.AMMO
                    });
                }
                var heli = this.createHelicopter([this.RandomBoolean() ? 0 : this.getMapWidth(), this.RandomBoolean() ? this.getMapHeight() : 0], {
                    vehicleId: bOsprey ? Helicopter.OSPREY : Helicopter.MH6,
                    team: 0,
                    destination: chars[0] ? chars[0].position : map.storeSpawn,
                    items: airdropItems,
                    bAutomated: true
                });
                this.onEvent({
                    eventId: GameServer.EVENT_GAME_UPDATE,
                    data: {
                        bEvolve: true,
                        dinoKills: this.game.gameModeData.dinoKills,
                        dinoKillsMax: this.game.gameModeData.dinoKillsMax,
                        dino: this.game.gameModeData.dino,
                        dinoIndex: this.game.gameModeData.dinoIndex,
                        heliType: heli.data.vehicleId
                    }
                });
            }
        }
        else
        {
            this.onEvent({
                eventId: GameServer.EVENT_GAME_UPDATE,
                data: {
                    dinoKills: this.game.gameModeData.dinoKills
                }
            });
        }
    }

    bodyIsInWall(_body)
    {
        if (_body)
        {
            var offset = 25;
            var data = _body.data;            
            if (data.bBot)
            {
                return this.isInWall([
                    [_body.position[0], _body.position[1]],
                    [_body.position[0] - offset, _body.position[1] - offset],
                    [_body.position[0] + offset, _body.position[1] + offset]
                ]);
            }
            else
            {
                return this.isInWall([
                    [_body.position[0], _body.position[1]],
                    [_body.position[0] - offset, _body.position[1] - offset],
                    [_body.position[0] + offset, _body.position[1] + offset],
                    [_body.position[0] + offset, _body.position[1] - offset],
                    [_body.position[0] - offset, _body.position[1] + offset]
                ]);
            }
        }
        return false;
    }

    isInWall(_points)
    {
        if (_points)
        {
            try
            {
                var num = 0;
                for (var i = 0; i < _points.length; i++)
                {
                    let point = _points[i];
                    if (point[0] < 0 || point[0] > this.getMapWidth() || point[1] < 0 || point[1] > this.getMapHeight())
                    {
                        return true;
                    }
                    var mapBody = this.getMapStructure();
                    var walls = mapBody ? [mapBody] : (this.game.bMultiplayer ? this.getGrounds() : null);
                    if (walls)
                    {
                        var bodies = this.game.world.hitTest(point, walls, 20);
                        if (bodies && bodies.length > 0)
                        {
                            num++;
                        }
                        else
                        {
                            return false;
                        }
                    }
                }     
                return num >= _points.length;
            }
            catch (e)
            {
                this.onGameError(e);
            }
        }
        return false;
    }

    getRandomItemId()
    {
        if (this.game.bOpenWorld)
        {
            var items = [
                Item.SENTRY,
                Item.SENTRY_SHOTGUN,
                Item.SENTRY_GRENADE,
                Item.SENTRY_SNIPER,
                Item.SENTRY_FLAME,
                Item.M2,
                Item.AIRSTRIKE,
                Item.AIRSTRIKE_NAPALM
            ];
        }
        else
        {
            items = [
                Item.SENTRY,
                Item.SENTRY_SHOTGUN,
                Item.SENTRY_GRENADE,
                Item.SENTRY_SNIPER,
                Item.SENTRY_FLAME,
                Item.M2,
                Item.M242,
                Item.AIRSTRIKE,
                Item.AIRSTRIKE_NAPALM
            ];
            if (this.Random(1, 5) == 1)
            {
                items.push(Item.BGM71);
            }
        }
        return items[this.Random(0, items.length - 1)];
    }

    spawnSurvivalEnemyEgg(_num)
    {
        var items = [];
        var wave = this.game.gameModeData.wave;        
        if (wave >= 20)
        {
            var eggType = Egg.MASSIVE;
            var len = this.Random(6, 8);
        }
        else if (wave >= 8)
        {
            eggType = Egg.HUGE;
            len = this.Random(4, 6);
        }
        else
        {
            len = 4;
            eggType = Egg.LARGE;
        }
        for (var i = 0; i < len; i++)
        {
            if (this.game.gameModeData.enemiesSpawned < this.game.gameModeData.numEnemies && this.getNumPawnsOnTeam(1) < this.settings.maxSurvivalEnemies)
            {
                items.push({
                    type: ObjectType.DINOSAUR,
                    dinoType: this.getRandomDinosaur(),
                    bSurvival: true
                });
                this.game.gameModeData.enemiesSpawned++;
            }
        }
        var map = this.getCurrentMapData();
        var egg = this.createEgg(map.spawns[this.Random(0, map.spawns.length - 1)], {
            eggType: eggType,
            team: 1,
            items: items
        });
        if (wave > 50)
        {
            egg.health = egg.maxHealth = egg.health + (wave * 200);
        }
        else if (wave > 25)
        {
            egg.health = egg.maxHealth = egg.health + (wave * 150);
        }
        else if (wave > 10)
        {
            egg.health = egg.maxHealth = egg.health + (wave * 100);
        }
        return egg;
    }

    spawnSurvivalEnemyAirdrop()
    {
        var wave = this.game.gameModeData.wave;
        var char = this.getSurvivalEnemyCharacterData();
        char.type = ObjectType.CHARACTER;
        var cars = [Car.GROWLER, Car.LAV25];
        var characters = [];
        for (var i = 0; i < 3; i++)
        {
            if (this.game.gameModeData.enemiesSpawned < this.game.gameModeData.numEnemies)
            {
                characters.push(char);
                this.game.gameModeData.enemiesSpawned++;
            }
        }
        var items = [
            {
                type: ObjectType.CAR,
                team: 1,
                playerId: null,
                vehicleId: cars[this.Random(0, cars.length - 1)],
                bAutomated: !characters.length,
                characters: characters
            }
        ];
        var map = this.getCurrentMapData();
        var pos = this.getBestSurvivalSpawnPosition(1);
        if (wave >= 25)
        {
            var weapons = [
                [
                    {
                        id: "m240"
                    }
                ]
            ];
        }
        var heli = this.createHelicopter([this.RandomBoolean() ? 0 : this.getMapWidth(), this.RandomBoolean() ? 0 : this.getMapHeight()], {
            vehicleId: Helicopter.SEAKNIGHT,
            team: 1,
            destination: this.clone(pos),
            items: items,
            bAutomated: true,
            destinationTimer: 0.1,
            bDropItemsWhenDestroyed: false,
            weapons: weapons
        });
        var wave = this.game.gameModeData.wave;
        if (wave > 25)
        {
            this.setMaxHealth(heli, heli.data.maxHealth + ((wave - 25) * 250));
        }
        if (heli && items)
        {
            for (var i = 0; i < items.length; i++)
            {
                let item = items[i];  
                if (item.bAutomated)
                {
                    this.game.gameModeData.enemiesSpawned++;
                }
            }
        }
        return heli;
    }

    spawnSurvivalEnemyTurret()
    {        
        var wave = this.game.gameModeData.wave;
        if (wave >= 15)
        {            
            var types = [
                MountedWeapon.SENTRY_GRENADE,
                MountedWeapon.SENTRY_SNIPER,
                MountedWeapon.SENTRY_FLAME,
                MountedWeapon.SENTRY_RAILGUN
            ];
        }
        else
        {
            var types = [
                MountedWeapon.SENTRY,
                MountedWeapon.SENTRY_SHOTGUN,
                MountedWeapon.SENTRY_GRENADE,
                MountedWeapon.SENTRY_SNIPER,
                MountedWeapon.SENTRY_FLAME
            ];
        }
        var vehicleId = types[this.Random(0, types.length - 1)];
        var pos = this.getBestSurvivalSpawnPosition(1);
        if (this.getNumHelicoptersOnTeam(0) >= 1 && this.Random(1, 2) == 1)
        {
            vehicleId = MountedWeapon.SENTRY_SAM;
            pos = this.getBestSpawnPosition(1);
        }
        var items = [
            {
                type: ObjectType.MOUNTED_WEAPON,
                team: 1,
                playerId: null,
                vehicleId: vehicleId,
                bAutomated: true
            }
        ];
        //var chars = this.getCharactersOnTeam(0);
        var heliType = Helicopter.MH6;
        if (wave == 12 || (wave >= 10 && this.RandomBoolean()))
        {
            heliType = Helicopter.SEAKNIGHT;
        }   
        if (wave >= 25)
        {
            var weapons = [
                [
                    {
                        id: "m240"
                    }
                ]
            ];
        }
        var heli = this.createHelicopter([this.RandomBoolean() ? 0 : this.getMapWidth(), this.RandomBoolean() ? 0 : this.getMapHeight()], {
            vehicleId: heliType,
            team: 1,
            destination: this.clone(pos),
            items: items,
            bAutomated: true,
            destinationTimer: 0.1,
            bDropItemsWhenDestroyed: false,
            weapons: weapons,
            tint: 0x666666
        });
        var wave = this.game.gameModeData.wave;
        if (wave >= 15)
        {
            heli.data.flares = 1;
        }
        if (wave > 25)
        {
            this.setMaxHealth(heli, heli.data.maxHealth + ((wave - 25) * 250));
        }
        if (heli && heli.data.items)
        {
            this.game.gameModeData.enemiesSpawned += heli.data.items.length;
        }
        else
        {
            this.game.gameModeData.enemiesSpawned++;
        }
        return heli;
    }

    setMaxHealth(_body, _val)
    {
        if (_body)
        {
            var data = _body.data;
            data.health = data.maxHealth = _val;
            this.pushObjectDataUpdate(data.id, "health", "maxHealth");
        }
    }

    spawnSurvivalEnemyBigfoot()
    {
        var spawnPos = this.getBestSpawnPosition(1);
        var wave = this.game.gameModeData.wave;
        var avatar = this.getAvatarDataById(AvatarPresets.BIGFOOT);
        var skillMult = 0.5;
        var botSkill = Math.min(BotSkill.SKILL_GOD, Math.floor(wave * skillMult) + 1);
        var health = 10000 + (wave * 100);
        var char = this.createCharacter({
            id: this.getRandomUniqueId(),
            x: spawnPos[0],
            y: spawnPos[1],
            team: 1,
            inventory: [],
            melee: this.getRandomMelee().id,
            equipment: "molotov",
            avatar: avatar,
            bBot: true,
            botSkill: botSkill,
            health: health,
            bRegenHealth: false,
            bZombie: true,
            bInteract: false,
            objectScale: this.Random(13, 16) * 0.1,
            speedMultiplier: 1 + Math.min(0.75, (wave * 0.1)) + (this.Random(10, 15) * 0.05),
            headScale: 0.75,
            legScale: 1.5,
            pawnName: "Bigfoot",
            reward: 1000
        });
        char.data.bDropWeapons = false;
        if (wave >= 25)
        {
            char.data.bImmuneToStun = true;
        }
        var wpn = char.data.inventory[Character.INDEX_MELEE];
        if (wpn)
        {
            if (wave >= 25)
            {
                wpn.fireRate = Math.round(wpn.fireRate * 0.25);
            }
            else if (wave >= 10)
            {
                wpn.fireRate = Math.round(wpn.fireRate * 0.5);
            }
        }
        return char;
    }

    spawnSurvivalEnemyZombie(_bJuggernaut)
    {
        var spawnPos = this.getBestSpawnPosition(1);        
        var wave = this.game.gameModeData.wave;
        if (this.game.gameModeId == GameMode.SURVIVAL_PANDEMONIUM)
        {
            var bJuggernaut = _bJuggernaut;
        }
        else
        {
            bJuggernaut = wave % 5 == 0 || (wave >= 5 && this.Random(1, Math.max(5, 40 - wave)) == 1);
        }
        var avatar = this.getAvatarDataById(bJuggernaut ? AvatarPresets.ZOMBIE_JUGGERNAUT : AvatarPresets.ZOMBIE);
        var skillMult = bJuggernaut ? 0.5 : 0.25;
        var botSkill = Math.min(BotSkill.SKILL_GOD, Math.floor(wave * skillMult) + 1);
        var multiplier = wave >= 25 ? 200 : 100;        
        var speedMult = 1 + (wave * 0.125);
        var speedMult2 = (this.Random(3, 10) * 0.1) * (bJuggernaut ? 0.35 : 1);
        speedMult = Math.min(speedMult * speedMult2, 2);
        var health = Math.round(100 + (wave * multiplier * (1 - speedMult2))) * (bJuggernaut ? 5 : 1);
        var damageMultipliers = {};
        if (bJuggernaut)
        {
            damageMultipliers = {
                1: 0.35,
                4: 0.1
            };
        }
        if (wave >= 10)
        {
            var melee = this.getRandomMelee().id
        }
        else
        {
            melee = "melee_knife";
        }
        var equipment = null;
        if (bJuggernaut)
        {
            equipment = "knife";
            var objectScale = 2;
        }
        else if (wave >= 10)
        {
            equipment = "blast_vest";
            objectScale = this.Random(10, 15) * 0.1;
        }
        var char = this.createCharacter({
            id: this.getRandomUniqueId(),
            x: spawnPos[0],
            y: spawnPos[1],
            team: 1,
            inventory: [],
            melee: melee,
            equipment: equipment,
            avatar: avatar,
            bBot: true,
            botSkill: botSkill,
            health: health,
            bRegenHealth: false,
            bJuggernaut: bJuggernaut,
            bZombie: true,
            damageMultipliers: damageMultipliers,
            bInteract: false,
            objectScale: objectScale,
            pawnName: bJuggernaut ? "Zombie Juggernaut" : null
        });
        char.data.maxSpeed *= speedMult;
        char.data.bDropWeapons = false;
        if (bJuggernaut)
        {
            char.data.bImmuneToStun = true;
            char.data.reward = 1000;
        }        
        var wpn = char.data.inventory[Character.INDEX_MELEE];
        if (wpn)
        {
            if (wave >= 25)
            {
                wpn.fireRate = Math.round(wpn.fireRate * 0.25);
            }
            else if (wave >= 10 || bJuggernaut)
            {
                wpn.fireRate = Math.round(wpn.fireRate * 0.5);
            }
        }        
        return char;
    }

    getOpenWorldCharacterData(_team)
    {
        var spawnPos = this.getBestSpawnPosition(_team);

        var classData = this.getBotClasses();
        var classes = [Classes.ASSAULT, Classes.COMMANDO, Classes.SUPPORT, Classes.HUNTER];
        var avatar = classData[classes[this.Random(0, classes.length - 1)]].avatar[_team == 0 ? Faction.DINOGEN : Faction.MILITIA];

        var pawnName = null;
        var bJuggernaut = false;
        if (bJuggernaut)
        {
            avatar = this.getAvatarDataById(AvatarPresets.JUGGERNAUT);
            var weaponTypes = [Weapon.TYPE_LMG];
            pawnName = "Juggernaut";
        }
        else
        {
            avatar.body = Character.BODY_MILITIA;
            var hairs = [
                Character.HAIR_BALD,
                Character.HAIR_BUZZED,
                Character.HAIR_SHORT,
                Character.HAIR_LONG
            ];
            avatar.hair = hairs[this.Random(0, hairs.length - 1)];
            var beards = [
                Character.BEARD_NONE,
                Character.BEARD_FULL
            ];
            avatar.beard = beards[this.Random(0, beards.length - 1)];
            var heads = [
                Character.HEAD_NONE,
                Character.HEAD_OPFOR_HELMET,
                Character.HEAD_MILITIA_SNIPER,
                Character.HEAD_MILITIA_RADIO
            ];
            avatar.head = heads[this.Random(0, heads.length - 1)];
            var facewears = [
                Character.FACEWEAR_NONE,
                Character.FACEWEAR_GAITER
            ];
            avatar.facewear = facewears[this.Random(0, facewears.length - 1)];
            avatar.hairColour = this.getRandomHairColour();
            avatar.hair = this.getRandomHair();
            weaponTypes = [
                Weapon.TYPE_SMG,
                Weapon.TYPE_CARBINE,
                Weapon.TYPE_RIFLE,
                Weapon.TYPE_LMG,
                Weapon.TYPE_DMR,
                Weapon.TYPE_SNIPER,
                Weapon.TYPE_SHOTGUN,
                Weapon.TYPE_LAUNCHER
            ];
        }
        var wpns = [];
        for (var i = 0; i < weaponTypes.length; i++)
        {
            wpns = wpns.concat(this.getAllWeaponsByType(weaponTypes[i]));
        }
        if (bJuggernaut)
        {
            wpns.push(this.getWeaponData("minigun"), this.getWeaponData("railgun"));
        }
        var primary = this.getWeaponData(wpns[this.Random(0, wpns.length - 1)].id);
        this.setRandomWeaponMods(primary);
        var inventory = [
            {
                id: primary.id,
                mods: primary.mods
            }
        ];
        var secondaryTypes = [
            Weapon.TYPE_PISTOL,
            Weapon.TYPE_MACHINE_PISTOL,
            Weapon.TYPE_LAUNCHER,
            Weapon.TYPE_WEAPON_TACTICAL
        ];
        if (secondaryTypes.length > 1)
        {
            var secondary = this.getAllWeaponsByType(secondaryTypes[this.Random(0, secondaryTypes.length - 1)]);
            inventory.push({
                id: secondary[this.Random(0, secondary.length - 1)].id
            });
        }
        var grenades = [];
        if (this.Random(1, 5) == 1)
        {
            grenades.push("frag", "stun", "flashbang");
        }
        var equipment = ["stim", "juice", "kevlar", "blast_vest"];
        if (this.Random(1, 5) == 1)
        {
            equipment.push("jammer", "trophy", "claymore", "betty")
        }
        var melees = this.getAllWeaponsByType(Weapon.TYPE_MELEE);
        var melee = melees[this.Random(0, melees.length - 1)];
        var botSkill = BotSkill.SKILL_NORMAL;
        var health = 200;
        var speedMult = 1;
        if (bJuggernaut)
        {
            var damageMultipliers = {
                1: 0.35,
                4: 0.1
            };
            health *= 10;
            speedMult = 0.8;
        }
        var data = {
            x: spawnPos[0],
            y: spawnPos[1],
            team: 1,
            inventory: inventory,
            melee: melee,
            grenade: grenades[this.Random(0, grenades.length - 1)],
            equipment: equipment[this.Random(0, equipment.length - 1)],
            avatar: avatar,
            bBot: true,
            botSkill: botSkill,
            health: health,
            bRegenHealth: true,
            bJuggernaut: bJuggernaut,
            damageMultipliers: damageMultipliers,
            bInteract: true,
            speedMultiplier: speedMult,
            reward: bJuggernaut ? 1000 : null,
            bSwitchToMelee: false, //!bJuggernaut,
            pawnName: pawnName
        };
        return data;
    }

    getSurvivalEnemyCharacterData(_bJuggernaut)
    {
        var spawnPos = this.getBestSpawnPosition(1);

        var classData = this.getBotClasses();
        var classes = [Classes.ASSAULT, Classes.COMMANDO, Classes.SUPPORT, Classes.HUNTER];
        var avatar = classData[classes[this.Random(0, classes.length - 1)]].avatar[Faction.MILITIA];

        var wave = this.game.gameModeData.wave;
        var pawnName = null;
        if (this.game.gameModeId == GameMode.SURVIVAL_PANDEMONIUM)
        {
            var bJuggernaut = _bJuggernaut;
        }
        else
        {
            bJuggernaut = wave % 5 == 0 || (wave >= 5 && this.Random(1, Math.max(10, 30 - wave)) == 1);
        }
        if (bJuggernaut)
        {
            avatar = this.getAvatarDataById(AvatarPresets.JUGGERNAUT);
            var weaponTypes = [Weapon.TYPE_LMG];
            if (wave > 10 && this.Random(1, 3) == 1)
            {
                var bCommander = true;
                pawnName = "Commander";
                weaponTypes = [Weapon.TYPE_DMR];
                avatar = this.getAvatarDataById(AvatarPresets.COMMANDER);
            }
            else
            {
                pawnName = "Juggernaut";
            }
        }
        else
        {
            avatar.body = Character.BODY_MILITIA;
            var hairs = [
                Character.HAIR_BALD,
                Character.HAIR_BUZZED,
                Character.HAIR_SHORT,
                Character.HAIR_LONG
            ];
            avatar.hair = hairs[this.Random(0, hairs.length - 1)];
            var beards = [
                Character.BEARD_NONE,
                Character.BEARD_FULL
            ];
            avatar.beard = beards[this.Random(0, beards.length - 1)];
            var heads = [
                Character.HEAD_NONE,
                Character.HEAD_OPFOR_HELMET,
                Character.HEAD_MILITIA_SNIPER,
                Character.HEAD_MILITIA_RADIO
            ];
            avatar.head = heads[this.Random(0, heads.length - 1)];
            var facewears = [
                Character.FACEWEAR_NONE,
                Character.FACEWEAR_GAITER
            ];
            avatar.facewear = facewears[this.Random(0, facewears.length - 1)];
            avatar.hairColour = this.getRandomHairColour();
            avatar.hair = this.getRandomHair();
            weaponTypes = [];
            if (wave < 10)
            {
                weaponTypes.push(Weapon.TYPE_PISTOL, Weapon.TYPE_MACHINE_PISTOL);
            }
            if (wave < 20 && wave >= 3)
            {
                weaponTypes.push(Weapon.TYPE_SMG);
            }
            if (wave < 30)
            {
                if (wave >= 5)
                {
                    weaponTypes.push(Weapon.TYPE_CARBINE, Weapon.TYPE_RIFLE, Weapon.TYPE_LMG);
                }
            }
            else
            {
                weaponTypes.push(Weapon.TYPE_LMG);
            }
            if (wave >= 15)
            {
                weaponTypes.push(Weapon.TYPE_LAUNCHER);
            }
            if (wave >= 10)
            {
                weaponTypes.push(Weapon.TYPE_DMR, Weapon.TYPE_SNIPER, Weapon.TYPE_SHOTGUN);
            }
        }
        var wpns = [];
        for (var i = 0; i < weaponTypes.length; i++)
        {
            wpns = wpns.concat(this.getAllWeaponsByType(weaponTypes[i]));
        }        
        if (bJuggernaut && !bCommander)
        {
            if (wave >= 10)
            {
                wpns = [this.getWeaponData("m82")];
            }
            if (wave >= 15)
            {
                wpns = [this.getWeaponData("minigun"), this.getWeaponData("flamethrower")];
                var objectScale = 1.25;
            }
            if (wave >= 20)
            {
                wpns.push(this.getWeaponData("railgun"));
                var objectScale = 1.5;
            }
        }
        if (!bJuggernaut)
        {
            if (wave >= 20)
            {
                wpns.push(this.getWeaponData("bow"), this.getWeaponData("crossbow"), this.getWeaponData("quadra"));
            }
            if (wave >= 25)
            {
                wpns.push(this.getWeaponData("railgun"));
            }
        }
        var primary = this.getWeaponData(wpns[this.Random(0, wpns.length - 1)].id);
        this.setRandomWeaponMods(primary);
        if (wave >= 25)
        {
            switch (primary.round)
            {
                case "556mm":
                case "762mm":
                case "762mm_39":
                case "762mm_54":
                case "50cal":
                case "44":
                    primary.mods[Mods.TYPE_AMMO] = Mods.AMMO_EXPLOSIVE;
                    break;
            }
        }
        var inventory = [
            {
                id: primary.id,
                mods: primary.mods
            }
        ];
        var secondaryTypes = [];
        if (wave >= 10)
        {
            secondaryTypes.push(Weapon.TYPE_LAUNCHER);
        }
        if (wave >= 3 && !bJuggernaut)
        {
            secondaryTypes.push(Weapon.TYPE_SHOTGUN);
        }
        if (secondaryTypes.length > 1)
        {
            var secondary = this.getAllWeaponsByType(secondaryTypes[this.Random(0, secondaryTypes.length - 1)]);
            inventory.push({
                id: secondary[this.Random(0, secondary.length - 1)].id
            });
        }
        var grenades = [];
        if (wave >= 5 && this.Random(1, 5) == 1)
        {
            grenades.push("frag", "stun", "flashbang");
        }
        if (bJuggernaut)
        {
            var equipment = ["frag", "semtex", "stun", "flashbang"];
        }
        else
        {
            equipment = [];
            if (wave >= 3 && this.Random(1, 50) == 1)
            {
                equipment.push("jammer");
            }
            if (wave >= 5)
            {
                equipment.push("stim", "juice");
            }
            if (wave >= 8)
            {
                equipment.push("claymore", "betty", "c4");
                if (this.Random(1, 5) == 1)
                {
                    equipment.push("molotov");
                }
            }
            if (wave >= 10)
            {
                equipment.push("semtex", "kevlar", "blast_vest");
            }
            if (wave >= 15)
            {
                equipment.push("trophy");
            }
        }
        var melees = ["melee_knife", "melee_machete"];
        var melee = melees[this.Random(0, melees.length - 1)];
        var skillMult = this.game.gameModeId == GameMode.SURVIVAL_CHAOS ? 0.15 : 0.125;
        var botSkill = bCommander ? BotSkill.SKILL_GOD : Math.min(BotSkill.SKILL_GOD, Math.floor(wave * skillMult) + (bJuggernaut ? 3 : 0));
        var multiplier = wave <= 50 ? 3 : 5;
        var health = Math.round(100 + (wave * multiplier));
        var speedMult = 1;
        if (bJuggernaut)
        {
            var damageMultipliers = {
                1: 0.35,
                4: 0.1
            };
            health *= 10;
            speedMult = bCommander ? 1 : 0.8;
            melee = "melee_hatchet";
        }
        else if (primary.type == Weapon.TYPE_SHOTGUN)
        {
            health *= 2;
        }
        var data = {
            x: spawnPos[0],
            y: spawnPos[1],
            team: 1,
            inventory: inventory,
            melee: melee,
            grenade: grenades[this.Random(0, grenades.length - 1)],
            equipment: equipment[this.Random(0, equipment.length - 1)],
            avatar: avatar,
            bBot: true,
            botSkill: botSkill,
            health: health,
            bRegenHealth: false,
            bJuggernaut: bJuggernaut,
            damageMultipliers: damageMultipliers,
            bInteract: false,
            objectScale: objectScale,
            speedMultiplier: speedMult,
            reward: bJuggernaut ? 1000 : null,
            bSwitchToMelee: !bJuggernaut,
            pawnName: pawnName 
        };
        return data;
    }

    spawnSurvivalEnemyCharacter(_bJuggernaut)
    {
        var data = this.getSurvivalEnemyCharacterData(_bJuggernaut);
        var char = this.createCharacter(data);
        return char;
    }

    onSurvivalWaveComplete()
    {
        var gameData = this.game.gameModeData;
        if (gameData.bIntermission)
        {
            return;
        }
        this.startSurvivalWaveIntermission();
        var waveBonus = (gameData.wave * 75) * Math.max(1, gameData.wave * 0.25);
        waveBonus += Math.round(gameData.waveKills * 2);
        waveBonus += gameData.waveMelees * 50;
        var keys = Object.keys(gameData.killTypes);
        for (var i = 0; i < keys.length; i++)
        {
            var key = keys[i];
            var reward = 0;
            switch (key)
            {
                case ObjectType.TANK:
                    reward = 500;
                    break;
                case ObjectType.EGG:
                case ObjectType.HELICOPTER:
                    reward = 250;
                    break;
                case ObjectType.CAR:
                    reward = 100;
                    break;
            }
            waveBonus += reward * gameData.killTypes[key];
        }
        waveBonus = this.RoundToNearest(Math.min(10000, Math.max(100, waveBonus)));
        this.onEvent({
            eventId: GameServer.EVENT_GAME_UPDATE,
            data: {
                wave: gameData.wave,
                bWaveComplete: true,
                reward: waveBonus,
                waveKills: gameData.waveKills,
                waveMelees: gameData.waveMelees,
                killTypes: gameData.killTypes
            }
        });
        this.dispatchTrigger({
            event: "survivalWaveCompleted",
            wave: gameData.wave,
            reward: waveBonus,
            waveKills: gameData.waveKills,
            waveMelees: gameData.waveMelees
        });
        switch (this.game.gameModeId)
        {
            case GameMode.SURVIVAL_PANDEMONIUM:
                if (gameData.wave % 5 == 0)
                {
                    //Airdrop tactical crate
                    this.createHelicopter([this.RandomBoolean() ? 0 : this.getMapWidth(), this.RandomBoolean() ? 0 : this.getMapHeight()], {
                        vehicleId: Helicopter.MH6,
                        team: 0,
                        destination: this.getRandomSpawnPosition(),
                        items: [
                            {
                                type: ObjectType.CRATE,
                                crateType: Crate.STORE,
                                destroyTimer: 60,
                                mass: 0,
                                bDisposable: false
                            }
                        ],
                        bAutomated: true,
                        pawnName: "Tactical Crate Airdrop"
                    });
                    this.onEvent({
                        eventId: GameServer.EVENT_MESSAGE_ADD,
                        data: {
                            message: "STR_TACTICAL_CRATE_INBOUND",
                            hqId: "hq_friendly_tactical_crate"
                        }
                    });
                }
                break;
            case GameMode.SURVIVAL_CHICKEN:
                if (this.getCrates().length < 5)
                {
                    let heliItems = [
                        {
                            type: ObjectType.CRATE,
                            crateType: Crate.AMMO
                        },
                        {
                            type: ObjectType.CRATE,
                            crateType: Crate.WEAPON,
                            items: [
                                {
                                    type: ObjectType.DROPPED_WEAPON,
                                    weaponData: this.getRandomWeapon(),
                                    bRandomVelocity: true
                                },
                                {
                                    type: ObjectType.DROPPED_WEAPON,
                                    weaponData: this.getRandomWeapon(),
                                    bRandomVelocity: true
                                },
                                {
                                    type: ObjectType.DROPPED_WEAPON,
                                    weaponData: this.getRandomWeapon(),
                                    bRandomVelocity: true
                                },
                                {
                                    type: ObjectType.DROPPED_WEAPON,
                                    weaponData: this.getRandomWeapon(),
                                    bRandomVelocity: true
                                },
                                {
                                    type: ObjectType.DROPPED_WEAPON,
                                    weaponData: this.getRandomWeapon(),
                                    bRandomVelocity: true
                                }
                            ]
                        }
                    ];
                    let turrets = [
                        Item.SENTRY,
                        Item.SENTRY_SHOTGUN,
                        Item.SENTRY_FLAME,
                        Item.SENTRY_SAM,
                        Item.M2
                    ];
                    heliItems.push({
                        type: ObjectType.CRATE,
                        crateType: Crate.ITEM,
                        itemId: turrets[this.Random(0, turrets.length - 1)]
                    });
                    this.ShuffleArray(heliItems);
                    heliItems.length = this.Random(1, heliItems.length - 1);
                    this.createHelicopter([this.RandomBoolean() ? 0 : this.getMapWidth(), this.RandomBoolean() ? 0 : this.getMapHeight()], {
                        vehicleId: Helicopter.MH6,
                        team: 0,
                        destination: this.getRandomSpawnPosition(),
                        items: heliItems,
                        bAutomated: true
                    });
                    this.onEvent({
                        eventId: GameServer.EVENT_MESSAGE_ADD,
                        data: {
                            message: "STR_AIRDROP_INBOUND",
                            hqId: "hq_friendly_package"
                        }
                    });
                }
                if (this.game.gameModeData.wave > 5 && this.getNumCars() < 2)
                {
                    let cars = [
                        Car.GROWLER,
                        Car.MRAP,
                        Car.LAV25
                    ];
                    let carId = cars[this.Random(0, cars.length - 1)];
                    this.createHelicopter([this.RandomBoolean() ? 0 : this.getMapWidth(), this.RandomBoolean() ? 0 : this.getMapHeight()], {
                        vehicleId: Helicopter.SEAKNIGHT,
                        team: 0,
                        destination: this.getBestSpawnPosition(0),
                        items: [
                            {
                                type: ObjectType.CAR,
                                vehicleId: carId,
                                team: 0
                            }
                        ],
                        bAutomated: true
                    });
                    this.onEvent({
                        eventId: GameServer.EVENT_MESSAGE_ADD,
                        data: {
                            message: "STR_AIRDROP_INBOUND",
                            hqId: "hq_friendly_item_" + carId
                        }
                    });
                }                
                break;
        }
        for (var i = 0; i < this.game.players.length; i++)
        {
            let ps = this.game.players[i];
            this.addPlayerMoney(ps.id, waveBonus);
        }       
        setTimeout(() =>
        {
            if (this.game)
            {
                this.respawnAllPlayers();
            }
        }, 100);        
    }

    addPlayerMoney(_playerId, _val)
    {
        var ps = this.getPlayerById(_playerId);
        if (ps)
        {
            ps.money = Math.min(this.settings.maxPlayerMoney, Math.max(0, ps.money + _val));
            this.requestEvent({
                eventId: GameServer.EVENT_PLAYER_UPDATE,
                playerId: ps.id,
                data: {
                    money: ps.money
                }
            });
        }
    }

    respawnPlayer(_id, _data)
    {       
        var ps = this.getPlayerById(_id);
        if (ps)
        {
            if (!_data)
            {
                if (ps.respawnData)
                {
                    _data = ps.respawnData;
                }
                else
                {
                    _data = {};
                }
            }
            if (ps.bSpectator)
            {
                return;
            }
            ps.respawnData = _data;
            this.removeObject(this.getReviverByPlayerId(ps.id));            
            if (_data.currentFaction)
            {
                ps.currentFaction = _data.currentFaction;
                this.onEvent({
                    eventId: GameServer.EVENT_PLAYER_UPDATE,
                    playerId: ps.id,
                    data: {
                        currentFaction: ps.currentFaction
                    }
                });
            }
            if (_data.dinoType)
            {
                ps.currentDino = _data.dinoType;
            }
            var inventory = null;
            var melee = _data.melee !== undefined ? _data.melee : "melee_knife";
            var grenade = null;
            var grenadeAmmo = null;
            var equipment = null;
            var equipmentAmmo = null;
            if (_data.inventory)
            {
                inventory = this.clone(_data.inventory);
            }
            if (_data.equipment)
            {
                equipment = _data.equipment;
            }
            if (_data.grenade)
            {
                grenade = _data.grenade;
            }
            if (this.game.bSurvival || this.game.gameModeData.bAllowRevives)
            {
                if (ps.inventory)
                {
                    inventory = this.clone(ps.inventory);
                    ps.inventory = null;
                    melee = ps.melee;
                    equipment = ps.equipment;
                    grenade = ps.grenade;
                }
                else if (_data.inventory)
                {
                    inventory = _data.inventory;
                }
                else
                {
                    switch (this.game.gameModeId)
                    {
                        case GameMode.SURVIVAL_CHICKEN:
                            inventory = [
                                {
                                    id: "sawed_off",
                                    name: "Chicken Blaster",
                                    ammo: 200
                                },
                                {
                                    id: "m1187",
                                    name: "Musket",
                                    ammo: 400,
                                    mods: {
                                        ammo: Mods.AMMO_SLUG
                                    }
                                }
                            ];
                            melee = "melee_hatchet";
                            break;
                        case GameMode.SURVIVAL_ZOMBIE:
                            inventory = [
                                {
                                    id: "m4a1",
                                    ammo: 300,
                                    mods: {
                                        optic: Mods.OPTIC_EOTECH,
                                        accessory: Mods.ACCESSORY_MAG_ASSIST
                                    }
                                },
                                {
                                    id: "m3",
                                    ammo: 80,
                                    mods: {
                                        accessory: Mods.ACCESSORY_LASER,
                                        ammo: Mods.AMMO_HOLLOW_POINT
                                    }
                                }
                            ];
                            melee = "melee_machete";
                            break;
                        case GameMode.SURVIVAL_PANDEMONIUM:
                            inventory = [
                                {
                                    id: "g36c",
                                    ammo: 300,
                                    mods: {
                                        accessory: Mods.ACCESSORY_LASER
                                    }
                                },
                                {
                                    id: "g17",
                                    ammo: 300,
                                    mods: {
                                        accessory: Mods.ACCESSORY_LASER
                                    }
                                }
                            ];
                            equipment = "kevlar";
                            break;
                        case GameMode.EXTRACTION:
                            if (!inventory)
                            {
                                var classData = ps.classes[ps.currentClass];
                                melee = classData.melee;
                                grenade = classData.grenade;
                                equipment = classData.equipment;
                                inventory = [
                                    classData.primary,
                                    classData.secondary
                                ];
                            }
                            break;
                        case GameMode.OPEN_WORLD:
                            inventory = [
                                {
                                    id: "m9",
                                    ammo: 150
                                }
                            ];
                            equipment = "stim";
                            grenade = "smoke";
                            break;
                        default:
                            inventory = [
                                {
                                    id: "mp5",
                                    ammo: 300
                                },
                                {
                                    id: "m9",
                                    ammo: 300
                                }
                            ];
                            break;
                    }
                    grenade = _data.grenade !== undefined ? _data.grenade : (grenade != null ? grenade : "frag");
                    equipment = _data.equipment !== undefined ? _data.equipment : (equipment != null ? equipment : "ammo_box");
                }
            }
            else if (this.game.bRanked || this.game.gameSettings.bAllowClassSelection)
            {                
                if (!inventory)
                {
                    var classData = ps.classes[ps.currentClass];
                    melee = classData.melee;
                    grenade = classData.grenade;
                    equipment = classData.equipment;
                    inventory = [
                        classData.primary,
                        classData.secondary
                    ];
                }
            }
            if (!inventory)
            {
                inventory = [
                    {
                        id: "m9"
                    }
                ];
            }
            var pos = _data.position;
            if (pos)
            {
                var spawnPos = this.checkSpecialString(pos);
                spawnPos[0] += this.Random(-25, 25);
                spawnPos[1] += this.Random(-25, 25);
            }
            else if (this.game.bOpenWorld)
            {
                spawnPos = this.getSpawnPointForTeam(ps.team);
            }
            else if (this.game.bSurvival)
            {
                spawnPos = this.getSpawnPointForTeam(ps.team);
            }
            else
            {
                spawnPos = this.getSpawnPointForTeam(ps.team);
                var tacInserts = this.getEquipmentByPlayerId(ps.id, "tac_insert");
                if (tacInserts[0])
                {
                    spawnPos = tacInserts[0].position;
                }
            }
            if (this.game.bSurvival)
            {
                this.removeEquipmentByPlayerId(ps.id, "tac_insert");
            }
            else
            {
                this.removeEquipmentByPlayerId(ps.id);
                this.removeGrenadesByPlayerId(ps.id);
            }
            if (_data.team != null)
            {
                ps.team = _data.team;
                this.onEvent({
                    eventId: GameServer.EVENT_PLAYER_UPDATE,
                    playerId: ps.id,
                    data: {
                        team: ps.team
                    }
                });
            }
            if (!this.getObjectById(ps.id))
            {
                var charData = {
                    id: ps.id,
                    x: spawnPos[0],
                    y: spawnPos[1],
                    team: ps.team,
                    inventory: inventory,
                    melee: melee,
                    grenade: grenade,
                    grenadeAmmo: grenadeAmmo,
                    equipment: equipment,
                    equipmentAmmo: equipmentAmmo,
                    avatar: ps.avatar,
                    bBot: ps.bBot,
                    botSkill: ps.botSkill
                };
                var dinoType = ps.currentDino ? ps.currentDino : this.getRandomDinosaur();
                var playerDinoData = ps.dinosaurs ? ps.dinosaurs : {};
                var dinoData = {
                    id: ps.id,
                    x: spawnPos[0],
                    y: spawnPos[1],
                    dinoType: dinoType,
                    team: ps.team,
                    bBot: ps.bBot,
                    botSkill: ps.botSkill,
                    bCanInteract: this.game.gameSettings.bAllowDinosaurInteract,
                    colour: playerDinoData[dinoType] ? playerDinoData[dinoType].colour : null
                };
                switch (this.game.gameModeId)
                {
                    case GameMode.RAPTOR_HUNT:
                        if (ps.team == 1)
                        {
                            var playerDinoData = ps.dinosaurs ? ps.dinosaurs : {};
                            this.createDinosaur({
                                id: ps.id,
                                x: spawnPos[0],
                                y: spawnPos[1],
                                dinoType: Dinosaur.RAPTOR,
                                team: ps.team,
                                bBot: ps.bBot,
                                botSkill: ps.botSkill,
                                healthMultiplier: 1.2,
                                colour: playerDinoData[dinoType] ? playerDinoData[dinoType].colour : null
                            });
                        }
                        else
                        {
                            this.createCharacter(charData);
                        }
                        break;
                    case GameMode.TYRANT:
                        if (ps.team == 1)
                        {
                            var playerDinoData = ps.dinosaurs ? ps.dinosaurs : {};
                            var rex = this.createDinosaur({
                                id: ps.id,
                                x: spawnPos[0],
                                y: spawnPos[1],
                                dinoType: Dinosaur.TREX,
                                team: ps.team,
                                bBot: ps.bBot,
                                botSkill: ps.botSkill,
                                colour: playerDinoData[dinoType] ? playerDinoData[dinoType].colour : null
                            });
                            rex.data.regenThreshold = 0.25;
                        }
                        else
                        {
                            this.createCharacter(charData);
                        }
                        break;
                    case GameMode.EVOLUTION:
                        if (ps.team == 1)
                        {
                            if (ps.bBot && !ps.dinosaurs[ps.currentDino])
                            {
                                ps.dinosaurs[ps.currentDino] = {
                                    colour: this.getRandomDinosaurColour()
                                }
                            }
                            var playerDinoData = ps.dinosaurs ? ps.dinosaurs : {};
                            var dinoType = this.game.gameModeData.dino;
                            var dino = this.createDinosaur({
                                id: ps.id,
                                x: spawnPos[0],
                                y: spawnPos[1],
                                dinoType: dinoType,
                                team: ps.team,
                                bBot: ps.bBot,
                                botSkill: ps.botSkill,
                                bCanInteract: this.game.gameSettings.bAllowDinosaurInteract,
                                colour: playerDinoData[dinoType] ? playerDinoData[dinoType].colour : null
                            });                            
                            switch (this.game.gameModeData.dino)
                            {
                                case Dinosaur.COMPY:
                                    dino.data.damageMultipliers[DamageType.DAMAGE_BULLET] *= 0.5;
                                    dino.data.health = dino.data.maxHealth = Math.max(this.getCharacterMaxHealth() * 2, dino.data.maxHealth);
                                    break;
                                case Dinosaur.DILO:
                                case Dinosaur.RAPTOR:
                                case Dinosaur.NEEDLER:
                                case Dinosaur.PACHY:
                                    dino.data.damageMultipliers[DamageType.DAMAGE_BULLET] *= 0.75;
                                    break;
                            }
                            if (this.game.gameModeData.dino == Dinosaur.COMPY)
                            {
                                dino.data.health = dino.data.maxHealth = Math.max(this.getCharacterMaxHealth() * 2, dino.data.maxHealth);
                            }
                        }
                        else
                        {
                            this.createCharacter(charData);
                        }
                        break;

                    case GameMode.HUMANS_VS_DINOSAURS:
                        if (ps.team == 1)
                        {
                            this.createDinosaur(dinoData);
                        }
                        else
                        {
                            this.createCharacter(charData);
                        }
                        break;

                    default:
                        if (ps.currentFaction == ObjectType.DINOSAUR)
                        {
                            this.createDinosaur(dinoData);
                        }
                        else
                        {
                            this.createCharacter(charData);
                        }
                        break;
                }
                this.dispatchTrigger({
                    event: "playerRespawned",
                    playerId: ps.id,
                    playerIndex: this.game.players.indexOf(ps),
                    playerTeam: ps.team
                });
            }
            ps.respawnTimer = -1;
            ps.timer_respawn = null;
            if (this.matchInProgress() && this.game.gameModeData.bSpawnProtection)
            {
                this.startSpawnProtectionTimer(ps.id);
            }            
        }
        else
        {
            console.warn("Player doesn't exist:", _id);
        }
    }

    getRandomDinosaurColour()
    {
        var colours = [
            Colours.GREEN,
            Colours.BROWN,
            Colours.ORANGE,
            Colours.THEME,
            Colours.XP,
            Colours.ALLY,
            0x333333,
            0x666666,
            0x999999,
            0xFFFFFF,
            0xFFA500,
            0xFFFF00,
            0x00FF00,
            0x00FFFF,
            0x0000FF,
            0xA020F0,
            0xFF00FF
        ]
        return colours[this.Random(0, colours.length - 1)];
    }

    getRandomColour()
    {
        return this.Random(0x000000, 0xFFFFFF);
    }

    getRandomTreeType()
    {
        var trees = [
            "tree",
            "tree_small",
            "tree_palm",
            "tree_palm_small",
            "bush",
            "bush_palm"
        ];
        return trees[this.Random(0, trees.length - 1)];
    }

    getRandomDinosaur()
    {
        var dinos = [
            Dinosaur.COMPY,
            Dinosaur.COMPY,
            Dinosaur.DILO,
            Dinosaur.DILO,
            Dinosaur.PACHY,
            Dinosaur.PACHY,
            Dinosaur.RAPTOR,
            Dinosaur.RAPTOR,
            Dinosaur.ANKYLOSAURUS,
            Dinosaur.ANKYLOSAURUS,
            Dinosaur.NEEDLER,            
            Dinosaur.STEGOSAURUS,
            Dinosaur.SPINOSAURUS,
            Dinosaur.ALLOSAURUS,
            Dinosaur.CARNOTAURUS
        ];
        return dinos[this.Random(0, dinos.length - 1)];
    }

    getRandomOpenWorldDinosaur()
    {
        var dinos = [
            Dinosaur.LIZARD,
            Dinosaur.LIZARD,
            Dinosaur.COMPY,
            Dinosaur.COMPY,
            Dinosaur.DILO,
            Dinosaur.DILO,
            Dinosaur.PACHY,
            Dinosaur.PACHY,
            Dinosaur.RAPTOR,
            Dinosaur.RAPTOR,
            Dinosaur.ANKYLOSAURUS,
            Dinosaur.ANKYLOSAURUS,
            Dinosaur.NEEDLER,
            Dinosaur.STEGOSAURUS,
            Dinosaur.SPINOSAURUS,
            Dinosaur.ALLOSAURUS,
            Dinosaur.CARNOTAURUS,
            Dinosaur.PTERODACTYL            
        ];
        if (this.Random(1, 2) == 1)
        {
            dinos.push(Dinosaur.TREX);
        }
        return dinos[this.Random(0, dinos.length - 1)];
    }

    getPlayers()
    {
        return this.game.players;
    }

    getPlayersOnTeam(_team)
    {
        var arr = [];
        for (var i = 0; i < this.game.players.length; i++)
        {
            let player = this.game.players[i];
            if (player.team == _team)
            {
                arr.push(player);
            }
        }
        return arr;
    }

    setPlayerPing(_id, _ms)
    {
        var ps = this.getPlayerById(_id);
        if (ps && !ps.bBot)
        {
            ps.ping = _ms;
            this.onEvent({
                eventId: GameServer.EVENT_PLAYER_UPDATE,
                playerId: ps.id,
                data: {
                    ping: ps.ping
                }
            });
        }
    }

    updatePlayer(_data)
    {
        if (!_data)
        {
            return;
        }
        var ps = this.getPlayerById(_data.id);
        if (ps)
        {
            var keys = Object.keys(_data);
            for (var i = 0; i < keys.length; i++)
            {
                var key = keys[i];
                ps[key] = _data[key];
            }
            this.onEvent({
                eventId: GameServer.EVENT_PLAYER_UPDATE,
                playerId: ps.id,
                data: ps
            });
        }
    }

    getPlayerById(_id)
    {
        if (!this.game)
        {
            return;
        }
        var players = this.game.players;
        for (var i = 0; i < players.length; i++)
        {
            var ps = players[i];
            if (ps.id == _id)
            {
                return ps;
            }
        }
        return null;
    }

    addWorldBody(_body, _bAddToWorld = true)
    {
        if (_bAddToWorld)
        {
            if (!_body.shapes.length)
            {
                console.log("No shapes", _body);
            }
            this.game.world.addBody(_body);
        }
        var data = _body.data;
        if (data)
        {
            if (!data.id)
            {
                console.warn("Missing id", data);
            }
            this.game.objects[data.id] = _body;
            if (data.type)
            {
                if (!this.game.types[data.type])
                {
                    this.game.types[data.type] = [];
                }
                var types = this.game.types[data.type];
                if (types.indexOf(_body) == -1)
                {
                    types.push(_body);
                }
                else
                {
                    console.warn("Already exists");
                }
            }
            else
            {
                console.warn("Missing type", data);
            }
        }
        else
        {
            console.warn("No data for", _body);
        }
    }

    removeObjectById(_id)
    {
        var object = this.getObjectById(_id);
        if (object)
        {            
            this.removeNextStep(object);
        }
    }

    removeObject(_body)
    {
        if (_body)
        {
            if (!_body.data)
            {
                console.warn("No body data", _body);
            }
            var world = this.game.world;
            if (_body.constraint)
            {
                world.removeConstraint(_body.constraint);
                delete _body.constraint;
            }
            var data = _body.data;
            var id = data ? data.id : undefined;
            var pos = _body.position;
            var type = data ? data.type : null;
            var typeArray = this.game.types[type];
            if (typeArray)
            {
                var index = typeArray.indexOf(_body);
                if (index >= 0)
                {
                    typeArray.splice(index, 1);
                }
            }
            delete _body.data;
            world.removeBody(_body);      
            var keys = Object.keys(_body);
            for (var i = 0; i < keys.length; i++)
            {
                delete _body[keys[i]];
            }            
            if (id)
            {
                var players = this.game.players;
                for (var i = 0; i < players.length; i++)
                {
                    var ps = players[i];
                    if (ps.controllableId == id)
                    {
                        this.clearPlayerControllable(ps.id);
                        break;
                    }
                }
                switch (type)
                {
                    case ObjectType.REVIVER:
                        if (this.game.bOpenWorld && data.destroyTimer <= 0)
                        {
                            this.dropPlayerWeapons(data.playerId, pos);
                        }
                        break;
                    case ObjectType.OBSTACLE:
                        this.removeDirtyNodeObject(id);                        
                        break;
                    case ObjectType.ROCKET:
                        for (var key in this.game.objects)
                        {
                            let curPawn = this.game.objects[key];
                            if (curPawn.data && curPawn.data.currentRocketId == id)
                            {
                                delete curPawn.data.currentRocketId;
                                break;
                            }
                        }
                        break;
                }              
                delete this.game.objects[id];
                this.onEvent({
                    eventId: GameServer.EVENT_REMOVE_OBJECT,
                    id: id
                });
                return true;
            }
        }
        return false;
    }

    createRocket(_position, _data)
    {
        var body = new this.p2.Body({
            mass: 0.1,
            position: _position,
            angle: _data.angle
        });
        var damage = 0;
        var radius = 0;
        var velocity = 0;
        var bControllable = false;
        var bRequireLock = false;
        var bAutoLock = _data.bAutoLock == true;
        var weaponId = _data.weaponId;
        var destroyTimer = this.game.settings.fps * 5;
        switch (weaponId)
        {
            case "hellfire":
                destroyTimer = this.game.settings.fps * 10;
                damage = 1000;
                radius = 500;
                velocity = 0;
                bControllable = true;
                break;
            case "rocket_flare":
                var weaponData = this.getWeaponData(weaponId);
                damage = 0;
                radius = 100;
                velocity = this.Random(50, 100);
                break;
            default:
                destroyTimer = this.game.settings.fps * 5;
                var weaponData = this.getWeaponData(weaponId);
                damage = _data.damage ? _data.damage : weaponData.damage;
                radius = _data.radius ? _data.radius : weaponData.radius;
                bRequireLock = _data.bRequireLock;
                bControllable = weaponData.bControllable;
                velocity = weaponData.velocity ? weaponData.velocity : 150;
                bAutoLock = bAutoLock || weaponData.bAutoLock;
                break;
        }
        body.data = {
            id: _data.id ? _data.id : this.getRandomUniqueId(),
            destroyTimer: destroyTimer,
            type: ObjectType.ROCKET,
            damage: damage,
            radius: radius,
            team: _data.team,
            rocketType: _data.rocketType,
            modId: _data.modId,
            playerId: _data.playerId,
            causerId: _data.causerId,
            weaponId: _data.weaponId,
            enemyId: _data.enemyId,
            bRequireLock: _data.bRequireLock,
            bAutoLock: bAutoLock,
            velocity: velocity,
            bControllable: bControllable,
            vehicleId: _data.vehicleId
        };
        var data = body.data;
        this.optimizeKeys(data);
        var shape = new this.p2.Circle({
            radius: 12,
            collisionGroup: CollisionGroups.PROJECTILE,
            collisionMask: CollisionGroups.GROUND | CollisionGroups.PAWN | CollisionGroups.OBJECT | CollisionGroups.HELICOPTER | CollisionGroups.BOUNDS
        });
        shape.sensor = true;
        body.addShape(shape);
        this.addWorldBody(body);
        if (velocity)
        {
            var rad = _data.angle;
            body.applyImpulse([Math.cos(rad) * velocity, Math.sin(rad) * velocity], 0, 0);
        }
        if (weaponData.id == "rocket_flare")
        {
            body.shapes[0].collisionMask = 0;
        }
        else if (bRequireLock || bAutoLock || (_data.lockOnTargetId && weaponData.bCanLock))
        {
            var lockOnTargetId = _data.lockOnTargetId;
            if (!lockOnTargetId)
            {
                var pawn = this.getObjectById(_data.playerId);
                if (pawn)
                {
                    lockOnTargetId = pawn.data.lockOnTargetId;
                }
            }
            if (lockOnTargetId)
            {
                var lockTarget = this.getObjectById(lockOnTargetId);                
                data.enemyId = lockOnTargetId;
                if (lockTarget)
                {
                    this.requestEvent({
                        eventId: GameServer.EVENT_PAWN_ACTION,
                        pawnId: _data.lockOnTargetId,
                        type: GameServer.PAWN_LOCK_ACQUIRED,
                        bRocket: true
                    });
                }                
            }
            if (lockTarget || bAutoLock)
            {
                body.shapes[0].collisionMask = CollisionGroups.PAWN | CollisionGroups.HELICOPTER;
            }
        }
        if (bControllable)
        {
            var ps = this.getPlayerById(_data.playerId);
            if (ps)
            {
                data.team = ps.team;
            }
        }
        if (data.enemyId || data.bAutoLock)
        {
            data.health = data.maxHealth = 100;
        }
        this.requestEvent({
            eventId: GameServer.EVENT_SPAWN_OBJECT,
            type: ObjectType.ROCKET,
            position: body.position,
            velocity: body.velocity,
            angularVelocity: body.angularVelocity,
            rotation: body.angle,
            data: data
        });
        return body;
    }

    createDroppedWeapon(_position, _data)
    {
        if (!_data.weaponData)
        {
            _data.weaponData = this.getWeaponData(_data.weaponId);
            if (_data.mods && _data.weaponData)
            {
                this.applyWeaponMods(_data.weaponData, _data.mods);
            }
        }        
        var weaponData = _data.weaponData;
        if (!weaponData)
        {
            console.warn("Invalid weaponData");
            return;
        }
        if (weaponData.id == "none" || weaponData.bZombie || weaponData.bDinosaur)
        {
            return;
        }
        if (_data.bRandomMods)
        {
            this.setRandomWeaponMods(weaponData);
        }
        if (weaponData.type != Weapon.TYPE_MELEE)
        {
            if (weaponData.mag == null)
            {
                weaponData.mag = weaponData.magSize = weaponData.ammoMax ? weaponData.ammoMax : 1;
            }            
            if (weaponData.ammo == null)
            {
                weaponData.ammo = weaponData.ammoMax = 1;
            }
        }
        if (_data.name)
        {
            weaponData.name = _data.name;
        }
        if (_data.magSize != null)
        {
            weaponData.magSize = Math.max(1, _data.magSize);
        }
        if (_data.mag != null)
        {
            weaponData.mag = Math.min(weaponData.magSize, Math.max(0, _data.mag));
        }
        if (_data.ammo != null)
        {
            weaponData.ammo = Math.max(0, _data.ammo);
        }
        if (_data.numMags != null)
        {
            weaponData.ammo = weaponData.magSize * weaponData.numMags;
        }
        var body = new this.p2.Body({
            mass: _data.mass != null ? _data.mass : 1,
            position: _position,
            angle: _data.angle ? _data.angle : (_data.rotation ? this.ToRad(_data.rotation) : 0),
            allowSleep: true,
            damping: 0.99,
            angularDamping: 0.98,
            sleepSpeedLimit: 10
        });
        body.data = {
            id: _data.id ? _data.id : this.getRandomUniqueId(),
            type: ObjectType.DROPPED_WEAPON,
            itemData: _data,
            bPersistent: _data.bPersistent
        };
        var atlasData = this.getWorldWeaponData(weaponData.id);
        var shape = new this.p2.Circle({
            width: atlasData.w,
            height: atlasData.h,
            radius: Math.min(atlasData.w, atlasData.h),
            collisionGroup: CollisionGroups.OBJECT,
            collisionMask: CollisionGroups.GROUND | CollisionGroups.HELICOPTER | CollisionGroups.OBJECT
        });
        body.addShape(shape);
        this.addWorldBody(body);
        if (weaponData.ammo == 0 && weaponData.mag == 0)
        {
            body.data.destroyTimer = this.game.settings.fps;
        }
        this.onEvent({
            eventId: GameServer.EVENT_SPAWN_OBJECT,
            type: ObjectType.DROPPED_WEAPON,
            position: body.position,
            rotation: body.angle,
            velocity: body.velocity,
            angularVelocity: body.angularVelocity,
            data: body.data
        });
        return body;
    }

    createEgg(_position, _data)
    {
        var eggType = _data.eggType ? _data.eggType : Egg.LARGE;
        var shared = this.getSharedData(eggType);
        var useMass = _data.mass != null ? _data.mass : shared.mass;
        var body = new this.p2.Body({
            mass: useMass,
            position: _position,
            angle: _data.angle ? _data.angle : this.RandomAngle(),
            damping: shared.damping,
            angularDamping: shared.angularDamping,
            allowSleep: true,
            sleepSpeedLimit: 10
        });
        switch (eggType)
        {
            case Egg.SMALL:
                var health = 1000;
                var hatchTimer = 5;
                break;
            case Egg.LARGE:
                health = 2000;
                hatchTimer = 8;
                break;
            case Egg.HUGE:
                health = 5000;
                hatchTimer = 12;
                break;
            case Egg.MASSIVE:
                health = 10000;
                hatchTimer = 15;
                break;
        }
        if (_data.hatchTimer != null)
        {
            hatchTimer = _data.hatchTimer;
        }
        if (this.game.bSurvival)
        {
            var wave = this.game.gameModeData.wave;
            if (wave >= 25)
            {
                hatchTimer *= 0.5;
            }
        }
        body.data = {
            id: _data.id ? _data.id : this.getRandomUniqueId(),
            type: ObjectType.EGG,
            material: Material.FLESH,
            health: _data.health ? _data.health : health,
            damageMultipliers: {
                1: 0.5,
                2: 1,
                3: 2.5,
                4: 0.5
            },
            playerId: _data.playerId,
            eggType: eggType,
            reward: Math.round(health * 0.25),
            items: _data.items ? _data.items : [],
            team: _data.team,
            playerId: _data.playerId,
            hatchTimer: this.game.settings.fps * hatchTimer,
            indicatorData: _data.indicatorData,
            bUntargetable: _data.bUntargetable,
            bRegenHealth: _data.bRegenHealth,
            bGodMode: _data.bGodMode,
            bDisabled: _data.bDisabled,
            tint: _data.tint,
            bShowHatchTimer: _data.bShowHatchTimer,
            bDropItemsWhenDestroyed: _data.bDropItemsWhenDestroyed != null ? _data.bDropItemsWhenDestroyed : false
        };
        var data = body.data;
        data.maxHealth = data.health;
        var shape = new this.p2.Circle({
            radius: shared.size,
            collisionGroup: CollisionGroups.OBJECT,
            collisionMask: CollisionGroups.OBJECT | CollisionGroups.PAWN | CollisionGroups.PROJECTILE | CollisionGroups.GROUND
        });
        body.addShape(shape);
        this.addWorldBody(body);
        this.onEvent({
            eventId: GameServer.EVENT_SPAWN_OBJECT,
            position: body.position,
            rotation: body.angle,
            data: body.data
        });
        return body;
    }

    createMoney(_position, _data)
    {
        var body = new this.p2.Body({
            mass: 1,
            position: _position,
            angle: _data.angle != null ? _data.angle : this.RandomAngle(),
            damping: 0.95,
            angularDamping: 0.9,
            allowSleep: true,
            sleepSpeedLimit: 10
        });
        body.data = {
            id: _data.id ? _data.id : this.getRandomUniqueId(),
            x: _position[0],
            y: _position[1],
            type: ObjectType.MONEY,
            value: Math.max(1, _data.value ? _data.value : 100),
            destroyTimer: _data.destroyTimer ? (_data.destroyTimer * this.game.settings.fps) : null
        };
        var shape = new this.p2.Circle({
            radius: 8,
            collisionGroup: CollisionGroups.OBJECT,
            collisionMask: CollisionGroups.OBJECT | CollisionGroups.GROUND | CollisionGroups.BOUNDS
        });
        body.addShape(shape);        
        this.addWorldBody(body);
        this.onEvent({
            eventId: GameServer.EVENT_SPAWN_OBJECT,
            position: body.position,
            rotation: body.angle,
            data: body.data
        });
        return body;
    }

    createArrow(_position, _data)
    {
        var body = new this.p2.Body({
            mass: 1,
            position: _position,
            angle: _data.angle ? _data.angle : (_data.rotation  ? this.ToRad(_data.rotation) : 0),
            damping: 0.9,
            angularDamping: 0.9,
            allowSleep: true,
            sleepSpeedLimit: 10
        });
        body.data = {
            id: _data.id ? _data.id : this.getRandomUniqueId(),
            x: _position[0],
            y: _position[1],
            type: ObjectType.ARROW,
            destroyTimer: _data.destroyTimer != null ? (_data.destroyTimer * this.game.settings.fps) : Math.round(this.game.settings.fps * 60)
        };
        var shape = new this.p2.Circle({
            radius: 5,
            collisionGroup: CollisionGroups.OBJECT,
            collisionMask: CollisionGroups.OBJECT | CollisionGroups.GROUND
        });
        body.addShape(shape);
        this.addWorldBody(body);
        this.onEvent({
            eventId: GameServer.EVENT_SPAWN_OBJECT,
            position: body.position,
            rotation: body.angle,
            data: body.data
        });
        return body;
    }

    createFlame(_position, _velocity, _team, _playerId, _weaponData, _time, _bFromWeapon, _scale)
    {
        if (!_weaponData)
        {
            console.warn("Invalid fire weapon data");
            return;
        }
        if (_time == null)
        {
            _time = 5;
        }
        var body = new this.p2.Body({
            mass: 1,
            position: _position,
            velocity: _velocity,
            angle: this.RandomAngle(),
            damping: 0.9,
            allowSleep: true,
            sleepSpeedLimit: 10
        });
        if (!_weaponData.fireDamage)
        {
            console.warn("Invalid fire damage", _weaponData.id);
        }
        body.data = {
            id: this.getRandomUniqueId(),
            x: _position[0],
            y: _position[1],
            type: ObjectType.FLAME,
            team: _team,
            damage: _weaponData.fireDamage ? _weaponData.fireDamage : 10,
            playerId: _playerId,
            weaponId: _weaponData.id,
            destroyTimer: Math.round(this.game.settings.fps * _time),
            ticker: 0,
            tickerMax: Math.round(2 * this.game.fpsMult),
            bFromWeapon: _bFromWeapon,
            objectScale: _scale != null ? _scale : 1
        };
        var data = body.data;
        if (_bFromWeapon)
        {
            data.cooldownTimer = Math.ceil(2 * this.game.fpsMult);
        }
        var collisionGroup = CollisionGroups.FLAME;
        var collisionMask = CollisionGroups.GROUND | CollisionGroups.BOUNDS | CollisionGroups.OBJECT | CollisionGroups.SHIELD
        var shape = new this.p2.Circle({
            radius: 20 * data.objectScale,
            collisionGroup: collisionGroup,
            collisionMask: collisionMask
        });
        body.addShape(shape);        

        this.addWorldBody(body);
        this.onEvent({
            eventId: GameServer.EVENT_SPAWN_OBJECT,
            angle: body.angle,
            data: data
        });

        /*
        var flames = this.getFlames();
        if (flames.length >= this.settings.maxFlames)
        {
            var dif = (flames.length - this.settings.maxFlames);
            for (var i = 0; i < dif; i++)
            {
                this.removeNextStep(flames[i]);
            }
        }    
        flames = this.getFlames(_playerId);
        if (flames.length >= this.settings.maxFlamesPerPlayer)
        {
            var dif = (flames.length - this.settings.maxFlamesPerPlayer);
            for (var i = 0; i < dif; i++)
            {
                this.removeNextStep(flames[i]);
            }
        }     
        */

        return body;
    }

    createProjectile(_position, _rotation, _team, _data)
    {
        var body = new this.p2.Body({
            mass: 0.1,
            position: _position,
            angle: _rotation,
            angularDamping: 0.2
        });
        var weaponData = this.getWeaponData(_data.weaponId);
        body.data = {
            id: _data.id ? _data.id : this.getRandomUniqueId(),
            type: ObjectType.PROJECTILE,
            team: _team,
            playerId: _data.playerId,
            causerId: _data.causerId,
            sourceId: _data.sourceId,
            damage: weaponData.damage,
            bMelee: weaponData.bArrow || _data.weaponId,  
            weaponId: weaponData.id,
            weaponData: weaponData
        };
        var data = body.data;
        var speed = _data.velocity ? _data.velocity : 200;
        switch (weaponData.id)
        {
            case Dinosaur.NEEDLER:
                var shape = new this.p2.Circle({
                    radius: 15
                });
                data.destroyTimer = this.game.settings.fps;
                speed = this.Random(190, 210);
                break;
            case "rope":
                shape = new this.p2.Circle({
                    radius: 15
                });
                data.bHitSameTeam = true;
                data.destroyTimer = this.game.settings.fps;
                break;
            default:
                shape = new this.p2.Circle({
                    radius: 15
                });
                break;
        }
        shape.sensor = true;
        shape.collisionGroup = CollisionGroups.PROJECTILE;
        shape.collisionMask = CollisionGroups.GROUND | CollisionGroups.PAWN | CollisionGroups.OBJECT | CollisionGroups.HELICOPTER | CollisionGroups.BOUNDS | CollisionGroups.SHIELD
        body.addShape(shape);
        this.addWorldBody(body);

        var rad = _rotation;        
        body.applyImpulse([Math.cos(rad) * speed, Math.sin(rad) * speed], 0, 0);

        this.requestEvent({
            eventId: GameServer.EVENT_SPAWN_OBJECT,
            type: ObjectType.PROJECTILE,
            position: body.position,
            rotation: body.angle,
            velocity: body.velocity,
            angularVelocity: body.angularVelocity,
            data: body.data
        });
        return body;
    }

    createEquipment(_position, _data)
    {
        var _weaponData = _data.weaponData;
        if (!_weaponData)
        {
            _weaponData = this.getWeaponData(_data.weaponId);
        }
        if (!_weaponData)
        {
            console.warn("Invalid weaponData");
            return;
        }
        var shared = this.getSharedData(_weaponData.id);
        if (!shared)
        {
            console.warn("Invalid shared equipment data", _weaponData.id);
            return;
        }
        var body = new this.p2.Body({
            mass: shared.mass ? shared.mass : 1,
            damping: shared.damping != null ? shared.damping : 0.99,
            angularDamping: shared.angularDamping != null ? shared.angularDamping : 0.9,
            position: _position,
            angle: _data.angle != null ? _data.angle : (_data.rotation ? this.ToRad(_data.rotation) : 0),
            allowSleep: true,
            sleepSpeedLimit: 10
        });
        if (_data.itemData)
        {
            if (_data.itemData.interactTime)
            {
                _data.itemData.interactTime = _data.itemData.interactTime * this.game.settings.fps;
            }
        }
        body.data = {
            id: _data.id ? _data.id : this.getRandomUniqueId(),
            x: _position[0],
            y: _position[1],
            type: ObjectType.EQUIPMENT,
            health: _data.health ? _data.health : (_weaponData.health ? _weaponData.health : 1),
            team: _data.team,
            scale: 1,
            ownerId: _data.ownerId,
            weaponData: _weaponData,
            bHideRadius: _data.bHideRadius,
            itemData: _data.itemData ? _data.itemData : null
        };
        var data = body.data;
        if (!data.itemData)
        {
            switch (_weaponData.id)
            {
                case "ammo_box":
                    data.itemData = {
                        uses: 10,
                        maxUses: 10,
                        interactTime: 0.5 * this.game.settings.fps
                    };
                    break;
            }
        }
        if (_weaponData.id == "trophy")
        {
            data.material = Material.METAL;
            data.blockNum = 5;
            data.bCanMelee = true;
        }
        else if (_weaponData.id == "beacon")
        {
            data.material = Material.METAL;
            body.fixedRotation = true;
        }
        if (this.game.bSurvival && data.team == 0 && data.health)
        {
            data.health *= 2;
        }
        if (_weaponData.radius)
        {
            data.radius = _weaponData.radius;
        }
        if (_weaponData.bMine)
        {
            data.bMine = true;
            switch (_weaponData.id)
            {
                case "claymore":
                    data.triggerRange = 200;
                    break;
                case "betty":
                    data.triggerRange = 150;
                    break;
                default:
                    data.triggerRange = 100;
                    break;
            }
        }
        var shape = new this.p2.Circle({
            radius: shared.size ? shared.size : Math.max(shared.width, shared.height),
            collisionGroup: CollisionGroups.PAWN,
            collisionMask: CollisionGroups.GROUND | CollisionGroups.OBJECT | CollisionGroups.BOUNDS
        });

        shape.sensor = !_weaponData.bThrowable && _weaponData.bMine;
        body.addShape(shape);

        var numMax = 4;
        switch (_weaponData.id)
        {
            case "health_box":
                numMax = 1;
                break;
            case "jammer":
            case "sensor":
            case "trophy":
                numMax = 2;
                break;
        }
        var arr = this.getEquipmentByPlayerId(data.ownerId, _weaponData.id);
        if (arr.length >= numMax)
        {
            this.removeNextStep(arr[0]);
        }

        this.addWorldBody(body);
        this.onEvent({
            eventId: GameServer.EVENT_SPAWN_OBJECT,
            type: ObjectType.EQUIPMENT,
            position: body.position,
            rotation: body.angle,
            data: data
        });
        return body;
    }

    getEquipmentByPlayerId(_id, _weaponId)
    {
        var arr = [];
        if (_id)
        {
            var equipment = this.getEquipment();
            for (var i = 0; i < equipment.length; i++)
            {
                var item = equipment[i];
                if (item.data.ownerId == _id)
                {
                    if (!_weaponId || item.data.weaponData.id == _weaponId)
                    {
                        arr.push(item);
                    }
                }
            }
        }
        return arr;
    }

    onStoppingPowerHit(_body, _damage)
    {
        var data = _body.data;
        if (data.type == ObjectType.CHARACTER || data.type == ObjectType.DINOSAUR)
        {
            var val = Math.max(0, _damage / 25) * 0.1;
            var fps = this.game.settings.fps;
            var time = Math.min(fps, fps * (0.25 + val));
            data.stoppingPowerTimer = Math.round(time / _body.mass);
            this.setDataValue(_body, "bStoppingPower", true);
        }
    }

    canAcceptNewPlayers()
    {
        if (this.matchHasEnded() || this.bGameEnded || this.game.gameSettings.bAllowJoinInProgress === false)
        {
            return false;
        }
        return true;
    }

    getNewPlayerDesiredTeam()
    {
        if (!this.game)
        {
            return 0;
        }
        switch (this.game.gameModeId)
        {
            case GameMode.TYRANT:
                return 0;
            default:
                if (this.game.bSurvival)
                {
                    return 0;
                }
                break;
        }
        var scoreLimit = this.game.gameModeData.scoreLimit;
        if (scoreLimit)
        {
            var scores = this.game.gameModeData.scores;
            if (scores)
            {
                if (scores[0] > scores[1])
                {
                    return 1;
                }
                else if (scores[0] < scores[1])
                {
                    return 0;
                }
            }
        }
        if (this.isTeamGameMode())
        {
            var team0 = this.getNumPlayersOnTeam(0);
            var team1 = this.getNumPlayersOnTeam(1);
            if (team0 > team1)
            {
                return 1;
            }
            else if (team0 < team1)
            {
                return 0;
            }
        }
        return this.Random(0, 1);
    }

    getNumPlayersOnTeam(_team)
    {
        var num = 0;
        var players = this.game.players;
        if (players)
        {
            for (var i = 0; i < players.length; i++)
            {
                if (players[i].team == _team)
                {
                    num++;
                }
            }
        }
        return num;
    }

    serverAction(_playerId, _args)
    {
        if (this.matchHasEnded())
        {
            return;
        }
        var ps = this.getPlayerById(_playerId);
        var pawn = this.getObjectById(_playerId);
        switch (_args[0])
        {
            case "/error":
                this.onGameError(new Error("test"));
                break;
            case "/clearTriggerAreas":
                var areas = this.getTriggerAreas();
                this.triggerCallback("chat", {
                    messageText: "Removing " + areas.length + " trigger areas"
                });
                for (var i = 0; i < areas.length; i++)
                {
                    this.removeNextStep(areas[i]);
                }
                break;
            case "/clearObstacles":
                var obstacles = this.getObstacles();
                this.triggerCallback("chat", {
                    messageText: "Removing " + obstacles.length + " obstacles"
                });
                for (var i = 0; i < obstacles.length; i++)
                {
                    this.removeNextStep(obstacles[i]);
                }
                break;
            case "/clearDecorations":
                var obstacles = this.getObstacles();     
                var numDecorations = 0;
                for (var i = 0; i < obstacles.length; i++)
                {
                    let obs = obstacles[i];
                    if (!obs.data.bGodMode && (obs.data.health || obs.data.bNoBody))
                    {
                        this.removeNextStep(obs);
                        numDecorations++;
                    }
                }
                this.triggerCallback("chat", {
                    messageText: "Removed " + numDecorations + " decorations"
                });
                break;
            case "/clearTrees":
                var trees = this.getTrees();
                this.triggerCallback("chat", {
                    messageText: "Removing " + trees.length + " trees"
                });
                for (var i = 0; i < trees.length; i++)
                {
                    this.removeNextStep(trees[i]);
                }
                break;
            case "/clearEquipment":
                var equipment = this.getEquipment();
                this.triggerCallback("chat", {
                    messageText: "Removing " + equipment.length + " equipment"
                });
                for (var i = 0; i < equipment.length; i++)
                {
                    this.removeNextStep(equipment[i]);
                }
                break;
            case "/clear":
                let numItems = 0;
                var obstacles = this.getObstacles();
                numItems += obstacles.length;
                for (var i = 0; i < obstacles.length; i++)
                {
                    this.removeNextStep(obstacles[i]);
                }
                var trees = this.getTrees();
                numItems += trees.length;
                for (var i = 0; i < trees.length; i++)
                {
                    this.removeNextStep(trees[i]);
                }
                var dropped = this.getDroppedWeapons();
                numItems += dropped.length;
                for (var i = 0; i < dropped.length; i++)
                {
                    this.removeNextStep(dropped[i]);
                }
                this.triggerCallback("chat", {
                    messageText: "Removing " + numItems + " objects"
                });
                break;
            case "/spectate":
                if (ps)
                {
                    if (this.game.gameSettings.bAllowSpectators || ps.bAdmin)
                    {
                        if (ps.bSpectator)
                        {
                            ps.bSpectator = false;
                            ps.bWaitingToRespawn = true;
                        }
                        else
                        {
                            ps.bSpectator = true;
                            this.removeObjectById(ps.id);
                            this.removeNextStep(this.getReviverByPlayerId(ps.id));
                        }
                        this.onEvent({
                            eventId: GameServer.EVENT_PLAYER_UPDATE,
                            playerId: ps.id,
                            data: {
                                team: ps.team,
                                kills: ps.kills,
                                bWaitingToRespawn: ps.bWaitingToRespawn,
                                bSpectator: ps.bSpectator
                            }
                        });
                        this.triggerCallback("chat", {
                            messageText: ps.name + (ps.bSpectator ? (" is now a spectator") : (" is no longer a spectator"))
                        });
                        if (this.game.bSurvival)
                        {
                            if (this.getNumPawnsOnTeam(0, true) <= 0)
                            {
                                this.requestEvent({
                                    eventId: GameServer.EVENT_GAME_END,
                                    condition: MatchState.END_CONDITION_KIA,
                                    result: MatchState.END_RESULT_LOSS,
                                    winningTeam: 1
                                });
                            }
                        }
                    }
                    else
                    {
                        console.log("Spectating is disabled");
                        this.triggerCallback("chat", {
                            messageText: "Spectating is disabled"
                        });
                    }
                }
                break;
            case "/team":
                if (ps)
                {
                    ps.team = ps.team == 0 ? 1 : 0;
                    if (pawn)
                    {
                        this.setDataValue(pawn, "team", ps.team);
                    }
                    this.onEvent({
                        eventId: GameServer.EVENT_PLAYER_UPDATE,
                        playerId: ps.id,
                        data: {
                            team: ps.team,
                        }
                    });
                }
                break;
            case "/money":
                if (ps)
                {
                    for (var i = 0; i < this.game.players.length; i++)
                    {
                        var player = this.game.players[i];
                        this.addPlayerMoney(player.id, _args[1] ? parseInt(_args[1]) : this.settings.maxPlayerMoney);
                    }
                }
                break;
            case "/world":
                var worldStr = "";
                this.triggerCallback("chat", {
                    messageText: worldStr
                });
                break;
            case "/pos":
                if (_args[1])
                {
                    var posObject = this.getObjectById(_args[1]);
                }
                else
                {
                    posObject = this.getObjectById(ps ? ps.id : null);
                }
                if (posObject)
                {
                    this.triggerCallback("chat", {
                        messageText: posObject.data.id + " position: [" + Math.round(posObject.position[0]) + ", " + Math.round(posObject.position[1]) + "]"
                    });
                }
                break;
            case "/kill":
                this.killPawn(_args[1] ? _args[1] : _playerId);
                break;
            case "/killBots":
                var pawns = this.getPawns();
                for (var i = 0; i < pawns.length; i++)
                {                    
                    let pawn = pawns[i];
                    if (pawn.data.bBot)
                    {
                        this.killPawn(pawn.data.id);
                    }
                }
                break;
            case "/disableBots":
                var pawns = this.getPawns();
                for (var i = 0; i < pawns.length; i++)
                {
                    let pawn = pawns[i];
                    if (pawn.data.bBot)
                    {
                        pawn.data.bBot = false;
                    }
                }
                break;
            case "/setTickRate":
                if (_args[1])
                {
                    var tickRate = parseInt(_args[1]);
                    this.game.gameSettings.tickRate = tickRate;
                    this.setTickRate(tickRate);
                }
                else
                {
                    this.triggerCallback("chat", {
                        messageText: "Tick rate: " + this.game.gameSettings.tickRate
                    });
                }
                break;
            case "/setMaxSubSteps":
                if (_args[1])
                {
                    this.game.gameSettings.maxSubSteps = parseInt(_args[1]);
                    this.triggerCallback("chat", {
                        messageText: "Max sub steps: " + this.game.gameSettings.maxSubSteps
                    });
                }
                break;
            case "/numBodies":
                let bodyTypes = {};
                for (var i = 0; i < this.game.world.bodies.length; i++)
                {
                    let curBody = this.game.world.bodies[i];
                    let data = curBody.data;
                    if (curBody.world && data)
                    {
                        if (bodyTypes[data.type] == null)
                        {
                            bodyTypes[data.type] = 0;
                        }
                        bodyTypes[data.type]++;
                    }
                }
                let bodyStr = this.game.world.bodies.length + " bodies";
                keys = Object.keys(bodyTypes);
                for (i = 0; i < keys.length; i++)
                {
                    let key = keys[i];
                    bodyStr += "\n" + key + ": " + bodyTypes[key];
                }
                this.onEvent({
                    eventId: GameServer.EVENT_MESSAGE_ADD,
                    data: {
                        message: bodyStr,
                        bLocalize: false,
                        bInfofeed: true
                    }
                });
                break;
            case "/numObstacles":
                this.onEvent({
                    eventId: GameServer.EVENT_MESSAGE_ADD,
                    data: {
                        message: this.getObstacles().length + " obstacles",
                        bLocalize: false,
                        bInfofeed: true
                    }
                });
                break;
            case "/obstacles":
                var obstacles = this.getObstacles();
                let obstacleTypes = {};
                for (var i = 0; i < obstacles.length; i++)
                {
                    let obstacle = obstacles[i];
                    if (!obstacle.data.bNoBody)
                    {
                        if (!obstacleTypes[obstacle.data.obstacleId])
                        {
                            obstacleTypes[obstacle.data.obstacleId] = 0;
                        }
                        obstacleTypes[obstacle.data.obstacleId]++;
                    }
                }
                let obstacleStr = obstacles.length + " obstacles";
                keys = Object.keys(obstacleTypes);
                for (i = 0; i < keys.length; i++)
                {
                    let key = keys[i];
                    obstacleStr += "\n" + key + ": " + obstacleTypes[key];
                }
                this.onEvent({
                    eventId: GameServer.EVENT_MESSAGE_ADD,
                    data: {
                        message: obstacleStr,
                        bLocalize: false,
                        bInfofeed: true
                    }
                });
                break;
            case "/numPawns":
                this.onEvent({
                    eventId: GameServer.EVENT_MESSAGE_ADD,
                    data: {
                        message: this.getPawns().length + " pawns",
                        bLocalize: false,
                        bInfofeed: true
                    }
                });
                break;
            case "/nodes":
                this.generateMapNodes();
                break;
            case "/showNodes":
                this.onEvent({
                    eventId: GameServer.EVENT_GAME_UPDATE,
                    data: {
                        nodes: this.game.nodes,
                        threshold: this.game.nodeThreshold
                    }
                });
                break;
            case "/hideNodes":
                this.onEvent({
                    eventId: GameServer.EVENT_GAME_UPDATE,
                    data: {
                        nodes: null
                    }
                });
                break;
            case "/vars":
                var vars = this.game.gameModeData.vars;
                if (vars)
                {
                    var str = "";
                    var keys = Object.keys(vars);
                    for (var i = 0; i < keys.length; i++)
                    {
                        var key = keys[i];
                        str += key + " = " + vars[key] + (i < keys.length - 1 ? "\n" : "");                        
                    }
                    this.triggerCallback("chat", {
                        messageText: str,
                        playerText: "Variables",
                        date: Date.now()
                    });
                }
                break;
            case "/var":
                this.triggerCallback("chat", {
                    messageText: _args[1] + " = " + this.getScenarioVarValue(_args[1]),
                    playerText: "Variable",
                    date: Date.now()
                });
                break;
            case "/game":
                var str = "";
                var keys = Object.keys(this.game.gameModeData);
                for (var i = 0; i < keys.length; i++)
                {
                    var key = keys[i];
                    str += key + " = " + this.game.gameModeData[key] + (i < keys.length - 1 ? "\n" : "");
                }
                this.triggerCallback("chat", {
                    messageText: str,
                    playerText: "Game Data",
                    date: Date.now()
                });
                break;
            case "/wave":
                if (_args[1])
                {
                    this.game.gameModeData.wave = parseInt(_args[1]);
                    this.onEvent({
                        eventId: GameServer.EVENT_GAME_UPDATE,
                        data: {
                            wave: this.game.gameModeData.wave
                        }
                    });
                }
                else
                {
                    this.onSurvivalWaveComplete();
                }
                break;
            case "/function":
                this.executeScenarioFunction(_args[1]);
                break;
            case "/trigger":
                this.executeTriggerById(_args[1]);
                break;
            case "/round":
                this.winRound(MatchState.END_CONDITION_DINOS_RESCUED, 0, 1, null);
                break;
            case "/spawn":
            case "/s":
                try
                {
                    this.spawn(_playerId, _args);
                }
                catch (e)
                {
                    this.onGameError(e);
                }
                break;
            case "/wanderBots":
                var pawns = this.getCharactersAndDinosaurs();
                for (var i = 0; i < pawns.length; i++)
                {
                    let pawn = pawns[i];
                    if (pawn.data.bBot && pawn.ai)
                    {
                        this.setAIWanderArea(pawn, this.Random(500, 1000));
                    }
                }
                break;
            case "/item":
                var ps = this.getPlayerById(_playerId);
                if (ps)
                {
                    var item = this.getItemData(_args[1]);
                    if (item)
                    {
                        ps.items.push({
                            id: _args[1]
                        });
                        ps.itemIndex = ps.items.length - 1;
                        this.onEvent({
                            eventId: GameServer.EVENT_PLAYER_UPDATE,
                            playerId: pawn.data.id,
                            data: {
                                items: ps.items,
                                itemIndex: ps.itemIndex
                            }
                        });
                    }
                }
                break;
            case "/god":
                if (pawn)
                {
                    pawn.data.bGodMode = !pawn.data.bGodMode;
                    this.triggerCallback("chat", {
                        messageText: "God mode " + (pawn.data.bGodMode ? "enabled" : "disabled")
                    });
                }
                break;
            case "/unlimitedAmmo":
                if (pawn)
                {
                    pawn.data.weapon.bUnlimitedAmmo = !pawn.data.weapon.bUnlimitedAmmo;
                    this.triggerCallback("chat", {
                        messageText: "Unlimited ammo " + (pawn.data.weapon.bUnlimitedAmmo ? "enabled" : "disabled")
                    });
                }
                break;
            case "/revive":
            case "/r":
                this.respawnAllPlayers();
                break;
            case "/survival_char":
                this.spawnSurvivalEnemyCharacter();
                break;
            case "/survival_turret":
                this.spawnSurvivalEnemyTurret();
                break;
            case "/survival_bigfoot":
                this.spawnSurvivalEnemyBigfoot();
                break;
            case "/survival_zombie":
                this.spawnSurvivalEnemyZombie();
                break;
            case "/survival_vehicle":
                this.spawnSurvivalEnemyVehicle();
                break;
            case "/survival_car":
                this.spawnSurvivalEnemyVehicle([Car.GROWLER, Car.PICKUP]);
                break;
            case "/survival_airdrop":
                this.spawnSurvivalEnemyAirdrop();
                break;
            case "/survival_bgm71":
                this.spawnSurvivalEnemyVehicle([MountedWeapon.BGM71]);
                break;
            case "/survival_egg":
                this.spawnSurvivalEnemyEgg();
                break;
        }
    }

    respawnAllPlayers(_data)
    {
        if (this.bGameEnded || this.roundHasEnded())
        {
            return;
        }
        for (var i = 0; i < this.game.players.length; i++)
        {
            var player = this.game.players[i];
            if (!this.getObjectById(player.id) || !player.bHasPawn)
            {
                let reviver = this.getReviverByPlayerId(player.id);
                let data = _data ? _data : {};
                if (reviver)
                {
                    data.position = this.clone(reviver.position);
                }
                this.respawnPlayer(player.id, data);
                if (this.game.bSurvival)
                {
                    this.onEvent({
                        eventId: GameServer.EVENT_PAWN_ACTION,
                        pawnId: player.id,
                        type: GameServer.PAWN_END_REVIVE,
                        reviveId: player.id
                    });
                }
                if (reviver)
                {
                    this.removeNextStep(reviver);
                }
            }
        }
    }

    spawn(_playerId, _args)
    {
        var curPawn = this.getObjectById(_playerId);
        if (curPawn)
        {
            var pos = this.clone(curPawn.position);
            pos[0] += this.Random(-50, 50);
            pos[1] += this.Random(-50, 50);
            var id = _args[1];
            switch (id)
            {
                case "sprite":
                    this.createPolygon({
                        position: pos,
                        rotation: 0,
                        spriteId: _args[2]
                    });
                    break;
                case "window":
                    this.createWindow({
                        width: 3,
                        height: 50,
                        position: pos
                    });
                    break;
                case "character":
                    this.createCharacter({
                        position: pos,
                        team: 0,
                        inventory: [
                            {
                                id: "m16a4"
                            }
                        ],
                        avatar: this.getAvatarDataById(AvatarPresets.DINOGEN),
                        bBot: true,
                        botSkill: 2,
                    });
                    break;
                case "juggernaut":
                    this.createCharacter({
                        position: pos,
                        team: 1,
                        inventory: [
                            {
                                id: "m240"
                            }
                        ],
                        avatar: this.getAvatarDataById(AvatarPresets.JUGGERNAUT),
                        bBot: true,
                        botSkill: 1,
                        health: 1000,
                        bJuggernaut: true
                    });
                    break;
                case "zombie":
                    this.createCharacter({
                        position: pos,
                        team: 1,
                        inventory: [],
                        avatar: this.getAvatarDataById(AvatarPresets.ZOMBIE),
                        bBot: true,
                        bZombie: true,
                        botSkill: 1,
                        health: 500
                    });
                    break;
                case "bigfoot":
                    this.createCharacter({
                        position: pos,
                        team: 1,
                        inventory: [],
                        avatar: this.getAvatarDataById(AvatarPresets.BIGFOOT),
                        bBot: true,
                        bZombie: true,
                        botSkill: 1,
                        health: 500
                    });
                    break;
                case ObjectType.EGG:
                    var eggs = [Egg.SMALL, Egg.LARGE, Egg.HUGE];
                    this.createEgg(pos, {
                        eggType: eggs[this.Random(0, eggs.length - 1)],
                        team: _args[2] != null ? parseInt(_args[2]) : 1,
                        items: [
                            {
                                type: ObjectType.DINOSAUR,
                                dinoType: this.getRandomDinosaur(),
                                bSavage: true,
                                bBot: true
                            },
                            {
                                type: ObjectType.DINOSAUR,
                                dinoType: this.getRandomDinosaur(),
                                bSavage: true,
                                bBot: true
                            },
                            {
                                type: ObjectType.DINOSAUR,
                                dinoType: this.getRandomDinosaur(),
                                bSavage: true,
                                bBot: true
                            }
                        ]
                    });
                    break;
                case "money":
                    this.createMoney(pos, {
                        value: this.Random(100, 1000)
                    });
                    break;
                case ObjectType.DUMMY:
                    this.createDummy({
                        position: pos,
                        team: -1
                    });
                    break;
                case "item":
                    var item = this.getWeaponData(_args[2]);
                    if (item)
                    {
                        this.setRandomWeaponMods(item);
                        this.createDroppedWeapon(pos, {
                            weaponData: item
                        });
                    }
                    break;
                case "store":
                    var storeCrate = this.createCrate(pos, {
                        team: 0,
                        crateType: Crate.STORE,
                        mass: 0,
                        bDisposable: false,
                        bDisableStoreInventory: false,
                        bDisableStoreSupportItems: false
                    });
                    storeCrate.mass = 0;
                    break;
                case "emitter":
                    this.createEmitter({
                        position: pos,
                        angle: 0
                    });
                    break;
                case "bomb":
                    var bombCrate = this.createCrate(pos, {
                        team: 0,
                        crateType: Crate.BOMB,
                        mass: 0,
                        bDisposable: false,
                        itemData: {
                            interactTime: this.game.settings.fps * 3
                        }
                    });
                    bombCrate.data.bombNum = 0;
                    break;
                case "crate_static":
                    var crate = this.createCrate(curPawn.position, {
                        team: 0,
                        crateType: Crate.AMMO,
                        mass: 0
                    });
                    crate.mass = 0;
                    break;
                case ObjectType.CRATE:
                    this.createCrate(pos, {
                        team: curPawn.data.team,
                        crateType: Crate.AMMO
                    });
                    break;
                case "crate_item":
                    this.createCrate(pos, {
                        team: curPawn.data.team,
                        crateType: Crate.ITEM,
                        itemId: this.getRandomItemId()
                    });
                    break;
                case "crate_weapon":
                    this.createCrate(pos, {
                        team: curPawn.data.team,
                        crateType: Crate.WEAPON,
                        items: [
                            {
                                type: ObjectType.DROPPED_WEAPON,
                                weaponData: this.getRandomWeapon(),
                                bRandomVelocity: true
                            },
                            {
                                type: ObjectType.DROPPED_WEAPON,
                                weaponData: this.getRandomWeapon(),
                                bRandomVelocity: true
                            },
                            {
                                type: ObjectType.DROPPED_WEAPON,
                                weaponData: this.getRandomWeapon(),
                                bRandomVelocity: true
                            }
                        ]
                    });
                    break;
                case "turret":
                    this.createMountedWeapon(pos, {
                        team: curPawn.data.team,
                        playerId: curPawn.data.id,
                        vehicleId: MountedWeapon.M2,
                        weapons: [
                            [
                                {
                                    id: _args[2]
                                }
                            ]
                        ]
                    });
                    break;
                case MountedWeapon.M2:
                case MountedWeapon.BGM71:
                case MountedWeapon.M242:
                    var mounted = this.createMountedWeapon(pos, {
                        team: curPawn.data.team,
                        playerId: curPawn.data.id,
                        vehicleId: id
                    });
                    break;
                case MountedWeapon.SENTRY:
                case MountedWeapon.SENTRY_SHOTGUN:
                case MountedWeapon.SENTRY_SNIPER:
                case MountedWeapon.SENTRY_GRENADE:
                case MountedWeapon.SENTRY_SAM:
                case MountedWeapon.SENTRY_FLAME:
                case MountedWeapon.SENTRY_RAILGUN:
                    this.createMountedWeapon(pos, {
                        team: _args[2] ? parseInt(_args[2]) : curPawn.data.team,
                        playerId: curPawn.data.id,
                        vehicleId: id,
                        bAutomated: true
                    });
                    break;
                case "minefield":
                    var threshold = _args[2] ? parseInt(_args[2]) : 200;
                    var map = this.getCurrentMapData();
                    var numX = Math.round(this.getMapWidth() / threshold);
                    var numY = Math.round(this.getMapHeight() / threshold);
                    for (var i = 0; i < numX; i++)
                    {
                        for (var j = 0; j < numY; j++)
                        {
                            this.createObstacle({
                                type: ObjectType.OBSTACLE,
                                obstacleId: "barrel_explosive",
                                position: [(i * threshold) + (threshold * 0.5), (j * threshold) + (threshold * 0.5)],
                                rotation: this.RandomAngle(),
                                mass: 0
                            });
                        }
                    }
                    this.triggerCallback("chat", {
                        messageText: "Created minefield with " + (numX * numY) + " explosives"
                    });
                    break;
                case "forest":
                    this.createForest(_args[2] ? parseInt(_args[2]) : 400);
                    break;
                case "boxes":
                    this.createBoxes(_args[2] ? parseInt(_args[2]) : 400);
                    break;
                case "rock":
                    this.createObstacle({
                        type: ObjectType.OBSTACLE,
                        position: curPawn.position,
                        health: 100,
                        obstacleId: "rock_1",
                        angle: this.RandomAngle()
                    });
                    break;
                case ObjectType.OBSTACLE:
                    this.createObstacle({
                        type: ObjectType.OBSTACLE,
                        position: curPawn.position,
                        obstacleId: _args[2],
                        angle: curPawn.data.aimRotation
                    });
                    break;
                case ObjectType.TREE:
                    this.createTree({
                        type: ObjectType.TREE,
                        treeType: _args[2] ? _args[2] : "tree",
                        position: curPawn.position
                    });
                    break;
                case "barrel":
                    this.createObstacle({
                        type: ObjectType.OBSTACLE,
                        position: pos,
                        obstacleId: "barrel_generic"
                    });
                    break;
                case "barrel_explosive":
                    this.createObstacle({
                        type: ObjectType.OBSTACLE,
                        position: pos,
                        obstacleId: "barrel_explosive"
                    });
                    break;
                case "weapon":
                    var wpns = this.getAllWeapons();
                    var wpn = this.getWeaponData(wpns[this.Random(0, wpns.length - 1)].id);
                    this.setRandomWeaponMods(wpn);
                    this.createDroppedWeapon(pos, {
                        weaponData: wpn
                    });
                    break;
                case Weapon.TYPE_PISTOL:
                case Weapon.TYPE_MACHINE_PISTOL:
                case Weapon.TYPE_SHOTGUN:
                case Weapon.TYPE_SMG:
                case Weapon.TYPE_RIFLE:
                case Weapon.TYPE_CARBINE:
                case Weapon.TYPE_SNIPER:
                case Weapon.TYPE_DMR:
                case Weapon.TYPE_LMG:
                case Weapon.TYPE_LAUNCHER:
                    var wpns = this.getAllWeaponsByType(id);
                    var wpn = this.getWeaponData(wpns[this.Random(0, wpns.length - 1)].id);
                    this.setRandomWeaponMods(wpn);
                    this.createDroppedWeapon(pos, {
                        weaponData: wpn
                    });
                    break;
                case "ammo":
                    var ammoBox = this.createEquipment(pos, {
                        team: curPawn.data.team,
                        angle: curPawn.data.aimRotation,
                        weaponId: "ammo_box",
                        itemData: {
                            uses: 10,
                            maxUses: 10,
                            interactTime: 0.5
                        }
                    });
                    ammoBox.data.destroyTimer = this.game.settings.fps * 60;
                    break;
                case "airdrop":
                    var heli = this.createHelicopter([0, 0], {
                        vehicleId: Helicopter.OSPREY,
                        team: curPawn.data.team,
                        destination: pos,
                        items: [
                            {
                                type: ObjectType.EGG,
                                eggType: Egg.LARGE,
                                team: 0,
                                items: [
                                    {
                                        type: ObjectType.DINOSAUR,
                                        dinoType: this.getRandomDinosaur()
                                    }
                                ]
                            }
                        ],
                        bAutomated: true
                    });
                    break;
                case "helicopter":
                    this.createHelicopter(pos, {
                        vehicleId: _args[2],
                        team: 1,
                        bAutomated: true
                    });
                    break;
                case "savage":
                    var dinoType = _args[2] ? _args[2] : this.getRandomDinosaur();
                    var dino = this.createDinosaur({
                        id: this.getRandomUniqueId(),
                        x: pos[0],
                        y: pos[1],
                        team: 1,
                        dinoType: dinoType,
                        bBot: true,
                        botSkill: this.Random(0, 5),
                        bSavage: true
                    });
                    break;
                case ObjectType.DINOSAUR:
                    var dinoType = _args[2] ? _args[2] : this.getRandomDinosaur();
                    var dino = this.createDinosaur({
                        id: this.getRandomUniqueId(),
                        x: pos[0],
                        y: pos[1],
                        team: 1,
                        dinoType: dinoType,
                        bBot: true,
                        botSkill: this.Random(0, 5)
                    });
                    break;
                case Car.PICKUP:
                case Car.QUAD:
                case Car.GROWLER:
                case Car.MRAP:
                case Car.LAV25:
                    this.createCar(pos, {
                        vehicleId: id,
                        team: -1 //curPawn.data.team
                    });
                    break;
                case Tank.ABRAMS:
                case Tank.T90:
                    this.createTank(pos, {
                        vehicleId: id,
                        team: -1
                    });
                    break;
                case Helicopter.MH6:
                case Helicopter.SEAKNIGHT:
                case Helicopter.BLACKHAWK:
                case Helicopter.KIOWA:
                case Helicopter.COBRA:
                case Helicopter.APACHE:
                case Helicopter.OSPREY:
                case Helicopter.CHICKENCOPTER:
                    this.createHelicopter(pos, {
                        vehicleId: id,
                        team: -1,
                        bAutomated: _args[2] == true
                    });
                    /*
                    var apacheRocket = this.getWeaponData("rpg");
                    apacheRocket.damage = 10000;
                    apacheRocket.fireRate = 30;
                    var apacheRailgun = this.getWeaponData("railgun");
                    apacheRailgun.fireRate = 10;
                    var apacheFlame = this.getWeaponData("flamethrower");
                    apacheFlame.damage = 250;
                    var apacheShotgun = this.getWeaponData("aa12");
                    apacheShotgun.damage = 1000;
                    apache.data.weapons = [
                        [
                            {
                                muzzlePos: [0, 0],
                                weaponData: apacheRocket
                            },
                            {
                                muzzlePos: [0, 0],
                                weaponData: apacheRailgun
                            },
                            {
                                muzzlePos: [0, 0],
                                weaponData: apacheFlame
                            },
                            {
                                muzzlePos: [0, 0],
                                weaponData: apacheShotgun
                            }
                        ]
                    ];
                    this.initVehicleWeapons(apache, apache.data.weapons);
                    */
                    break;
                case "owEgg":
                    this.spawnDinoPackEgg();
                    break;
                case "owAirdrop":
                    this.spawnOpenWorldAirdrop();
                    break;
                case "owMilitiaAirdrop":
                    this.spawnOpenWorldMilitiaAirdrop();
                    break;                
                default:
                    console.warn("Unhandled spawn", _args[1]);
                    break;
            }
        }
    }

    ejectPawn(_id)
    {
        var curPawn = this.getObjectById(_id);
        if (curPawn)
        {
            var veh = this.getObjectById(curPawn.data.controllableId);
            if (veh)
            {
                veh.position[1] -= 500;
            }
        }
    }

    killPawn(_id)
    {
        var curPawn = this.getObjectById(_id);
        if (curPawn)
        {
            var damage = curPawn.data.health;
            if (curPawn.data.damageMultipliers)
            {
                curPawn.data.damageMultipliers[DamageType.DAMAGE_WORLD] = 1;
            }
            if (curPawn.data.bGodMode)
            {
                curPawn.data.bGodMode = false;
            }
            this.requestEvent({
                eventId: GameServer.EVENT_PAWN_DAMAGE,
                damageType: DamageType.DAMAGE_WORLD,
                damageAmount: Math.max(damage, 500),
                pawnId: _id,
                attackerId: _id,
                weaponId: "generic"
            });
        }
    }

    removeEquipmentByPlayerId(_id, _weaponId)
    {
        if (_id)
        {
            var equipment = this.getEquipment();
            for (var i = 0; i < equipment.length; i++)
            {
                var item = equipment[i];
                if (item.data.ownerId == _id)
                {
                    if (_weaponId != null)
                    {
                        if (item.data.weaponData.id == _weaponId)
                        {
                            this.removeNextStep(item);
                        }
                    }
                    else
                    {
                        this.removeNextStep(item);
                    }
                }
            }
        }
    }

    removeGrenadesByPlayerId(_id, _weaponId)
    {
        if (_id)
        {
            var grenades = this.getGrenades();
            for (var i = 0; i < grenades.length; i++)
            {
                var item = grenades[i];
                if (item.data.playerId == _id)
                {
                    if (_weaponId != null)
                    {
                        if (item.data.weaponData.id == _weaponId)
                        {
                            this.removeNextStep(item);
                        }
                    }
                    else
                    {
                        this.removeNextStep(item);
                    }
                }
            }
        }
    }

    createSpawner(_position, _data)
    {
        var spawners = this.getSpawners();
        if (spawners.length >= this.settings.maxSpawners)
        {
            this.scenarioLog("Exceeded spawner limit", Colours.RED_STRING);
            return;
        }
        var body = new this.p2.Body({
            mass: 0,
            fixedRotation: true,
            position: _position
        });
        body.data = {
            id: _data.id ? _data.id : this.getRandomUniqueId(),
            type: ObjectType.SPAWNER,
            objectData: _data.data,
            timer: 0,
            ids: [],
            numObjects: _data.numObjects ? _data.numObjects : 1,
            totalObjects: _data.totalObjects,
            randomX: _data.randomX,
            randomY: _data.randomY,
            timerMax: _data.timerMax != null ? _data.timerMax : (this.game.settings.fps * 10),
            bDisabled: _data.bDisabled,
            bSkipServerUpdate: true
        };
        this.addWorldBody(body, false);
        this.requestEvent({
            eventId: GameServer.EVENT_SPAWN_OBJECT,
            type: ObjectType.SPAWNER,
            position: _data.position,
            data: body.data
        });
    }

    handleSpawner(_body)
    {
        if (this.matchHasEnded())
        {
            return;
        }
        var data = _body.data;
        if (data.bDisabled)
        {
            return;
        }
        var numSpawned = 0;
        var numObjects = data.numObjects;
        for (var i = 0; i < numObjects; i++)
        {
            var pawnId = data.ids[i];
            var pawn = this.getObjectById(pawnId);
            var pos = [_body.position[0], _body.position[1]];
            if (data.randomX)
            {
                pos[0] += this.Random(-data.randomX * 0.5, data.randomX * 0.5);
            }
            if (data.randomY)
            {
                pos[1] += this.Random(-data.randomY * 0.5, data.randomY * 0.5);
            }
            if (!pawn)
            {                
                var bTimer = true;
                if (data.timer <= 0)
                {
                    var objectData = data.objectData;
                    if (objectData)
                    {
                        switch (objectData.type)
                        {
                            case ObjectType.CHARACTER:
                            case ObjectType.DINOSAUR:
                            case ObjectType.DUMMY:
                                let numPawns = this.getPawns().length;
                                if (numPawns >= this.settings.maxPawns)
                                {
                                    return;
                                }
                                break;
                        }
                        objectData.id = data.objectId ? data.objectId : this.getRandomUniqueId();
                        switch (objectData.type)
                        {
                            case ObjectType.SPAWNER:
                                break;

                            case ObjectType.DROPPED_WEAPON:
                                var dropped = this.clone(objectData);
                                dropped.weaponData = this.getWeaponData(objectData.weaponId)
                                pawn = this.createDroppedWeapon(pos, dropped);
                                pawn.data.bSpawned = true;
                                break;

                            case ObjectType.HELICOPTER:
                                pawn = this.createHelicopter(pos, objectData);
                                break;

                            case ObjectType.TANK:
                                pawn = this.createTank(pos, objectData);
                                break;

                            case ObjectType.CAR:
                                pawn = this.createCar(pos, objectData);
                                break;

                            case ObjectType.MOUNTED_WEAPON:
                                pawn = this.createMountedWeapon(pos, objectData);
                                break;

                            case ObjectType.ARROW:
                                pawn = this.createArrow(pos, objectData);
                                break;

                            default:
                                delete objectData.bRespawn;
                                objectData.position = pos;
                                pawn = this.createObject(objectData);
                                break;
                        }
                    }
                    else
                    {
                        console.warn("Invalid spawner data", objectData);
                    }
                    if (pawn)
                    {
                        data.ids[i] = pawn.data.id;
                        numSpawned++;
                    }
                    else
                    {
                        this.scenarioLog("Spawner did not create a pawn", Colours.RED_STRING);
                    }
                }
                break;
            }
        }
        if (bTimer)
        {            
            if (data.timer > 0)
            {
                data.timer--;
            }
            else
            {
                data.timer = data.timerMax;
            }            
        }
        if (numSpawned > 0 && data.totalObjects != null)
        {
            data.totalObjects -= numSpawned;
            if (data.totalObjects <= 0)
            {
                this.removeNextStep(_body);
            }
        }
    }

    createTank(_position, _data)
    {
        if (!_data.vehicleId)
        {
            _data.vehicleId = Tank.ABRAMS;
            console.warn("Missing vehicle id");
        }
        var shared = this.getSharedData(_data.vehicleId);
        var body = new this.p2.Body({
            mass: _data.mass != null ? _data.mass : shared.mass,
            position: _position,
            angle: _data.angle != null ? _data.angle : (_data.rotation != null ? this.ToRad(_data.rotation) : 0),
            damping: 0.99,
            angularDamping: shared.angularDamping,
            allowSleep: true,
            sleepSpeedLimit: 10
        });
        var damageMultipliers = {
            1: 0.025,
            2: 0.025,
            3: 1,
            4: 0.05
        };        
        if (this.game.bSurvival)
        {
            damageMultipliers = {
                1: 0.025,
                2: 0.025,
                3: 0.35,
                4: 0.05
            };
        }
        body.data = {
            id: _data.id ? _data.id : this.getRandomUniqueId(),
            type: ObjectType.TANK,
            material: Material.METAL,
            damageMultipliers: damageMultipliers,
            team: _data.team != null ? _data.team : -1,
            speed: 2500,
            health: 4000,
            vehicleId: _data.vehicleId,
            bAutomated: _data.bAutomated,
            bDisabled: _data.bDisabled,
            bRegenHealth: _data.bRegenHealth != null ? _data.bRegenHealth : this.game.bSurvival,
            bGodMode: _data.bGodMode,
            bUnlimitedAmmo: true,
            regenTimerMax: 180 * this.game.fpsMult,
            regenTimer: 0,
            regenThreshold: 0.25,
            pawnName: _data.pawnName,            
            tint: _data.tint
        };
        var data = body.data;
        var bSurvivalAlly = this.game.bSurvival && data.team <= 0;
        switch (data.vehicleId)
        {
            case Tank.ABRAMS:
                data.speed = 2500;
                data.maxSpeed = 275;
                data.health = 4000;
                data.seats = [
                    {
                        position: [0, 0],
                        bInvisible: true
                    },
                    {
                        position: [0, 0],
                        damageMultiplier: bSurvivalAlly ? 0 : 0.1,
                    },
                    {
                        position: [-110, -40],
                        bInput: true,
                        damageMultiplier: bSurvivalAlly ? 0.25 : 0.5,
                    },
                    {
                        position: [-110, 40],
                        bInput: true,
                        damageMultiplier: bSurvivalAlly ? 0.25 : 0.5,
                    }
                ];
                var coaxial = this.getWeaponData("m240");
                coaxial.accuracy = 3.5;                
                var m2 = this.getWeaponData("m2");
                if (this.game.bSurvival)
                {
                    coaxial.damage *= 1.5;
                    m2.damage *= 1.5;
                }
                data.weapons = [
                    [
                        {
                            muzzlePos: [0, 0],
                            weaponData: this.getWeaponData("m256a1"),
                            aimSpeed: 0.1
                        },
                        {
                            muzzlePos: [0, 0],
                            weaponData: coaxial,
                            aimSpeed: 0.1
                        }
                    ],
                    [
                        {
                            muzzlePos: [0, 0],
                            weaponData: m2
                        }
                    ],
                    [
                        null
                    ],
                    [
                        null
                    ]
                ];
                break;
            case Tank.T90:
                data.speed = 3000;
                data.maxSpeed = 300;
                data.health = 3800;
                data.seats = [
                    {
                        position: [20, 0],
                        bInvisible: true
                    },
                    {
                        position: [20, 0],
                        damageMultiplier: bSurvivalAlly ? 0 : 0.1,
                    },
                    {
                        position: [-100, -40],
                        bInput: true,
                        damageMultiplier: bSurvivalAlly ? 0.25 : 0.5,
                    },
                    {
                        position: [-100, 40],
                        bInput: true,
                        damageMultiplier: bSurvivalAlly ? 0.25 : 0.5,
                    }
                ];
                var m2 = this.getWeaponData("m2");
                if (this.game.bSurvival)
                {
                    m2.damage *= 1.5;
                }
                data.weapons = [
                    [
                        {
                            muzzlePos: [20, 0],
                            weaponData: this.getWeaponData("d81"),
                            aimSpeed: 0.1
                        }
                    ],
                    [
                        {
                            muzzlePos: [20, 0],
                            weaponData: m2
                        }
                    ],
                    [
                        null
                    ],
                    [
                        null
                    ]
                ];
                break;
        }
        data.speed /= this.game.fpsMult;
        this.initVehicleWeapons(body, data.weapons);
        if (_data.weapons)
        {
            this.applyCustomVehicleWeapons(body, _data.weapons);
        }
        if (_data.weaponRotation != null)
        {
            if (data.weapons && data.weapons[0])
            {
                this.setVehicleWeaponAimRotation(body, 0, data.weapons[0][0], body.angle + this.ToRad(_data.weaponRotation), 1, true);
            }
        }
        data.maxHealth = data.health;        
        var shape = new this.p2.Box({
            width: shared.width,
            height: shared.height,
            collisionGroup: CollisionGroups.OBJECT,
            collisionMask: CollisionGroups.GROUND | CollisionGroups.PROJECTILE | CollisionGroups.OBJECT | CollisionGroups.PAWN | CollisionGroups.BOUNDS
        });
        body.addShape(shape);
        this.addWorldBody(body);
        this.requestEvent({
            eventId: GameServer.EVENT_SPAWN_OBJECT,
            type: ObjectType.TANK,
            position: body.position,
            rotation: body.angle,
            data: body.data
        });
        return body;
    }

    getCharacterInventoryItemIndex(_body, _weaponId)
    {
        if (_body)
        {
            var inventory = _body.data.inventory;
            if (inventory)
            {
                for (var i = 0; i < inventory.length; i++)
                {
                    var item = inventory[i];
                    if (item && item.id == _weaponId)
                    {
                        return i;
                    }
                }
            }
        }
        return -1;
    }

    characterHasEquipment(_body, _weaponId)
    {
        if (_body)
        {
            var equipment = _body.data.equipment;
            return equipment && equipment.id == _weaponId && (equipment.ammo || equipment.bPassive);
        }
        return false;
    }

    characterHasGrenade(_body, _weaponId)
    {
        if (_body)
        {
            var equipment = _body.data.grenade;
            return grenade && grenade.id == _weaponId;
        }
        return false;
    }

    setVehicleWeapon(_vehicle, _seatIndex, _weaponIndex, _weaponData)
    {
        if (_vehicle)
        {
            try
            {
                var data = _vehicle.data;
                var weapons = data.weapons;
                if (weapons)
                {
                    if (_weaponData)
                    {
                        delete data.seats[_seatIndex].bInput;
                    }
                    var wpn = weapons[_seatIndex][_weaponIndex] = {
                        aimRotation: 0,
                        overheat: 0,
                        muzzlePos: [0, 0],
                        weaponData: _weaponData
                    };
                    this.initVehicleWeapon(_vehicle, wpn);
                    this.pushObjectDataUpdate(data.id, ["weapons"]);
                }
                else
                {
                    this.log("Invalid vehicle weapons");
                }
            }
            catch (e)
            {
                this.onGameError(e);
            }
        }
    }

    createCar(_position, _data)
    {
        if (!_data.vehicleId)
        {
            console.warn("Missing vehicle id", _data);
            _data.vehicleId = Car.QUAD;            
        }
        var shared = this.getSharedData(_data.vehicleId);
        var body = new this.p2.Body({
            mass: _data.mass != null ? _data.mass : shared.mass,
            position: _position,
            angle: _data.angle != null ? _data.angle : (_data.rotation ? this.ToRad(_data.rotation) : 0),
            damping: 0.99,
            angularDamping: shared.angularDamping,
            allowSleep: true,
            sleepSpeedLimit: 10
        });
        if (_data.rotation)
        {
            body.angle = this.ToRad(_data.rotation);
        }
        body.data = {
            id: _data.id ? _data.id : this.getRandomUniqueId(),
            type: ObjectType.CAR,
            material: Material.METAL,
            damageMultipliers: {
                1: 0.25,
                2: 0.25,
                3: 1.5,
                4: 0.1
            },
            team: _data.team != null ? _data.team : -1,
            scale: _data.scale != null ? _data.scale : 1,
            carData: _data,
            vehicleId: _data.vehicleId,
            bRegenHealth: _data.bRegenHealth != null ? _data.bRegenHealth : true,
            regenTimerMax: 180 * this.game.fpsMult,
            regenTimer: 0,
            regenThreshold: 0.25,
            bAutomated: _data.bAutomated,
            bUntargetable: _data.bUntargetable,
            bUnlimitedAmmo: true,
            bKillOccupantsWhenDestroyed: _data.bKillOccupantsWhenDestroyed,
            bLeaveWhenNoOccupants: _data.bLeaveWhenNoOccupants,
            bGodMode: _data.bGodMode,
            pawnName: _data.pawnName,
            tint: _data.tint
        };
        var data = body.data;
        var bSurvivalAlly = this.game.bSurvival && data.team <= 0;
        if (this.game.bSurvival)
        {
            data.damageMultipliers = {
                1: 0.1,
                2: 0.1,
                3: 1.5,
                4: 0.01
            };
        }
        switch (data.vehicleId)
        {
            case Car.QUAD:
                data.speed = 500;
                data.health = 500;
                data.seats = [
                    {
                        position: [5, 0],
                    },
                    {
                        position: [-30, 0],
                        bInput: true
                    }
                ];
                break;
            case Car.PICKUP:
                data.speed = 1000;
                data.health = 1000;
                data.seats = [
                    {
                        position: [40, 0],
                        bInvisible: true
                    },
                    {
                        position: [-20, -20],
                        bInput: true
                    },
                    {
                        position: [-20, 20],
                        bInput: true
                    },
                    {
                        position: [-65, -20],
                        bInput: true
                    },
                    {
                        position: [-65, 20],
                        bInput: true
                    }
                ];
                data.weapons = [
                    [null],
                    [null],
                    [null],
                    [null],
                    [null]
                ];
                break;
            case Car.GROWLER:
                data.speed = 1000;
                data.health = 1000;
                data.seats = [
                    {
                        position: [0, -15],
                    },
                    {
                        position: [-45, 0]
                    },
                    {
                        position: [0, 15],
                        bInput: true,
                        damageMultiplier: 0.5
                    }
                ];
                data.weapons = [
                    [
                        null
                    ],
                    [
                        {
                            muzzlePos: [-45, 0],
                            weaponData: this.getWeaponData("m240"),
                            aimRotation: 0
                        }
                    ],
                    [
                        null
                    ]
                ];
                break;
            case Car.MRAP:
                if (bSurvivalAlly)
                {
                    data.damageMultipliers[DamageType.DAMAGE_BULLET] = 0.05;
                    data.damageMultipliers[DamageType.DAMAGE_EXPLOSIVE] = 0.25;
                }
                data.speed = 1250;
                data.health = 2000;
                data.seats = [
                    {
                        position: [30, 0],
                        bInvisible: true,
                        bBack: true
                    },
                    {
                        position: [-15, 0],
                        damageMultiplier: bSurvivalAlly ? 0 : 0.1
                    },
                    {
                        position: [-70, -35],
                        bInput: true,
                        damageMultiplier: bSurvivalAlly ? 0.25 : 0.5,
                    },
                    {
                        position: [-70, 35],
                        bInput: true,
                        damageMultiplier: bSurvivalAlly ? 0.25 : 0.5,
                    }
                ];
                var m2 = this.getWeaponData("m2");
                if (this.game.bSurvival)
                {
                    m2.damage *= 1.25;
                }
                data.weapons = [
                    [
                        null
                    ],
                    [
                        {
                            muzzlePos: [-10, 0],
                            weaponData: m2,
                            aimRotation: 0
                        }
                    ],
                    [
                        null
                    ],
                    [
                        null
                    ]
                ];
                break;
            case Car.LAV25:
                if (this.game.bSurvival)
                {
                    data.damageMultipliers[DamageType.DAMAGE_BULLET] = 0.05;
                    data.damageMultipliers[DamageType.DAMAGE_EXPLOSIVE] = 1;
                }
                data.speed = 1200;
                data.health = 2000;
                data.seats = [
                    {
                        position: [20, 0],
                        bBack: true,
                        bInvisible: true
                    },
                    {
                        position: [-30, 0],
                        damageMultiplier: bSurvivalAlly ? 0 : 0.1,
                    },
                    {
                        position: [-100, -35],
                        bInput: true,
                        damageMultiplier: bSurvivalAlly ? 0.25 : 0.5,
                    },
                    {
                        position: [-100, 35],
                        bInput: true,
                        damageMultiplier: bSurvivalAlly ? 0.25 : 0.5
                    }
                ];
                var lav = this.getWeaponData("m242");
                lav.accuracy = 1;
                if (this.game.bSurvival && data.team == 0)
                {
                    data.damage *= 1.5;
                }
                data.weapons = [
                    [
                        {
                            muzzlePos: [-20, 0],
                            weaponData: lav,
                            aimRotation: 0
                        }
                    ],
                    [
                        {
                            muzzlePos: [-30, 0],
                            weaponData: this.getWeaponData("m240"),
                            aimRotation: 0
                        }
                    ],
                    [
                        null
                    ],
                    [
                        null
                    ]
                ];
                break;
        }
        if (_data.weapons)
        {        
            this.applyCustomVehicleWeapons(body, _data.weapons);
        }
        this.initVehicleWeapons(body, data.weapons);        
        if (_data.weaponRotation != null)
        {
            if (data.weapons && data.weapons[0])
            {
                this.setVehicleWeaponAimRotation(body, 0, data.weapons[0][0], body.angle + this.ToRad(_data.weaponRotation), 1, true);
            }
        }
        data.maxHealth = data.health;
        data.speed /= this.game.fpsMult;
        if (_data.speed)
        {
            data.speed = _data.speed;
        }
        this.optimizeKeys(data);
        var shape = new this.p2.Box({
            width: shared.width,
            height: shared.height,
            collisionGroup: CollisionGroups.OBJECT,
            collisionMask: CollisionGroups.GROUND | CollisionGroups.PROJECTILE | CollisionGroups.OBJECT | CollisionGroups.PAWN | CollisionGroups.BOUNDS
        });
        body.addShape(shape);
        this.addWorldBody(body);
        this.requestEvent({
            eventId: GameServer.EVENT_SPAWN_OBJECT,
            type: ObjectType.CAR,
            position: body.position,
            rotation: body.angle,
            data: body.data
        });
        return body;
    }

    applyCustomVehicleWeapons(_vehicle, _weapons)
    {
        var data = _vehicle.data;
        data.bCustomWeapons = true;
        if (_weapons)
        {
            for (var i = 0; i < _weapons.length; i++)
            {
                if (!data.seats[i])
                {
                    continue;
                }
                let weaponList = _weapons[i];
                if (weaponList)
                {
                    for (var j = 0; j < weaponList.length; j++)
                    {
                        let weapon = weaponList[j];
                        if (weapon)
                        {                            
                            if (!data.weapons)
                            {
                                data.weapons = [];
                                for (let k = 0; k < data.seats.length; k++)
                                {
                                    data.weapons.push([null]);
                                }
                            }
                            if (!data.weapons[i][j] || 1)
                            {
                                data.weapons[i][j] = {
                                    muzzlePos: data.type == ObjectType.MOUNTED_WEAPON ? [0, 0] : data.seats[i].position,
                                    aimRotation: 0
                                }
                            }
                            let weaponData = this.getWeaponData(weapon.id, weapon);
                            if (weaponData && !weaponData.bEquipment)
                            {
                                if (weaponData.bVehicle)
                                {
                                    this.initVehicleWeapon(_vehicle, weapon);
                                }
                                weaponData.bVehicle = true;
                                data.weapons[i][j].weaponData = weaponData;
                                delete data.seats[i].bInput;
                            }
                        }
                    }
                }
            }
        }
    }

    detachRope(_body)
    {
        if (_body)
        {
            var data = _body.data;
            if (data.attachId)
            {
                this.game.world.removeConstraint(_body.constraint);
                delete _body.constraint;
                var attached = this.getObjectById(data.attachId);
                if (attached)
                {
                    var shared = this.getSharedData(attached.data.vehicleId);
                    if (shared && shared.mass)
                    {
                        //attached.mass = shared.mass;
                    }
                    else
                    {
                        //attached.mass = this.isVehicle(attached) ? 10 : 1;
                    }
                    //attached.updateMassProperties();
                    this.game.world.removeConstraint(attached.constraint);
                    delete attached.constraint;
                    this.setDataValue(attached, "attachToId", null);                    
                }
                this.setDataValue(_body, "attachId", null);
            }
        }
    }

    attachObjects(_body, _target)
    {
        if (_target && _target.data.health)
        {
            //_target.mass = Math.min(_target.mass, 1);
            //_target.updateMassProperties();
            _target.data.attachToId = _body.data.id;

            var constraint = new this.p2.RevoluteConstraint(_body, _target, {
                worldPivot: [_body.position[0], _body.position[1]]
            });
            constraint.setRelaxation(0.5);
            constraint.setStiffness(100);
            //constraint.upperLimit = this.ToRad(75);
            //constraint.upperLimitEnabled = true;
            //constraint.lowerLimit = this.ToRad(-75);
            //constraint.lowerLimitEnabled = true;
            this.game.world.addConstraint(constraint);

            _target.constraint = constraint;
            _body.constraint = constraint;

            this.setDataValue(_target, "attachToId", _body.data.id);
            this.setDataValue(_body, "attachId", _target.data.id);
        }
    }

    createHelicopter(_position, _data)
    {
        if (!_data.vehicleId)
        {
            _data.vehicleId = Helicopter.MH6;
            console.warn("Missing vehicle id");
        }
        var shared = this.getSharedData(_data.vehicleId);
        if (!shared)
        {
            shared = {
                mass: 10,
                width: 32,
                height: 32
            };
        }
        var useMass = Math.max(0, _data.mass != null ? _data.mass : (shared.mass ? shared.mass : 10));
        var body = new this.p2.Body({
            mass: useMass,
            position: _position,
            angle: _data.angle != null ? _data.angle : (_data.rotation != null ? this.ToRad(_data.rotation) : 0),
            angularDamping: 0.8,
            damping: 0.5,
            allowSleep: true,
            sleepSpeedLimit: 10
        });
        body.data = {
            id: _data.id ? _data.id : this.getRandomUniqueId(),
            type: ObjectType.HELICOPTER,
            material: Material.METAL,
            damageMultipliers: {
                1: 0.5,
                2: 0.1,
                3: 2,
                4: 0.1
            },
            mass: useMass,
            sway: this.Random(0, 99),
            swayDir: this.RandomBoolean() ? 1 : -1,
            swayMax: 100,
            team: _data.team != null ? _data.team : -1,
            scale: _data.scale != null ? _data.scale : 1,
            angleMult: 0.015,
            vehicleId: _data.vehicleId,
            bRegenHealth: _data.bRegenHealth != null ? _data.bRegenHealth : this.game.bSurvival,
            regenTimerMax: 180 * this.game.fpsMult,
            regenTimer: 0,
            regenThreshold: 0.25,
            speed: 2500,
            speedMultiplier: _data.speedMultiplier,
            playerId: _data.playerId,
            bAutomated: _data.bAutomated,
            bUntargetable: _data.bUntargetable,
            bDisabled: _data.bDisabled,
            bUnlimitedAmmo: true,
            bGodMode: _data.bGodMode,
            items: _data.items,
            bDropItemsWhenDestroyed: _data.bDropItemsWhenDestroyed != null ? _data.bDropItemsWhenDestroyed : true,
            bKillOccupantsWhenDestroyed: _data.bKillOccupantsWhenDestroyed,
            destination: _data.destination,
            destinationTimer: (_data.destinationTimer ? _data.destinationTimer : 3) * this.game.settings.fps,
            defendTimer: _data.defendTimer ? _data.defendTimer : 0,
            itemTimerMax: (_data.itemTimerMax ? _data.itemTimerMax : 5) * this.game.settings.fps,
            pawnName: _data.pawnName,
            indicatorData: _data.indicatorData,
            interactTeam: _data.interactTeam,
            tint: _data.tint,
            enemyTypes: _data.enemyTypes,
            objectScale: _data.objectScale,
            departSpeedMult: _data.departSpeedMult
        };
        var data = body.data;
        if (this.game.bSurvival)
        {
            data.reward = 500;
            if (data.team == 1)
            {
                data.damageMultipliers[DamageType.DAMAGE_EXPLOSIVE] = 1.5;
            }
        }
        var gatling = this.getWeaponData("gatling");        
        switch (data.vehicleId)
        {
            case Helicopter.MH6:
                data.health = 1000;
                data.speed = 2000;
                data.seats = [
                    {
                        position: [40, 0],
                        bInvisible: true
                    }
                ];
                data.weapons = [
                    [
                        {
                            muzzlePos: [40, 0],
                            aimRotation: 0,
                            overheat: 0
                        }
                    ]
                ];
                break;

            case Helicopter.SEAKNIGHT:
                data.health = 3000;
                data.speed = 1250;
                data.seats = [
                    {
                        position: [50, 0],
                        bInvisible: true
                    },
                    {
                        position: [0, 0],
                        bInvisible: true
                    },
                    {
                        position: [-50, 0],
                        bInvisible: true
                    },
                    {
                        position: [-100, 0],
                        bInvisible: true
                    }
                ];
                data.weapons = [
                    [
                        {
                            muzzlePos: [0, 0],
                            aimRotation: 0,
                            overheat: 0
                        }
                    ],
                    [
                        null
                    ],
                    [
                        null
                    ],
                    [
                        null
                    ]
                ];
                break;

            case Helicopter.COBRA:
                data.health = 1500;
                data.speed = 2000;
                data.seats = [
                    {
                        position: [80, 0],
                        bInvisible: true
                    }
                ];
                data.weapons = [
                    [
                        {
                            muzzlePos: [80, 0],
                            weaponData: gatling
                        }
                    ]
                ];
                break;

            case Helicopter.APACHE:
                data.health = 2000;
                data.speed = 1500;
                data.seats = [
                    {
                        position: [80, 0],
                        bInvisible: true
                    }
                ];
                data.weapons = [
                    [
                        {
                            muzzlePos: [80, 0],
                            weaponData: this.getWeaponData("rocket_guided")
                        },
                        {
                            muzzlePos: [80, 0],
                            weaponData: gatling
                        }
                    ]
                ];
                break;

            case Helicopter.KIOWA:
                data.health = 1750;
                data.speed = 1750;
                data.seats = [
                    {
                        position: [150, 0],
                        bInvisible: true
                    },
                    {
                        position: [100, -30],
                        bInput: true
                    },
                    {
                        position: [100, 30],
                        bInput: true
                    }
                ];
                data.weapons = [
                    [
                        {
                            muzzlePos: [150, 0],
                            weaponData: this.getWeaponData("minigun")
                        }
                    ],
                    [
                        null
                    ],
                    [
                        null
                    ]
                ];
                break;

            case Helicopter.BLACKHAWK:
                data.health = 3000;
                data.speed = 1250;
                data.seats = [
                    {
                        position: [150, 0],
                        bInvisible: true
                    },
                    {
                        position: [120, -35],
                        bInvisible: false
                    },
                    {
                        position: [120, 35],
                        bInvisible: false
                    },
                    {
                        position: [70, -35],
                        bInvisible: false,
                        bInput: true
                    },
                    {
                        position: [70, 35],
                        bInvisible: false,
                        bInput: true
                    }
                ];
                data.weapons = [
                    [
                        {
                            muzzlePos: [0, 0],
                            aimRotation: 0,
                            overheat: 0
                        }
                    ],
                    [
                        {
                            muzzlePos: [120, -40],
                            weaponData: this.getWeaponData("minigun")
                        }
                    ],
                    [
                        {
                            muzzlePos: [120, 40],
                            weaponData: this.getWeaponData("minigun")
                        }
                    ],
                    [
                        null
                    ],
                    [
                        null
                    ]
                ];
                break;

            case Helicopter.OSPREY:
                data.health = 3250;
                data.speed = 1500;
                var m242 = this.getWeaponData("m242");
                if (this.game.bSurvival && data.team != 0)
                {
                    m242.accuracy = 5;
                }
                data.seats = [
                    {
                        position: [100, 0],
                        bInvisible: true
                    },
                    {
                        position: [50, 0],
                        bInvisible: true
                    },
                    {
                        position: [-50, -20],
                        bInvisible: true,
                        bInput: true
                    },
                    {
                        position: [-50, 20],
                        bInvisible: true,
                        bInput: true
                    }
                ];
                data.weapons = [
                    [
                        {
                            muzzlePos: [0, 0],
                            weaponData: m242
                        },
                    ],
                    [
                        {
                            muzzlePos: [160, 0],
                            weaponData: gatling
                        }
                    ],
                    [
                        null
                    ],
                    [
                        null
                    ]
                ];
                break;

            case Helicopter.CHICKENCOPTER:
                data.health = 500;
                data.speed = 1000;
                data.seats = [
                    {
                        position: [0, 0]
                    }
                ];
                var chickenM2 = this.getWeaponData("m2");
                data.weapons = [
                    [
                        {
                            muzzlePos: [0, 0],
                            weaponData: chickenM2
                        }
                    ]
                ];
                break;

            default:
                console.warn("Unhandled helicopter", data.vehicleId);
                data.health = 1000;
                data.speed = 1500;
                data.seats = [
                    {
                        position: [0, 0]
                    }
                ];
                data.weapons = [
                    [
                        {
                            muzzlePos: [0, 0],
                            weaponData: this.getWeaponData("m2")
                        }
                    ]
                ];
                break;
        }
        data.speed = Math.round(data.speed / this.game.fpsMult);
        if (data.bAutomated)
        {
            var mainWeapon = data.weapons[0] ? data.weapons[0][0] : null;
            if (mainWeapon && mainWeapon.weaponData)
            {
                mainWeapon.weaponData.ammoMax = mainWeapon.weaponData.ammo;
            }
        }
        this.initVehicleWeapons(body, data.weapons);
        if (_data.weapons)
        {
            this.applyCustomVehicleWeapons(body, _data.weapons);
        }
        data.maxHealth = data.health;
        if (this.game.bSurvival && data.team == 0)
        {
            data.damageMultipliers = {
                1: 0.1,
                2: 0.1,
                3: 0.25,
                4: 0.1
            };
        }
        var shape = new this.p2.Box({
            width: shared.width,
            height: shared.height,
            collisionGroup: CollisionGroups.HELICOPTER,
            collisionMask: data.bAutomated ? (CollisionGroups.HELICOPTER | CollisionGroups.PROJECTILE) : (CollisionGroups.GROUND | CollisionGroups.PROJECTILE | CollisionGroups.OBJECT | CollisionGroups.PAWN | CollisionGroups.BOUNDS)
        });
        body.addShape(shape);
        this.addWorldBody(body);
        this.requestEvent({
            eventId: GameServer.EVENT_SPAWN_OBJECT,
            type: ObjectType.HELICOPTER,
            position: body.position,
            rotation: body.angle,
            data: body.data
        });        
        return body;
    }

    initVehicleWeapons(_vehicle, _weapons)
    {
        var data = _vehicle.data;
        data.weaponIndex = 0;
        if (_weapons)
        {
            for (var i = 0; i < _weapons.length; i++)
            {
                var weaponList = _weapons[i];
                if (weaponList)
                {
                    for (var j = 0; j < weaponList.length; j++)
                    {
                        var wpn = weaponList[j];
                        if (wpn)
                        {
                            this.initVehicleWeapon(_vehicle, wpn);
                        }
                    }
                }
            }
        }
    }

    initVehicleWeapon(_vehicle, _data)
    {
        _data.overheat = 0;
        _data.aimRotation = _vehicle.angle;
        if (_data.weaponData)
        {
            _data.weaponData.bVehicle = true;
            if (_data.weaponData.ammoMax)
            {
                _data.ammo = _data.weaponData.ammoMax;
                _data.weaponData.overheatMax = 100;
                _data.weaponData.overheatNum = Math.round(_data.weaponData.overheatMax / _data.weaponData.ammoMax);
                _data.weaponData.overheatCooldownNum = 0;
            }
        }
    }

    setPawnRequest(_body, _value)
    {
        if (_body && _body.data && _body.data.type == ObjectType.CHARACTER)
        {
            this.setDataValue(_body, "currentRequest", _value ? _value : 0);
            if (_value)
            {
                switch (_value)
                {
                    case Commands.REQUEST_FOLLOW:
                        var time = 10;
                        break;
                    default:
                        time = 3;
                        break;
                }
                _body.data.requestTimer = this.game.settings.fps * time;
            }
        }
    }

    createDoor(_data)
    {
        var body = new this.p2.Body({
            mass: 0,
            position: _data.position,
            angle: _data.rotation != null ? this.ToRad(_data.rotation) : 0,
            allowSleep: true,            
            sleepSpeedLimit: 10
        });
        var size = _data.size ? _data.size : 100;      
        switch (_data.doorType)
        {
            case "garage":
            case "garage_large":
            case "sliding":
                var material = Material.METAL;
                break;
            default:
                material = Material.WOOD;
                break;
        }
        if (_data.material)
        {
            material = _data.material;
        }
        body.data = {
            id: _data.id ? _data.id : this.getRandomUniqueId(),
            type: ObjectType.DOOR,
            bClosed: _data.bClosed,
            bDisabled: _data.bDisabled,
            triggerId: _data.triggerId,
            material: material,
            width: 50,
            size: size,
            cooldownTimer: 0,
            team: -1,
            doorType: _data.doorType,
            leverId: _data.leverId,
            health: _data.health,
            layer: _data.layer,
            bSkipServerUpdate: true
        };
        body.addShape(new this.p2.Box({
            width: body.data.width,
            height: size,
            collisionGroup: CollisionGroups.PAWN
        }));
        this.addWorldBody(body);
        this.requestEvent({
            eventId: GameServer.EVENT_SPAWN_OBJECT,
            type: ObjectType.DOOR,
            position: body.position,
            rotation: body.angle,
            data: body.data
        });
        this.setDoorClosed(body, body.data.bClosed);
        return body;
    }

    setDoorClosed(_door, _bClosed, _causer, _bImpact, _bForce)
    {
        if (_door)
        {
            var data = _door.data;
            if (!_bForce && data["cooldownTimer"] > 0)
            {
                return;
            }
            var prev = data.bClosed;
            data.bClosed = _bClosed;
            var shape = _door.shapes[0];
            if (_bClosed)
            {
                shape.collisionGroup = CollisionGroups.GROUND;
                shape.collisionMask = CollisionGroups.PAWN | CollisionGroups.PROJECTILE | CollisionGroups.OBJECT | CollisionGroups.HELICOPTER | CollisionGroups.FLAME
            }
            else
            {
                shape.collisionGroup = 0;
                shape.collisionMask = 0;
            }
            if (data.bClosed != prev)
            {
                var scale = null;
                if (_causer)
                {
                    data["cooldownTimer"] = Math.round(this.game.settings.fps * 0.5);
                    if (!_bClosed)
                    {
                        var causerPos = _causer.previousPosition ? _causer.previousPosition : _causer.position;
                        switch (_door.angle)
                        {
                            case this.ToRad(90):
                            case this.ToRad(-90):
                                scale = _door.position[1] > causerPos[1] ? 1 : -1;
                                break;
                            default:
                                scale = _door.position[0] > causerPos[0] ? 1 : -1;
                                break;
                        }
                    }
                }
                this.onEvent({
                    eventId: GameServer.EVENT_PAWN_ACTION,
                    pawnId: data.id,
                    causerId: _causer ? _causer.data.id : null,
                    type: GameServer.PAWN_UPDATE_DOOR,
                    bClosed: data.bClosed,
                    scale: scale,
                    bImpact: _bImpact
                });
                if (data.bClosed)
                {
                    this.dispatchTrigger({
                        event: "doorClosed",
                        objectId: data.id,
                        causerId: _causer ? _causer.data.id : null
                    });
                }
                else
                {
                    this.dispatchTrigger({
                        event: "doorOpened",
                        objectId: data.id,
                        causerId: _causer ? _causer.data.id : null
                    });
                }
            }
            if (data.bDisabled)
            {
                if (data.bClosed)
                {
                    this.addDirtyNodeObject(_door);
                }
                else
                {
                    this.removeDirtyNodeObject(data.id);
                }
            }
        }
    }

    createForest(_threshold = 200)
    {
        var threshold = Math.max(100, _threshold);
        var map = this.getCurrentMapData();
        var numX = Math.round(this.getMapWidth() / threshold);
        var numY = Math.round(this.getMapHeight() / threshold);
        var offset = threshold;
        for (var i = 0; i < numX; i++)
        {
            for (var j = 0; j < numY; j++)
            {
                var pos = [(i * threshold) + (threshold * 0.5) + this.Random(-offset, offset), (j * threshold) + (threshold * 0.5) + this.Random(-offset, offset)];
                if (!this.isInWall([pos]))
                {
                    this.createTree({
                        type: ObjectType.TREE,
                        treeType: this.RandomBoolean() ? "tree" : "tree_palm",
                        position: pos,
                        angle: this.RandomAngle(),
                    });
                }
            }
        }
        /*
        this.triggerCallback("chat", {
            messageText: "Created forest with " + (numX * numY) + " trees"
        });
        */
    }

    createBoxes(_threshold = 200)
    {
        var threshold = Math.max(200, _threshold);
        var numX = Math.round(this.getMapWidth() / threshold);
        var numY = Math.round(this.getMapHeight() / threshold);
        var offset = (threshold * 0.5);
        var boxes = [
            "box",
            "box",
            "box_small"
        ];
        for (var i = 0; i < numX; i++)
        {
            for (var j = 0; j < numY; j++)
            {
                var pos = [(i * threshold) + threshold + this.Random(-offset, offset), (j * threshold) + threshold + this.Random(-offset, offset)];
                if (!this.isInWall([pos]))
                {
                    this.createObstacle({
                        type: ObjectType.OBSTACLE,
                        obstacleId: boxes[this.Random(0, boxes.length - 1)],
                        position: pos,
                        angle: this.RandomAngle()
                    });
                }
            }
        }
        /*
        this.triggerCallback("chat", {
            messageText: "Added " + (numX * numY) + " boxes"
        });
        */
    }

    createMountedWeapon(_position, _data)
    {
        var body = new this.p2.Body({
            mass: _data.mass ? _data.mass : 0,
            position: _position,
            angle: _data.angle != null ? _data.angle : (_data.rotation != null ? this.ToRad(_data.rotation) : 0),
            damping: 0.99,
            angularDamping: 0.99,
            allowSleep: true,
            sleepSpeedLimit: 10           
        });
        body.data = {
            id: _data.id ? _data.id : this.getRandomUniqueId(),
            type: ObjectType.MOUNTED_WEAPON,
            material: Material.METAL,
            vehicleId: _data.vehicleId,
            weaponType: _data.vehicleId,
            team: _data.team != null ? _data.team : -1,
            scale: 1,
            playerId: _data.playerId,
            damageMultipliers: {
                1: 1,
                2: 2,
                3: 1,
                4: 0.1
            },
            bAutomated: _data.bAutomated,
            ammo: _data.ammo != null ? _data.ammo : 100,
            bRegenHealth: _data.bRegenHealth != null ? _data.bRegenHealth : true,
            regenThreshold: 0.25,
            reward: _data.bAutomated ? 500 : 50,
            pawnName: _data.pawnName,
            maxRange: _data.maxRange,
            bUntargetable: _data.bUntargetable,
            bUnlimitedAmmo: _data.bUnlimitedAmmo != null ? _data.bUnlimitedAmmo : (!_data.ammo),
            bDisableAutomatedLaser: _data.bDisableAutomatedLaser,
            bGodMode: _data.bGodMode,
            bAutoLock: _data.bAutoLock,
            bHideHealthBar: _data.bHideHealthBar
        };
        var data = body.data;
        if (this.game.bSurvival)
        {
            if (data.team == 0)
            {
                data.damageMultipliers = {
                    1: 0.1,
                    2: 0.25,
                    3: 1,
                    4: 0.1
                };
            }
            else
            {
                var bSurvivalEnemy = true;
                data.damageMultipliers = {
                    1: 1,
                    2: 2,
                    3: 2,
                    4: 0.1
                };
            }
        }
        var weapon = this.getWeaponData(data.vehicleId);
        switch (data.vehicleId)
        {
            case MountedWeapon.M2:
                data.health = 500;
                data.weaponData = {
                    type: data.vehicleId
                };
                data.seats = [
                    {
                        position: [-20, 0],
                        bTurret: true
                    }
                ];
                data.weapons = [
                    [
                        {
                            id: weapon.id,
                            muzzlePos: [0, 0],
                            weaponData: weapon
                        }
                    ]
                ];
                break;
            case MountedWeapon.M242:
                data.health = 750;
                data.frame = "bushmaster";
                data.weaponData = {
                    type: data.vehicleId
                };
                data.seats = [
                    {
                        position: [-20, 0],
                        bTurret: true
                    }
                ];
                weapon.fireRate = Math.round(weapon.fireRate * 0.75);
                data.weapons = [
                    [
                        {
                            id: weapon.id,
                            muzzlePos: [0, 0],
                            weaponData: weapon
                        }
                    ]
                ];
                break;
            case MountedWeapon.BGM71:
                data.health = 500;
                data.weaponData = {
                    type: data.vehicleId
                };
                data.seats = [
                    {
                        position: [-20, 0],
                        bBack: true,
                        bTurret: true
                    }
                ];
                data.weapons = [
                    [
                        {
                            muzzlePos: [0, 0],
                            weaponData: this.getWeaponData("bgm71")
                        }
                    ]
                ];
                break;
            default:
                data.health = 500;
                data.weaponData = {
                    type: data.vehicleId
                };
                data.seats = [
                    {
                        position: [-25, 0],
                        bTurret: true
                    }
                ];
                switch (data.vehicleId)
                {
                    case MountedWeapon.SENTRY_SHOTGUN:
                        data.ammo = 500;
                        var weapon = this.getWeaponData("jackhammer");
                        weapon.damage = 35;
                        weapon.fireRate = 15;
                        weapon.accuracy = 15;
                        weapon.range = 650;
                        break;
                    case MountedWeapon.SENTRY_SNIPER:
                        data.ammo = 250;
                        data.health = 1000;
                        weapon = this.getWeaponData("m82");
                        weapon.fireRate = 60;
                        if (this.game.bSurvival)
                        {
                            weapon.range = 2500;
                            if (data.team != 0)
                            {
                                weapon.damage = 1000;
                            }
                        }
                        break;
                    case MountedWeapon.SENTRY_GRENADE:
                        data.ammo = 250;
                        weapon = this.getWeaponData("thumper");
                        weapon.accuracy = 0;
                        weapon.fireRate = 90;
                        weapon.damage = 350;
                        weapon.radius = 300;
                        break;
                    case MountedWeapon.SENTRY_SAM:
                        data.ammo = 30;
                        weapon = this.getWeaponData("smaw");
                        weapon.fireRate = 180;
                        weapon.bAutoLock = true;
                        weapon.range = bSurvivalEnemy ? 5000 : 2500;                        
                        if (bSurvivalEnemy)
                        {
                            data.maxRange = weapon.range;
                            weapon.damage *= 3;
                        }
                        break;
                    case MountedWeapon.SENTRY_FLAME:
                        data.ammo = 1000;
                        data.health = 1000;
                        weapon = this.getWeaponData("flamethrower");
                        weapon.damage = weapon.fireDamage = 25;
                        weapon.fireRate = 6;
                        weapon.velocity = 1500;
                        weapon.fireTime = 1;
                        break;
                    case MountedWeapon.SENTRY_RAILGUN:
                        data.ammo = 80;
                        data.health = 1000;
                        weapon = this.getWeaponData("railgun");
                        weapon.damage = 750;
                        weapon.fireRate = 70;
                        break;
                    default:
                        data.ammo = 1000;
                        weapon = this.getWeaponData(_data.weaponId ? _data.weaponId : "mg4");
                        weapon.penetration = 1;
                        break;
                }
                weapon.useId = data.vehicleId;
                data.weapons = [
                    [
                        {
                            muzzlePos: [0, 0],
                            weaponData: weapon
                        }
                    ]
                ];
                break;
        }
        if (_data.ammo != null)
        {
            data.ammo = _data.ammo;
        }
        if (data.ammo)
        {
            data.ammoMax = data.ammo;
        }
        if (weapon)
        {
            data.range = weapon.range;
        }
        this.initVehicleWeapons(body, data.weapons);
        if (_data.weapons)
        {
            this.applyCustomVehicleWeapons(body, _data.weapons);
        }
        this.setVehicleWeaponAimRotation(body, 0, data.weapons[0], body.angle);
        switch (this.game.gameModeId)
        {
            case GameMode.EVOLUTION:
                data.damageMultipliers = {
                    1: 0.5,
                    2: 0.5,
                    3: 0.5,
                    4: 0.5
                };
                break;
        }
        data.maxHealth = data.health;
        body.addShape(new this.p2.Circle({
            radius: this.getSharedData("turret").size,
            collisionGroup: CollisionGroups.PAWN,
            collisionMask: CollisionGroups.GROUND | CollisionGroups.PROJECTILE | CollisionGroups.OBJECT
        }));
        if (data.playerId)
        {
            var arr = this.getMountedWeapons(data.playerId);
            if (arr.length >= this.settings.maxTurretsPerPlayer)
            {
                this.removeNextStep(arr[0]);
            }
        }
        this.addWorldBody(body);
        this.requestEvent({
            eventId: GameServer.EVENT_SPAWN_OBJECT,
            type: ObjectType.MOUNTED_WEAPON,
            position: body.position,
            rotation: body.angle,
            data: body.data
        });
        return body;
    }

    createWindow(_data)
    {
        var useMass = _data.mass != null ? _data.mass : 0;
        var body = new this.p2.Body({
            mass: useMass,
            position: _data.position,
            angle: _data.rotation != null ? this.ToRad(_data.rotation) : 0,
            allowSleep: true,
            sleepSpeedLimit: 1
        });
        body.data = {
            id: _data.id ? _data.id : this.getRandomUniqueId(),
            type: ObjectType.WINDOW,
            width: _data.width ? _data.width : 3,
            height: _data.height,
            material: Material.GLASS,
            health: _data.health ? _data.health : 1,
            bSkipServerUpdate: useMass == 0
        };
        var data = body.data;
        data.maxHealth = data.health;
        data.team = -1;
        data.damageMultipliers = {
            1: 1,
            2: 0.1,
            3: 50
        };
        body.addShape(new this.p2.Box({
            width: _data.width,
            height: _data.height,
            collisionGroup: CollisionGroups.OBJECT,
            collisionMask: CollisionGroups.GROUND | CollisionGroups.PAWN | CollisionGroups.PROJECTILE | CollisionGroups.OBJECT | CollisionGroups.HELICOPTER
        }));
        this.addWorldBody(body);
        this.requestEvent({
            eventId: GameServer.EVENT_SPAWN_OBJECT,
            type: ObjectType.WINDOW,
            position: body.position,
            rotation: body.angle,
            data: body.data
        });
    }

    createFlag(_position, _data)
    {
        var body = new this.p2.Body({
            mass: _data.flagType == GameMode.DOMINATION ? 0 : 10,
            position: _position,
            fixedRotation: true,
            allowSleep: true,
            sleepSpeedLimit: 10
        });
        var captureTime = this.game.settings.fps * 10;
        body.data = {
            id: _data.id ? _data.id : this.getRandomUniqueId(),
            x: body.position[0],
            y: body.position[1],
            type: ObjectType.FLAG,
            num: _data.num,
            flagType: _data.flagType ? _data.flagType : this.game.gameModeId,
            team: _data.team,
            bIsBeingCaptured: false,
            bIsContested: false,
            captureTimer: [
                captureTime,
                captureTime
            ],
            captureTimerMax: captureTime,
            pointTimer: 0,
            pointTimerMax: this.game.settings.fps * 2
        };
        switch (body.data.flagType)
        {
            case GameMode.DOMINATION:
                var flagSize = this.getSharedData("flagCaptureSize");
                body.data.size = flagSize;
                var shape = new this.p2.Circle({
                    radius: Math.round(flagSize * 0.5)
                });
                shape.sensor = true;
                break;
            default:
                flagSize = 50;
                body.data.size = 100;
                shape = new this.p2.Circle({
                    radius: Math.round(flagSize * 0.5),
                    collisionGroup: CollisionGroups.PAWN,
                    collisionMask: CollisionGroups.GROUND | CollisionGroups.BOUNDS
                });                
                break;
        }
        body.addShape(shape);
        this.addWorldBody(body, shape != null);
        this.onEvent({
            eventId: GameServer.EVENT_SPAWN_OBJECT,
            type: ObjectType.FLAG,
            position: body.position,
            data: body.data
        });
        return body;
    }

    createObstacle(_data)
    {
        var shared = this.getSharedData(_data.obstacleId.indexOf("barrel") >= 0 ? "barrel" : _data.obstacleId);
        if (_data.obstacleId == "window")
        {
            shared = {
                mass: 0,
                width: Math.max(20, _data.width ? _data.width : 3),
                height: _data.height ? _data.height : 100
            };
        }
        if (!shared)
        {
            shared = {
                mass: 0,
                fixedRotation: true,
                bNoBody: true
            };
        }
        var useMass = _data.mass != null ? _data.mass : shared.mass;
        var body;
        var angle = _data.angle != null ? _data.angle : (_data.rotation != null ? this.ToRad(_data.rotation) : 0);
        var body = new this.p2.Body({
            mass: useMass,
            damping: shared.damping != null ? shared.damping : 0.95,
            angularDamping: 0.99,
            position: _data.position,
            angle: angle,
            fixedRotation: useMass == 0,
            allowSleep: true,
            sleepSpeedLimit: 10
        });
        var data = {
            id: _data.id ? _data.id : this.getRandomUniqueId(),
            obstacleId: _data.obstacleId,
            spriteId: shared.spriteId,
            scale: _data.scale,
            playerId: _data.playerId,
            type: ObjectType.OBSTACLE,
            width: shared.width,
            height: shared.height,
            items: _data.items,
            bDropItemsWhenDestroyed: true,
            indicatorData: _data.indicatorData,
            mass: useMass,
            damping: body ? body.damping : 0,
            fixedRotation: body ? body.fixedRotation : false,
            tint: _data.tint,
            objectScale: _data.objectScale,
            opacity: _data.opacity,
            bFlashing: _data.bFlashing,
            bNoBody: shared.bNoBody || _data.bNoBody,
            bBlockLOS: true,            
            bSkipServerUpdate: useMass == 0,
            layer: _data.layer,
            loopSfxId: _data.loopSfxId
        };
        switch (_data.obstacleId)
        {
            case "crate":
                data.material = Material.WOOD;
                data.bBlockLOS = false;
                break;
            case "tv":
                data.material = Material.GLASS;
                break;
            case "sofa_1":
            case "sofa_2":
            case "sofa_3":
            case "chair_1":
            case "chair_2":            
                data.bBlockLOS = false;
                data.bIgnoreProjectiles = true;
                break;
            case "cabinet_1":
            case "cabinet_2":
            case "table_large":
            case "table_circle":
                data.health = 200;
                data.material = Material.WOOD;
                data.bBlockLOS = false;
                break;
            case "bed":
            case "target_base":
            case "turret_base":
            case "turret_base_2":
                data.material = Material.WOOD;
                data.bBlockLOS = false;
                data.bIgnoreProjectiles = true;
                break;
            case "deployable_cover":
                data.material = Material.METAL;
                data.health = 1000;
                data.bBlockLOS = false;
                break;
            case "window":
                data.material = Material.GLASS;
                data.health = 1;
                break;
            case "armory":
            case "armory_table":
            case "armory_weapons":
                data.material = Material.WOOD;
                data.health = 250;
                data.bBlockLOS = false;
                break;
            case "logs":
            case "logs_large":
                data.material = Material.WOOD;
                break;
            case "desk":
                data.material = Material.WOOD;
                data.health = 200;
                data.bBlockLOS = false;
                break;
            case "generator":
                data.material = Material.METAL;
                break;
            case "target_dummy":
                data.material = Material.WOOD;
                data.health = 200;
                break;
            case "box":
            case "box_2":
                data.material = Material.WOOD;
                data.health = 1000;
                break;
            case "box_small":
                data.material = Material.WOOD;
                data.health = 500;
                data.bBlockLOS = false;
                break;
            case "barrel_wood":
                data.health = 200;
                data.material = Material.WOOD;
                data.bBlockLOS = false;
                break;
            case "barrel_explosive":
            case "barrel_poison":
            case "barrel_oil":
                data.health = 75;
                data.material = Material.METAL;
                data.damageMultipliers = {
                    1: 1,
                    3: 50
                };
                data.bBlockLOS = false;
                break;
            case "barrel_generic":
                data.health = 1;
                data.material = Material.METAL;
                data.bGodMode = true;
                data.bBlockLOS = false;
                break;
            case "sandbags":
            case "sandbags_large":
            case "sandbags_small":
                data.material = Material.SANDBAG;
                data.damageMultipliers = {
                    1: 0.1
                };                
                data.bBlockLOS = false;
                break;
            case ObjectType.WINDOW:
                data.health = 1;
                data.material = Material.GLASS;
                break;
            default:
                data.material = Material.DEFAULT;
                break;
        }
        if (_data.bBlockLOS != null)
        {
            data.bBlockLOS = _data.bBlockLOS == true;
        }
        if (_data.material)
        {
            data.material = _data.material;
        }
        if (_data.health)
        {
            data.health = _data.health;
        }
        if (_data.bIgnoreProjectiles != null)
        {
            data.bIgnoreProjectiles = _data.bIgnoreProjectiles;
        }
        if (data.health > 0)
        {
            data.maxHealth = data.health;
            data.team = -1;
        }
        if (_data.bGodMode != null)
        {
            data.bGodMode = _data.bGodMode;
        }
        this.optimizeKeys(data);
        if (body)
        {
            body.data = data;
            var group = CollisionGroups.OBJECT;
            if (useMass > 0)
            {
                var mask = CollisionGroups.BOUNDS | CollisionGroups.GROUND | CollisionGroups.PAWN | CollisionGroups.OBJECT | CollisionGroups.FLAME | CollisionGroups.HELICOPTER | CollisionGroups.PROJECTILE;
            }
            else
            {
                mask = CollisionGroups.OBJECT | CollisionGroups.PAWN | CollisionGroups.FLAME | CollisionGroups.HELICOPTER | CollisionGroups.PROJECTILE;
            }             
            if (!data.bNoBody)
            {
                if (data.spriteId)
                {
                    this.loadPolygon(data.spriteId, body, data.width, data.height, 1, {
                        material: new this.p2.Material(),
                        collisionGroup: group,
                        collisionMask: mask
                    });
                }
                else
                {                    
                    if (shared.shape == "circle")
                    {
                        var radius = shared.size ? shared.size : shared.width;
                        if (radius < this.game.nodeThreshold)
                        {
                            var shape = new this.p2.Circle({
                                radius: this.game.nodeThreshold,
                                collisionMask: 0
                            });
                            shape.sensor = true;
                            body.addShape(shape);
                        }
                        body.addShape(new this.p2.Circle({
                            radius: radius,
                            collisionGroup: group,
                            collisionMask: mask
                        }));
                    }
                    else
                    {
                        if (shared.width < this.game.nodeThreshold)
                        {
                            var shape = new this.p2.Box({
                                width: this.game.nodeThreshold,
                                height: Math.max(shared.height, this.game.nodeThreshold),
                                collisionMask: 0
                            });
                            shape.sensor = true;
                            body.addShape(shape);
                        }
                        else if (shared.height < this.game.nodeThreshold)
                        {
                            var shape = new this.p2.Box({
                                width: Math.max(shared.width, this.game.nodeThreshold),
                                height: this.game.nodeThreshold,
                                collisionMask: 0
                            });
                            shape.sensor = true;
                            body.addShape(shape);
                        }
                        body.addShape(new this.p2.Box({
                            width: shared.width,
                            height: shared.height,
                            collisionGroup: group,
                            collisionMask: mask
                        }));
                    }
                }
            }
            this.addWorldBody(body, !data.bNoBody);
            this.addDirtyNodeObject(body);
        }
        this.requestEvent({
            eventId: GameServer.EVENT_SPAWN_OBJECT,
            type: ObjectType.OBSTACLE,
            position: _data.position,
            rotation: angle,
            data: data
        });        
        return body;
    }

    createTriggerArea(_data)
    {
        var body = new this.p2.Body({
            mass: 0,
            fixedRotation: true,
            position: _data.position,
            angle: _data.rotation != null ? this.ToRad(_data.rotation) : 0,
            allowSleep: true
        });
        body.data = {
            id: _data.id ? _data.id : this.getRandomUniqueId(),
            type: ObjectType.TRIGGER_AREA,
            team: _data.team,
            icon: _data.icon,
            areaWidth: _data.width ? _data.width : 150,
            areaHeight: _data.height ? _data.height : 150,
            onTouchTriggerId: _data.onTouchTriggerId,
            targetId: _data.targetId,
            targetTeam: _data.targetTeam,
            targetType: _data.targetType,
            indicatorData: _data.indicatorData,
            uses: _data.uses != null ? _data.uses : 1,
            bHidden: _data.bHidden,
            bBotsCanTrigger: _data.bBotsCanTrigger,
            attachToId: _data.attachToId,
            bSkipServerUpdate: _data.bHidden == true,
            ticker: 1
        };
        var data = body.data;
        var shape = new this.p2.Box({
            width: data.areaWidth,
            height: data.areaHeight,
            collisionGroup: CollisionGroups.OBJECT,
            collisionMask: 0
        });
        shape.sensor = true;
        body.addShape(shape);
        this.addWorldBody(body);
        this.requestEvent({
            eventId: GameServer.EVENT_SPAWN_OBJECT,
            type: data.type,
            position: _data.position,
            rotation: _data.rotation,
            data: data
        });
        return body;
    }

    createTree(_data)
    {
        var angle = _data.angle ? _data.angle : (_data.rotation ? this.ToRad(_data.rotation) : 0);
        var body;
        body = new this.p2.Body({
            mass: 0,
            fixedRotation: true,
            position: _data.position,
            angle: angle,
            allowSleep: true
        });
        var data = {
            id: _data.id ? _data.id : this.getRandomUniqueId(),
            type: ObjectType.TREE,
            treeType: _data.treeType,
            bBack: _data.bBack,
            bSkipServerUpdate: true
        };
        body.data = data;
        this.addWorldBody(body, false);
        this.requestEvent({
            eventId: GameServer.EVENT_SPAWN_OBJECT,
            type: ObjectType.TREE,
            position: _data.position,
            rotation: angle,
            data: data
        });
    }

    createEmitter(_data)
    {
        var angle = _data.angle ? _data.angle : (_data.rotation ? this.ToRad(_data.rotation) : 0);
        var body;
        body = new this.p2.Body({
            mass: 0,
            fixedRotation: true,
            position: _data.position ? _data.position : [0, 0],
            angle: angle,
            allowSleep: true
        });
        var data = {
            id: _data.id ? _data.id : this.getRandomUniqueId(),
            type: ObjectType.EMITTER,
            team: _data.team,
            layer: _data.layer,
            frame: _data.frame,
            lifespan: _data.lifespan,
            frequency: _data.frequency,
            maxParticles: _data.maxParticles,
            particleTint: _data.particleTint,
            gravityX: _data.gravityX,
            gravityY: _data.gravityY,
            speedMinX: _data.speedMinX,
            speedMaxX: _data.speedMaxX,
            speedMinY: _data.speedMinY,
            speedMaxY: _data.speedMaxY,
            minParticleScale: _data.minParticleScale,
            maxParticleScale: _data.maxParticleScale,
            destroyTimer: _data.destroyTimer ? (_data.destroyTimer * 60) : null,
            attachToId: _data.attachToId,
            opacity: _data.opacity,
            bHideWhenPerformanceMode: _data.bHideWhenPerformanceMode,
            loopSfxId: _data.loopSfxId
        };
        this.optimizeKeys(data);
        body.data = data;
        this.addWorldBody(body, false);
        this.requestEvent({
            eventId: GameServer.EVENT_SPAWN_OBJECT,
            type: ObjectType.EMITTER,
            position: _data.position,
            rotation: angle,
            data: data
        });
        return body;
    }

    createIcon(_data)
    {
        var angle = _data.angle ? _data.angle : (_data.rotation ? this.ToRad(_data.rotation) : 0);
        var body;
        body = new this.p2.Body({
            mass: 0,
            fixedRotation: true,
            position: _data.position,
            angle: angle,
            allowSleep: true
        });
        var data = {
            id: _data.id ? _data.id : this.getRandomUniqueId(),
            type: ObjectType.ICON,
            atlas: _data.atlas,
            key: _data.key,
            tint: _data.tint,
            opacity: _data.opacity,
            layer: _data.layer,
            bSkipServerUpdate: true
        };
        this.optimizeKeys(data);
        body.data = data;
        this.addWorldBody(body, false);
        this.requestEvent({
            eventId: GameServer.EVENT_SPAWN_OBJECT,
            type: ObjectType.ICON,
            position: _data.position,
            rotation: angle,
            data: data
        });
        return body;
    }

    createText(_data)
    {
        var angle = _data.angle ? _data.angle : (_data.rotation ? this.ToRad(_data.rotation) : 0);
        var body;
        body = new this.p2.Body({
            mass: 0,
            fixedRotation: true,
            position: _data.position,
            angle: angle,
            allowSleep: true
        });
        var data = {
            id: _data.id ? _data.id : this.getRandomUniqueId(),
            type: ObjectType.TEXT,
            text: _data.text,
            fill: _data.fill,
            font: _data.font,
            fontSize: _data.fontSize,
            opacity: _data.opacity,
            bTextShadow: _data.bTextShadow,
            glowFill: _data.glowFill,
            layer: _data.layer,
            bSkipServerUpdate: true
        };
        this.optimizeKeys(data);
        body.data = data;
        this.addWorldBody(body, false);
        this.requestEvent({
            eventId: GameServer.EVENT_SPAWN_OBJECT,
            type: ObjectType.TEXT,
            position: _data.position,
            rotation: angle,
            data: data
        });
        return body;
    }

    createDummy(_data)
    {
        var shared = this.getSharedData("target_dummy");
        var body = new this.p2.Body({
            mass: shared.mass,
            damping: 0.9,
            angularDamping: 0.9,
            position: _data.position,
            angle: _data.angle ? _data.angle : (_data.rotation ? this.ToRad(_data.rotation) : 0),
            allowSleep: true,
            sleepSpeedLimit: 1
        });
        body.data = {
            id: _data.id ? _data.id : this.getRandomUniqueId(),
            type: ObjectType.DUMMY,
            material: Material.WOOD,
            indicatorData: _data.indicatorData,
            damageMultipliers: _data.damageMultipliers,
            health: 200,
            reward: 25,
            width: shared.width,
            height: shared.height,
            damping: body.damping,
            angularDamping: body.angularDamping,
            bUntargetable: _data.bUntargetable
        };
        var data = body.data;
        this.optimizeKeys(data);
        data.maxHealth = data.health;
        var shape = new this.p2.Circle({
            radius: shared.size ? shared.size : shared.width,
            collisionGroup: CollisionGroups.OBJECT,
            collisionMask: CollisionGroups.GROUND | CollisionGroups.PAWN | CollisionGroups.PROJECTILE | CollisionGroups.HELICOPTER | CollisionGroups.OBJECT
        });
        body.addShape(shape);
        this.addWorldBody(body);
        this.requestEvent({
            eventId: GameServer.EVENT_SPAWN_OBJECT,
            type: data.type,
            position: body.position,
            rotation: body.angle,
            data: data
        });
        return body;
    }

    createLever(_position, _data)
    {
        var shared = this.getSharedData(ObjectType.LEVER);
        var body = new this.p2.Body({
            mass: 0,
            angle: _data.angle != null ? _data.angle : (_data.rotation != null ? this.ToRad(_data.rotation) : 0),
            position: _position,
            allowSleep: true,
            sleepSpeedLimit: 10
        });
        body.data = {
            id: _data.id ? _data.id : this.getRandomUniqueId(),
            type: ObjectType.LEVER,
            leverType: _data.leverType,
            targetId: _data.targetId,
            triggerId: _data.triggerId,
            bDisabled: _data.bDisabled,
            indicatorData: _data.indicatorData,
            glowTint: _data.glowTint,
            tint: _data.tint != null ? _data.tint : null,
            bHidden: _data.bHidden,
            itemData: _data.itemData
        };
        this.optimizeKeys(body.data);
        var shape = new this.p2.Circle({
            radius: shared.size ? shared.size : shared.width,
            collisionGroup: CollisionGroups.PAWN,
            collisionMask: CollisionGroups.GROUND | CollisionGroups.PROJECTILE | CollisionGroups.OBJECT
        });
        body.addShape(shape);
        this.addWorldBody(body);
        this.onEvent({
            eventId: GameServer.EVENT_SPAWN_OBJECT,
            type: ObjectType.LEVER,
            position: body.position,
            rotation: body.angle,
            data: body.data
        });
        return body;
    }

    startCharacterShieldCooldown(_body)
    {
        if (_body && _body.data)
        {
            var data = _body.data;
            this.cancelCharacterBoltPull(_body);
            this.cancelCharacterReload(_body);            
            data.bShieldCooldown = true;
            data.shieldCooldownTimer = Math.ceil(this.game.settings.fps * 0.3);
            data.bDoorCooldown = true;
            this.requestEvent({
                eventId: GameServer.EVENT_PAWN_ACTION,
                pawnId: data.id,
                type: GameServer.PAWN_START_SHIELD_COOLDOWN,
                bDoor: true
            });
        }
    }

    createCrate(_position, _data)
    {
        var shared = this.getSharedData(_data.frame ? _data.frame : ObjectType.CRATE);
        if (!shared)
        {
            console.warn("Invalid crate shared data");
            return;
        }
        var useMass = _data.mass != null ? _data.mass : (shared.mass ? shared.mass : 1);
        var body = new this.p2.Body({
            mass: useMass,
            damping: 0.99,
            angularDamping: 0.99,
            position: _position,
            angle: _data.angle ? _data.angle : (_data.rotation ? this.ToRad(_data.rotation) : 0),
            allowSleep: true,
            sleepSpeedLimit: 10
        });
        body.data = {
            id: _data.id ? _data.id : this.getRandomUniqueId(),
            type: ObjectType.CRATE,
            itemData: _data.itemData ? _data.itemData : {},
            team: _data.team,
            crateType: _data.crateType,
            items: _data.items,
            itemId: _data.itemId,
            ownerId: _data.ownerId,
            bDisabled: _data.bDisabled,
            destroyTimer: _data.destroyTimer != null ? (_data.destroyTimer * this.game.settings.fps) : null,
            bLimitInteractions: _data.bLimitInteractions,
            bDisposable: _data.bDisposable != null ? _data.bDisposable : true,
            mass: useMass,
            indicatorData: _data.indicatorData,
            opacity: _data.opacity,
            bDisableStoreInventory: _data.bDisableStoreInventory,
            bDisableStoreSupportItems: _data.bDisableStoreSupportItems
        };
        var data = body.data;
        this.optimizeKeys(data);
        switch (data.crateType)
        {
            case Crate.BOMB:
            case Crate.BOMB_GENERIC:                
                data.bombNum = _data.num;
                data.bombTimerMax = data.bombTimer = this.game.settings.fps * (_data.bombTimerMax ? _data.bombTimerMax : 60);
                data.bDisposable = false;
                data.itemData = {
                    interactTime: this.game.settings.fps * 3,
                    interactTeam: i == 0 ? 1 : 0
                };
                break;
            case Crate.AMMO:
                data.itemData = {
                    uses: 5,
                    maxUses: 5,
                    interactTime: this.game.settings.fps * 1
                };
                break;
            case Crate.OBJECTIVE:
                data.itemData = {
                    uses: 1,
                    maxUses: 1,
                    interactTime: this.game.settings.fps * 3
                };
                break;
            case Crate.ITEM:
            case Crate.WEAPON:
                data.itemData = {
                    uses: 1,
                    maxUses: 1,
                    interactTime: this.game.settings.fps * 0.5
                };
                break;
        }
        if (_data.itemData)
        {
            var keys = Object.keys(_data.itemData);
            for (var i = 0; i < keys.length; i++)
            {
                var key = keys[i];
                data.itemData[key] = _data.itemData[key];
            }
        }
        if (data.bDisposable && !data.destroyTimer)
        {
            data.destroyTimer = this.game.settings.fps * 180;            
        }
        if (data.destroyTimer)
        {
            data.destroyTimerMax = data.destroyTimer;
        }
        var shape = new this.p2.Box({
            width: shared.width,
            height: shared.height,
            collisionGroup: CollisionGroups.OBJECT,
            collisionMask: CollisionGroups.GROUND | CollisionGroups.PAWN | CollisionGroups.OBJECT
        });
        body.addShape(shape);
        if (useMass == 0)
        {
            shape = new this.p2.Circle({
                radius: this.game.nodeThreshold
            });
            body.addShape(shape);
        }
        this.addWorldBody(body);
        this.onEvent({
            eventId: GameServer.EVENT_SPAWN_OBJECT,
            type: ObjectType.CRATE,
            position: body.position,
            rotation: body.angle,
            data: body.data
        });
        var crates = this.getDisposableCrates();
        if (crates.length > this.settings.maxCrates)
        {
            this.removeNextStep(crates[0]);
        }
        return body;
    }

    createGrenade(_position, _data)
    {
        var body = new this.p2.Body({
            mass: 1,
            position: _position,
            angle: _data.angle ? _data.angle : 0,
            damping: _data.bImpact ? 0 : 0.6,
            angularDamping: 0.5,
            allowSleep: true,
            sleepSpeedLimit: 10
        });
        var causer = this.getObjectById(_data.causerId);
        var weaponData = _data.weaponData ? _data.weaponData : this.getWeaponData(_data.weaponId);
        var bRemoteDetonation = weaponData ? weaponData.bRemoteDetonation : false;
        body.data = {
            id: _data.id ? _data.id : this.getRandomUniqueId(),
            type: ObjectType.GRENADE,
            team: _data.team,
            damage: _data.damage ? _data.damage : weaponData.damage,
            radius: _data.radius ? _data.radius : weaponData.radius,
            causerId: _data.causerId,
            playerId: _data.playerId,
            weaponId: _data.weaponId,
            modId: _data.modId,
            bDetonationTimerEnabled: true,
            detonationTimer: (weaponData ? weaponData.detonationTimer : this.game.settings.fps) * this.game.fpsMult,
            bRemoteDetonation: bRemoteDetonation,
            bStartDetonationAfterHit: _data.bStartDetonationAfterHit,
            bAutomated: causer ? causer.data.bAutomated : false,
            bImpact: _data.bImpact,
            lifespan: 0
        };
        var data = body.data;
        switch (weaponData.id)
        {
            case "semtex":
                break;
            default:
                data.minTimer = Math.round(3 * this.game.fpsMult);
                break;
        }
        var shared = this.getSharedData(ObjectType.GRENADE);
        if (bRemoteDetonation)
        {
            var mask = CollisionGroups.GROUND | CollisionGroups.OBJECT | CollisionGroups.HELICOPTER | CollisionGroups.BOUNDS;
        }
        else
        {
            mask = CollisionGroups.GROUND | CollisionGroups.PAWN | CollisionGroups.OBJECT | CollisionGroups.HELICOPTER | CollisionGroups.BOUNDS
        }
        if (bRemoteDetonation)
        {
            data.bDetonationTimerEnabled = false;
            body.allowSleep = false;
            body.data.health = 1;
            var shape = new this.p2.Circle({
                collisionGroup: CollisionGroups.PROJECTILE,
                collisionMask: mask,
                radius: shared.width
            });
        }
        else
        {
            shape = new this.p2.Circle({
                collisionGroup: CollisionGroups.PROJECTILE,
                collisionMask: mask,
                radius: shared.width
            });
        }
        if (_data.bImpact)
        {
            shape.sensor = true;
        }        
        body.addShape(shape);
        this.addWorldBody(body);

        var rad = _data.rotation;
        var speed = _data.velocity;
        body.angularVelocity = (speed * 0.01);
        body.applyImpulse([Math.cos(rad) * speed, Math.sin(rad) * speed], 0, 0);

        this.requestEvent({
            eventId: GameServer.EVENT_SPAWN_OBJECT,
            type: ObjectType.GRENADE,
            rotation: body.angle,
            position: body.position,
            velocity: body.velocity,
            angularVelocity: body.angularVelocity,
            data: body.data
        });

        return body;
    }

    getCharacterMaxHealth()
    {
        return this.game.gameModeData.bHardcore ? 100 : 200;
    }

    createPolygon(_data)
    {
        if (_data.spriteId)
        {
            var shared = this.getSharedData(_data.spriteId);
            if (!shared)
            {
                console.warn("Unhandled sprite", _data.spriteId); 
                return;
            }
        }
        else
        {
            shared = {
                shape: _data.shape,
                width: _data.width,
                height: _data.height,
                radius: _data.radius
            }
        }
        var useWidth = _data.width ? _data.width : shared.width;
        var useHeight = _data.height ? _data.height : shared.height;
        var body = new this.p2.Body({
            mass: 0,
            damping: 1,
            position: _data.position,
            angle: _data.angle ? _data.angle : (_data.rotation ? this.ToRad(_data.rotation) : 0),
            allowSleep: true,
            sleepSpeedLimit: 1
        });
        if (!_data.bNoBody)
        {            
            if (_data.shape == "box")
            {
                var shape = new this.p2.Box({
                    width: _data.width,
                    height: _data.height,
                    collisionGroup: CollisionGroups.GROUND,
                    collisionMask: CollisionGroups.PAWN | CollisionGroups.PROJECTILE | CollisionGroups.HELICOPTER | CollisionGroups.OBJECT | CollisionGroups.FLAME
                });
                body.addShape(shape);
                if (_data.width < this.game.nodeThreshold)
                {
                    var shape = new this.p2.Box({
                        width: this.game.nodeThreshold,
                        height: Math.max(_data.height, this.game.nodeThreshold),
                        collisionMask: 0
                    });
                    shape.sensor = true;
                    body.addShape(shape);
                }
                else if (_data.height < this.game.nodeThreshold)
                {
                    var shape = new this.p2.Box({
                        width: Math.max(_data.width, this.game.nodeThreshold),
                        height: this.game.nodeThreshold,
                        collisionMask: 0
                    });
                    shape.sensor = true;
                    body.addShape(shape);
                }
            }
            else if (_data.shape == "circle")
            {
                shape = new this.p2.Circle({
                    radius: _data.radius,
                    collisionGroup: CollisionGroups.GROUND,
                    collisionMask: CollisionGroups.PAWN | CollisionGroups.PROJECTILE | CollisionGroups.HELICOPTER | CollisionGroups.OBJECT | CollisionGroups.FLAME
                });
                body.addShape(shape);
            }
            else if (_data.spriteId)
            {
                this.loadPolygon(_data.spriteId, body, useWidth, useHeight, _data.scale ? _data.scale : 1, {
                    material: new this.p2.Material(),
                    collisionGroup: CollisionGroups.GROUND,
                    collisionMask: CollisionGroups.PAWN | CollisionGroups.PROJECTILE | CollisionGroups.HELICOPTER | CollisionGroups.OBJECT | CollisionGroups.FLAME
                });
            }
        }
        body.data = {
            id: _data.id ? _data.id : this.getRandomUniqueId(),
            type: ObjectType.GROUND,
            material: _data.material,
            spriteId: _data.spriteId,
            texture: _data.texture,
            textureScale: _data.textureScale,
            opacity: _data.opacity,
            shape: _data.shape,
            width: useWidth,
            height: useHeight,
            radius: _data.radius,
            scale: _data.scale,
            bNoBody: _data.bNoBody,
            tint: _data.tint,
            layer: _data.layer,
            bHideOutline: _data.bHideOutline,
            bIgnoreProjectiles: _data.bIgnoreProjectiles, 
            bRoof: _data.bRoof,
            roofOpacity: _data.roofOpacity,
            bSkipServerUpdate: true
        };        
        var data = body.data;
        this.optimizeKeys(data);
        this.addWorldBody(body, !data.bNoBody);
        this.onEvent({
            eventId: GameServer.EVENT_SPAWN_OBJECT,
            position: body.position,
            rotation: body.angle,
            data: data
        });
        this.addDirtyNodeObject(body);
        return body;
    }

    createDinosaur(_data)
    {
        var shared = this.getSharedData(_data.dinoType);
        if (!shared)
        {
            console.warn("Invalid dinoType", _data.dinoType);
            shared = {
                mass: 1,
                width: 30,
                height: 30
            };
        }
        var useMass = shared.mass != null ? shared.mass : 1;
        var body = new this.p2.Body({
            mass: useMass,
            damping: shared.damping != null ? shared.damping : 0.99,
            angularDamping: 0.95,
            position: _data.position ? _data.position : [_data.x, _data.y],
            allowSleep: _data.bBot == true,
            sleepSpeedLimit: 1
        });
        var objectType = ObjectType.DINOSAUR;
        switch (_data.dinoType)
        {
            case Dinosaur.PTERODACTYL:
                objectType = ObjectType.FLYING_DINOSAUR;
                var shape = new this.p2.Circle({
                    radius: shared.size ? shared.size : shared.width,
                    collisionGroup: CollisionGroups.HELICOPTER,
                    collisionMask: CollisionGroups.HELICOPTER | CollisionGroups.PROJECTILE
                });
                break;
            case Dinosaur.CHICKEN:
            case Dinosaur.LIZARD:
                shape = new this.p2.Circle({
                    radius: shared.width,
                    collisionGroup: CollisionGroups.PAWN,
                    collisionMask: CollisionGroups.BOUNDS | CollisionGroups.PAWN | CollisionGroups.GROUND | CollisionGroups.PROJECTILE | CollisionGroups.OBJECT
                });
                break;
            default:
                shape = new this.p2.Box({
                    width: shared.width,
                    height: shared.height,
                    collisionGroup: CollisionGroups.PAWN,
                    collisionMask: CollisionGroups.BOUNDS | CollisionGroups.PAWN | CollisionGroups.GROUND | CollisionGroups.PROJECTILE | CollisionGroups.OBJECT
                });
                break;
        }        
        body.addShape(shape);
        body.data = {
            id: _data.id ? _data.id : this.getRandomUniqueId(),
            type: objectType,
            material: Material.FLESH,
            team: _data.team,
            health: 100,
            dinoType: _data.dinoType,
            lungeMult: 2,
            aimRotation: this.RandomAngle(),
            desiredAimRotation: this.RandomAngle(),
            lookPos: [body.position[0] + this.Random(-100, 100), body.position[1] + this.Random(-100, 100)],
            maxSpeed: shared.maxSpeed ? shared.maxSpeed : 300,
            speedMultiplier: _data.speedMultiplier ? Math.max(0, Math.min(_data.speedMultiplier, 40)) : 1,
            baseSpeedMultiplier: 1,
            reloadMultiplier: 1,
            bRegenHealth: _data.bRegenHealth != null ? _data.bRegenHealth : true,
            regenTimerMax: 180 * this.game.fpsMult,
            regenTimer: 0,
            bGodMode: _data.bGodMode,
            bHideHealthBar: _data.bHideHealthBar,
            bIgnoreOutOfSight: _data.bIgnoreOutOfSight,
            bIgnoreEnemies: _data.bIgnoreEnemies,
            bInvestigate: _data.bInvestigate != false,
            bBot: _data.bBot,
            bUntargetable: _data.bUntargetable,
            bCanInteract: _data.bCanInteract,
            botSkill: _data.botSkill >= 0 ? _data.botSkill : BotSkill.SKILL_EASY,
            playerId: _data.playerId,
            weapon: {
                fireDelayTimer: 0,
                burstTimer: 0,
                recoil: 0,
                bUnlimitedAmmo: true
            },
            damageMultipliers: {
                1: 1,
                2: 1,
                3: this.game.bSurvival ? 1.5 : 2,
                4: this.game.bSurvival ? 1 : 0.75
            },
            pawnName: _data.pawnName,
            indicatorData: _data.indicatorData,
            objectScale: _data.objectScale,
            maxRange: _data.maxRange,
            colour: _data.colour,
            bHostage: _data.bHostage,
            items: _data.items,
            attackDamageMultiplier: _data.attackDamageMultiplier
        };
        var data = body.data;
        this.optimizeKeys(data);
        var weapon = this.getWeaponData(data.dinoType);
        if (!weapon)
        {
            weapon = this.getWeaponData(Dinosaur.COMPY);
        }
        if (data.attackDamageMultiplier != null)
        {
            weapon.damage *= data.attackDamageMultiplier;
        }
        data.inventory = [
            weapon
        ];
        data.bCanLunge = weapon.range < 200;
        data.lungeMult = data.maxSpeed >= 500 ? 1.6 : 2;
        switch (data.dinoType)
        {
            case Dinosaur.PTERODACTYL:
                data.bCanLunge = true;
                data.health = 400;
                data.reward = 100;
                data.damageMultipliers[DamageType.DAMAGE_EXPLOSIVE] = 0.75;
                data.damageMultipliers[DamageType.DAMAGE_FIRE] = 0.75;
                break;
            case Dinosaur.CHICKEN:
                data.health = 100;
                data.reward = 50;
                break;
            case Dinosaur.LIZARD:
                data.bCanLunge = false;
                data.health = 100;
                data.reward = 5;
                break;
            case Dinosaur.COMPY:
                data.bCanLunge = false;
                data.health = 250;
                data.reward = 50;
                if (this.game.bSurvival)
                {
                    data.health = 200;
                    data.maxSpeed = 600;
                }
                break;
            case Dinosaur.DILO:
                data.health = 250;
                data.reward = 100;
                if (this.game.bSurvival)
                {
                    data.health = 300;
                    data.maxSpeed = 600;
                }
                break;
            case Dinosaur.RAPTOR:
                data.lungeMult = 2;
                data.health = 500;
                data.reward = this.game.bSurvival ? 400 : 200;
                if (this.game.bSurvival)
                {
                    weapon.damage *= 2;
                    data.health = 750;
                    data.maxSpeed = data.team == 0 ? 600 : 800;
                }
                break;
            case Dinosaur.PACHY:
                data.lungeMult = 3;
                data.health = 500;
                data.reward = 200;
                data.damageMultipliers[DamageType.DAMAGE_BULLET] = 0.75;
                data.damageMultipliers[DamageType.DAMAGE_MELEE] = 0.75;
                if (this.game.bSurvival)
                {
                    data.health = 1000;
                    data.maxSpeed = 500;
                }
                break;
            case Dinosaur.NEEDLER:
                data.health = 250;
                data.reward = this.game.bSurvival ? 500 : 250;
                if (this.game.bSurvival)
                {
                    data.health = 250;
                    data.maxSpeed = 400;
                }
                break;
            case Dinosaur.CARNOTAURUS:
                data.lungeMult = 2.8;
                data.health = 1250;
                data.reward = this.game.bSurvival ? 1000 : 500;
                data.damageMultipliers[DamageType.DAMAGE_MELEE] = 0.5;
                if (this.game.bSurvival)
                {
                    data.damageMultipliers[DamageType.DAMAGE_BULLET] = 0.5;
                    weapon.damage *= 2;
                    data.health = 2000;
                }
                break;
            case Dinosaur.ALLOSAURUS:
                data.health = 1500;
                data.reward = this.game.bSurvival ? 1000 : 500;
                data.damageMultipliers[DamageType.DAMAGE_MELEE] = 0.5;
                if (this.game.bSurvival)
                {
                    data.damageMultipliers[DamageType.DAMAGE_BULLET] = 0.5;
                    weapon.damage *= 2;
                    data.health = 3000;
                }
                break;
            case Dinosaur.SPINOSAURUS:
                data.health = 2000;
                data.reward = this.game.bSurvival ? 1500 : 500;
                data.damageMultipliers[DamageType.DAMAGE_MELEE] = 0.5;
                if (this.game.bSurvival)
                {
                    data.damageMultipliers[DamageType.DAMAGE_BULLET] = 0.5;
                    weapon.damage *= 2;
                    data.health = 4000;
                }
                break;
            case Dinosaur.TREX:
                data.health = 10000;
                data.reward = 5000;
                data.damageMultipliers[DamageType.DAMAGE_BULLET] = 0.25;
                data.damageMultipliers[DamageType.DAMAGE_EXPLOSIVE] = 1.25;
                data.damageMultipliers[DamageType.DAMAGE_MELEE] = 0.25;
                data.damageMultipliers[DamageType.DAMAGE_FIRE] = 0.25;
                if (this.game.bSurvival)
                {
                    weapon.damage *= 2;
                    data.maxSpeed = 325;
                    data.bImmuneToStun = true;
                    data.damageMultipliers[DamageType.DAMAGE_BULLET] = 0.1;
                }
                break;
            case Dinosaur.STEGOSAURUS:
                data.health = 1500;
                data.reward = this.game.bSurvival ? 1000 : 500;
                data.damageMultipliers[DamageType.DAMAGE_BULLET] = 0.5;
                data.damageMultipliers[DamageType.DAMAGE_MELEE] = 0.5;
                data.damageMultipliers[DamageType.DAMAGE_FIRE] = 0.5;
                if (this.game.bSurvival)
                {
                    data.health = 2000;
                    data.damageMultipliers[DamageType.DAMAGE_BULLET] = 0.25;
                    data.maxSpeed = 200;
                }
                break;
            case Dinosaur.ANKYLOSAURUS:
                data.health = 1000;
                data.reward = this.game.bSurvival ? 400 : 200;
                data.damageMultipliers[DamageType.DAMAGE_BULLET] = 0.5;
                data.damageMultipliers[DamageType.DAMAGE_MELEE] = 0.5;
                data.damageMultipliers[DamageType.DAMAGE_FIRE] = 0.5;
                data.damageMultipliers[DamageType.DAMAGE_EXPLOSIVE] = 0.5;
                if (this.game.bSurvival)
                {
                    data.health = 1250;
                    data.damageMultipliers[DamageType.DAMAGE_BULLET] = 0.25;
                    data.damageMultipliers[DamageType.DAMAGE_EXPLOSIVE] = 0.25;
                }
                break;
        }
        data.maxSpeed = Math.round(data.maxSpeed * data.speedMultiplier);
        if (_data.damageMultipliers)
        {
            this.applyDamageMultipliers(data.damageMultipliers, _data.damageMultipliers);
        }
        this.setCharacterCurrentInventoryItem(body, 0);
        data.regenAmount = Math.ceil(data.maxHealth * 0.005);
        if (this.game.gameModeData.bHardcore)
        {
            data.health = Math.max(200, Math.round(data.health * 0.5));
        }
        if (data.bBot && !this.game.bSurvival)
        {
            data.maxSpeed = data.maxSpeed * Math.min(1, Math.max(0.75, ((data.botSkill + 1) / BotSkill.SKILL_INSANE)));
        }
        if (_data.speedMult)
        {
            console.warn("Deprecated");
            //data.maxSpeed = Math.round(data.maxSpeed * _data.speedMult);
        }
        if (_data.healthMultiplier)
        {
            data.health = data.maxHealth = Math.round(data.health * _data.healthMultiplier);
        }
        if (_data.bSavage)
        {
            data.bSavage = true;
            data.maxSpeed = Math.floor(data.maxSpeed * 1.1);
            data.health = Math.max(data.health * 1.25, 1000);
            data.reward *= 3;
            data.colour = 0xFF0000;
            var dinoWpn = data.inventory[0];
            if (dinoWpn)
            {
                dinoWpn.fireRate = Math.ceil(dinoWpn.fireRate * 0.5);
                switch (data.dinoType)
                {
                    case Dinosaur.PTERODACTYL:
                        dinoWpn.damage = Math.round(dinoWpn.damage * 2);
                        break;
                }
            }
        }
        if (_data.health)
        {
            data.health = _data.health;
        }
        data.maxHealth = data.health;        
        this.addWorldBody(body);
        if (data.bBot)
        {
            this.initPawnAI(body, data.botSkill);
            if (_data.wanderArea)
            {
                this.setAIWanderArea(body, _data.wanderArea);
            }
            if (_data.investigatePosition)
            {
                this.setAIInvestigatePos(body, _data.investigatePosition);
            }
            if (_data.followTargetId)
            {
                this.setAIFollowTargetId(body, _data.followTargetId);
            }
        }
        var ps = this.getPlayerById(data.id);
        if (ps && this.game.gameSettings.playerDamageMultipliers)
        {
            if (!data.damageMultipliers)
            {
                data.damageMultipliers = {};
            }
            this.applyDamageMultipliers(data.damageMultipliers, this.game.gameSettings.playerDamageMultipliers);
        }
        this.onEvent({
            eventId: GameServer.EVENT_SPAWN_OBJECT,
            position: body.position,
            rotation: body.angle,
            data: body.data
        });
        return body;
    }

    applyDamageMultipliers(_target, _mults)
    {
        if (_target && _mults)
        {
            var keys = Object.keys(_mults);
            for (var i = 0; i < keys.length; i++)
            {
                let key = keys[i];
                if (_mults[key] != null)
                {
                    if (_target[key] != null)
                    {
                        _target[key] *= _mults[key];
                    }
                    else
                    {
                        //_target[key] = _mults[key];
                    }
                }
            }
        }
    }

    createCharacter(_data)
    {
        var shared = this.getSharedData(ObjectType.CHARACTER);
        var body = new this.p2.Body({
            mass: _data.mass != null ? _data.mass : 1,
            fixedRotation: shared.fixedRotation,
            damping: shared.damping,
            position: _data.position ? _data.position : [_data.x, _data.y],
            allowSleep: _data.bBot == true,
            sleepSpeedLimit: 1
        });
        var shape = new this.p2.Circle({
            radius: shared.width,
            collisionGroup: CollisionGroups.PAWN,
            collisionMask: CollisionGroups.BOUNDS | CollisionGroups.GROUND | CollisionGroups.PROJECTILE | CollisionGroups.OBJECT | CollisionGroups.PAWN
        });
        body.addShape(shape);

        if (_data.avatarId)
        {
            _data.avatar = this.getAvatarDataById(_data.avatarId);
        }
        if (!_data.avatar)
        {
            _data.avatar = this.getAvatarDataById(AvatarPresets.DINOGEN);
        }
        body.data = {
            id: _data.id ? _data.id : this.getRandomUniqueId(),
            type: ObjectType.CHARACTER,
            material: _data.bJuggernaut ? Material.METAL : Material.FLESH,
            team: _data.team,
            health: _data.health ? _data.health : this.getCharacterMaxHealth(),
            aimRotation: _data.angle ? _data.angle : (_data.rotation ? this.ToRad(_data.rotation) : 0),
            desiredAimRotation: 0,
            lookPos: this.clone(body.position),
            maxSpeed: _data.maxSpeed ? _data.maxSpeed : shared.maxSpeed,
            reloadMultiplier: 1,
            speedMultiplier: 1,
            baseSpeedMultiplier: _data.speedMultiplier != null ? Math.max(0, Math.min(_data.speedMultiplier, 40)) : 1,
            bRegenHealth: _data.bRegenHealth != null ? _data.bRegenHealth : true,
            regenThreshold: _data.regenThreshold,
            regenTimerMax: 180 * this.game.fpsMult,
            regenTimer: 0,
            weapon: {
                fireDelayTimer: 0,
                burstTimer: 0,
                recoil: 0
            },
            bGodMode: _data.bGodMode,
            bHideHealthBar: _data.bHideHealthBar,
            bIgnoreOutOfSight: _data.bIgnoreOutOfSight,
            bIgnoreEnemies: _data.bIgnoreEnemies,
            bInvestigate: _data.bInvestigate != false,
            bBot: _data.bBot,
            botSkill: _data.botSkill,
            bUntargetable: _data.bUntargetable,
            bJuggernaut: _data.bJuggernaut,
            bZombie: _data.bZombie,
            avatar: _data.avatar,
            legScale: _data.legScale,
            pawnName: _data.pawnName,
            indicatorData: _data.indicatorData,
            bDropWeapons: _data.bDropWeapons,
            bDropAllWeapons: _data.bDropAllWeapons,
            objectScale: _data.objectScale,
            reward: _data.reward != null ? _data.reward : null,
            bSwitchToMelee: _data.bSwitchToMelee,
            maxRange: _data.maxRange,
            bCanInteract: _data.bCanInteract != null ? _data.bCanInteract : true,
            bHostage: _data.bHostage,
            items: _data.items,
            destroyTimer: _data.destroyTimer != null ? _data.destoyTimer * this.game.settings.fps : null
        };
        var data = body.data;
        this.optimizeKeys(data);
        data.desiredAimRotation = data.aimRotation;
        data.lookPos[0] += Math.cos(data.aimRotation) * 100;
        data.lookPos[1] += Math.sin(data.aimRotation) * 100;
        data.maxHealth = data.health;
        data.weapon.bUnlimitedAmmo = this.game.gameModeData.bUnlimitedAmmo || _data.bUnlimitedAmmo;
        if (_data.inventory)
        {
            if (!_data.inventory[1])
            {
                _data.inventory[1] = null;
            }
            var inventory = [];
            for (var i = 0; i < _data.inventory.length; i++)
            {
                var curItem = _data.inventory[i];
                if (curItem && curItem.id)
                {
                    var item = this.getWeaponData(curItem.id);
                    if (item)
                    {
                        this.applyWeaponMods(item, curItem.mods);
                        if (curItem.mag != null)
                        {
                            item.mag = Math.max(0, Math.min(99999, curItem.mag));
                        }
                        if (curItem.magSize != null)
                        {
                            item.magSize = Math.max(0, Math.min(99999, curItem.magSize));
                        }
                        if (curItem.ammo != null)
                        {
                            item.ammo = Math.max(0, Math.min(99999, curItem.ammo));
                        }
                        if (curItem.name != null)
                        {
                            item.name = curItem.name;
                        }
                        inventory.push(item);
                    }
                    else if (curItem.id)
                    {
                        console.warn("Invalid item:", curItem.id);
                    }
                }
                else
                {
                    inventory.push(null);
                }
            }
            data.inventory = inventory;
            //this.setCharacterCurrentInventoryItem(body, 0);
        }
        else
        {
            data.inventory = [
                {
                    id: "m9"
                }
            ];
        }
        data.melee = this.getWeaponData(_data.melee ? _data.melee : "melee_knife");
        if (typeof _data.grenade == "string")
        {
            data.grenade = this.getWeaponData(_data.grenade);
        }
        else
        {
            data.grenade = _data.grenade;
        }
        if (typeof _data.equipment == "string")
        {
            data.equipment = this.getWeaponData(_data.equipment);
        }
        else
        {
            data.equipment = _data.equipment;
        }
        data.inventory.push(data.melee, data.equipment, data.grenade);

        var useIndex = 0;
        for (var i = 0; i < data.inventory.length; i++)
        {
            if (data.inventory[i])
            {
                useIndex = i;
                break;
            }
        }
        this.setCharacterCurrentInventoryItem(body, useIndex);

        this.addWorldBody(body);
        if (data.bBot)
        {
            var ai = this.initPawnAI(body, data.botSkill);
            if (_data.bCamp != null)
            {
                ai.bCamp = _data.bCamp;
                ai.campPos = [body.position[0], body.position[1]];
            }
            if (_data.bInteract != null)
            {
                ai.bInteract = _data.bInteract;
            }
            if (_data.wanderArea)
            {
                this.setAIWanderArea(body, _data.wanderArea);
            }
            if (_data.objectiveItemId)
            {
                this.setAIObjectiveItemId(body, _data.objectiveItemId);
            }
            if (_data.investigatePosition)
            {
                this.setAIInvestigatePos(body, _data.investigatePosition);
            }
            if (_data.followTargetId)
            {
                this.setAIFollowTargetId(body, _data.followTargetId);
            }
            if (_data.destination)
            {
                this.setAIDestination(body, _data.destination);
            }
        }
        if (_data.damageMultipliers)
        {
            data.damageMultipliers = _data.damageMultipliers;
        }
        var ps = this.getPlayerById(data.id);
        if (this.game.bScenario)
        {
            if (ps)
            {
                data.damageMultipliers = {
                    1: 0.5,
                    2: 0.5,
                    3: 0.5,
                    4: 0.5
                }
            }
        }
        else if (this.game.bSurvival)
        {
            //Survival damage multipler
            if (ps)
            {
                data.damageMultipliers = {
                    1: 0.1,
                    2: 0.25,
                    3: 0.25,
                    4: 0.25
                }
            }
            if (data.bBot)
            {
                data.weapon.bUnlimitedAmmo = true;
            }
        }
        else
        {
            switch (this.game.gameModeId)
            {
                case GameMode.OPEN_WORLD:
                    if (ps)
                    {
                        data.damageMultipliers = {
                            1: 0.2,
                            2: 0.2,
                            3: 0.2,
                            4: 0.2
                        }
                    }
                    break;
                case GameMode.EXTRACTION:
                    if (ps && ps.team == 0)
                    {
                        data.damageMultipliers = {
                            2: 0.35
                        }
                    }
                    if (data.bBot)
                    {
                        data.weapon.bUnlimitedAmmo = true;
                    }
                    break;
            }
        }
        if (ps && this.game.gameSettings.playerDamageMultipliers)
        {
            if (!data.damageMultipliers)
            {
                data.damageMultipliers = {};
            }
            this.applyDamageMultipliers(data.damageMultipliers, this.game.gameSettings.playerDamageMultipliers);
        }
        this.onEvent({
            eventId: GameServer.EVENT_SPAWN_OBJECT,
            type: data.type,
            position: body.position,
            data: data
        });
        return body;
    }

    initPawnAI(_body, _botSkill)
    {
        var data = _body.data;
        if (_botSkill == null || _botSkill < 0)
        {
            _botSkill = 0;
        }
        var botSkill = _botSkill;
        var ai = {            
            pathTicker: 1,
            distanceMoved: 0,
            distanceTimer: 0,
            distanceTimerMax: 5 * this.game.settings.fps,
            actionTicker: 0,
            actionTickerMax: Math.max(5, 30 - (botSkill * 10)),
            wanderTicker: 0,
            wanderTickerMax: 3,
            ticker: this.Random(1, 3),
            botSkill: botSkill,
            destThreshold: data.type == ObjectType.DINOSAUR ? 20 : 50,
            fireBurstTimer: 0,
            fireBurstTimerMax: Math.round((this.Random(25, 30) + (botSkill * 10)) * this.game.fpsMult),
            fireCooldownTimer: 0,
            fireCooldownTimerMax: Math.round((this.Random(90, 100) - (botSkill * 15)) * this.game.fpsMult),
            semiCooldownTimer: 0,
            semiCooldownTimerMax: Math.round((this.Random(15, 20) - (botSkill * 2)) * this.game.fpsMult),
            lookRange: 2000 + (botSkill * 500),
            bFireCooldown: true,
            bInteract: data.bCanInteract == true,
            bInvestigate: data.bIgnoreOutOfSight == true && data.bInvestigate != false,
            enemyDistMax: 1000,
            enemyDistMult: 1
        };
        if (data.bZombie)
        {
            ai.bInteract = false;
            ai.semiCooldownTimerMax = 1;
            ai.fireBurstTimerMax = Math.ceil(ai.fireBurstTimerMax * 5);
        }
        else
        {
            if (botSkill == BotSkill.SKILL_EASY)
            {
                ai.fireBurstTimerMax = Math.ceil(ai.fireBurstTimerMax * 0.4);
                ai.fireCooldownTimerMax = Math.ceil(ai.fireCooldownTimerMax * 1.5);
            }
            else if (botSkill == BotSkill.SKILL_NORMAL)
            {
                ai.fireBurstTimerMax = Math.ceil(ai.fireBurstTimerMax * 0.5);
                ai.fireCooldownTimerMax = Math.ceil(ai.fireCooldownTimerMax * 1.2);
            }
            else if (botSkill == BotSkill.SKILL_INSANE)
            {
                ai.semiCooldownTimerMax = Math.ceil(ai.semiCooldownTimerMax * 0.5);
                ai.fireBurstTimerMax = Math.ceil(ai.fireBurstTimerMax * 1.5);
            }
            else if (botSkill >= BotSkill.SKILL_GOD)
            {
                ai.semiCooldownTimerMax = 2;
                ai.fireCooldownTimerMax = 1;
                ai.fireBurstTimerMax = Math.ceil(ai.fireBurstTimerMax * 5);
            }
        }
        switch (data.type)
        {
            case ObjectType.CHARACTER:
                data.bSwitchToMelee = data.bSwitchToMelee != null ? data.bSwitchToMelee : (ai.botSkill >= BotSkill.SKILL_HARD);
                break;
        }
        _body.ai = ai;
        return ai;
    }

    raycastBodies(_start, _target)
    {
        try
        {
            var p2 = this.p2;
            var ray = new this.p2.Ray({
                mode: p2.Ray.ANY,
                from: _start.position,
                to: _target.position,
                skipBackfaces: true,
                collisionGroup: CollisionGroups.PAWN | CollisionGroups.HELICOPTER
            });
            var result = new this.p2.RaycastResult();
            this.game.world.raycast(result, ray);
            return result ? result.body == _target : false;
        }
        catch (e)
        {
            this.onGameError(e);
        }
        return false;
    }

    raycast(_startX, _startY, _endX, _endY, _targetBody, _bBackfaces)
    {
        try
        {
            var p2 = this.p2;
            var arr = [];
            var ray = new this.p2.Ray({
                mode: p2.Ray.ALL,
                from: [_startX, _startY],
                to: [_endX, _endY],
                skipBackfaces: !_bBackfaces,
                //collisionGroup: CollisionGroups.GROUND | CollisionGroups.PAWN | CollisionGroups.OBJECT | CollisionGroups.SHIELD | CollisionGroups.HELICOPTER | CollisionGroups.PROJECTILE,
                callback: (result) =>
                {
                    var hitPoint = p2.vec2.create();
                    result.getHitPoint(hitPoint, ray);                     
                    arr.push({
                        body: result.body,
                        point: { x: hitPoint[0], y: hitPoint[1] },
                        distance: result.getHitDistance(ray)
                    });
                    if (_targetBody && result.body === _targetBody)
                    {
                        result.stop();
                    }
                }
            });
            var result = new this.p2.RaycastResult();
            this.game.world.raycast(result, ray);
            var bodies = this.getTypes([
                ObjectType.CAR,
                ObjectType.TANK,
                ObjectType.HELICOPTER
            ]);
            for (var i = 0; i < bodies.length; i++)
            {
                let body = bodies[i];
                if (body && this.Dist(_startX, _startY, body.position[0], body.position[1]) < 50)
                {
                    let aabb = body.getAABB();
                    if (aabb.containsPoint([_startX, _startY]))
                    {
                        arr.push({
                            body: body,
                            point: { x: _startX, y: _startY },
                            distance: 1
                        });
                    }
                }
            }
            arr.sort(function (a, b)
            {
                if (a.distance < b.distance) return -1;
                else if (a.distance > b.distance) return 1;
                return 0;
            });
            return arr;
        }
        catch (e)
        {
            this.onGameError(e);
        }
        return null;
    }

    endMultiKill(_ps)
    {
        if (_ps)
        {
            var count = _ps.multiKillCount;
            if (count > 1)
            {
                this.requestEvent({
                    eventId: GameServer.EVENT_PLAYER_MULTI_KILL,
                    playerId: _ps.id,
                    kills: count
                });
                if (this.game.bSurvival)
                {
                    this.addPlayerMoney(_ps.id, Math.min(500, 50 * count));
                }
            }
            _ps.multiKillTimer = 0;
            _ps.multiKillCount = 0;
        }
    }

    addScore(_team, _val)
    {
        if (_team == null || _team == -1)
        {
            return;
        }
        var gameModeData = this.game.gameModeData;
        gameModeData.scores[_team] = Math.min(gameModeData.scoreLimit, gameModeData.scores[_team] + _val);
        this.onEvent({
            eventId: GameServer.EVENT_GAME_UPDATE,
            data: {
                scores: gameModeData.scores
            }
        });
    }

    winRound(_condition, _winningTeam, _score, _playerSpotlight)
    {
        if (this.game.timer_game)
        {
            clearInterval(this.game.timer_game);
            delete this.game.timer_game;
        }
        var gameModeData = this.game.gameModeData;
        if (_winningTeam != null && _winningTeam != -1)
        {
            if (_score != 0)
            {
                this.addScore(_winningTeam, _score);
            }
            var newScore = gameModeData.scores[_winningTeam];
        }
        var scores = gameModeData.scores;
        if (gameModeData.bUseRoundThreshold)
        {
            var roundWinThreshold = Math.ceil(gameModeData.numRounds * 0.5);
            var scoreWinThreshold = Math.ceil(gameModeData.scoreLimit * 0.5);
        }
        console.log(gameModeData);
        if (scores[0] >= gameModeData.scoreLimit || scores[1] >= gameModeData.scoreLimit)
        {
            this.requestEvent({
                eventId: GameServer.EVENT_GAME_END,
                condition: MatchState.END_CONDITION_SCORE,
                winningTeam: scores[0] > scores[1] ? 0 : 1,
                gameModeData: {
                    scores: gameModeData.scores
                }
            });
        }
        else if (gameModeData.bUseRoundThreshold && ((scores[0] >= scoreWinThreshold && scores[1] < scores[0]) || (scores[1] >= scoreWinThreshold && scores[0] < scores[1])))
        {
            this.requestEvent({
                eventId: GameServer.EVENT_GAME_END,
                condition: MatchState.END_CONDITION_SCORE,
                winningTeam: scores[0] > scores[1] ? 0 : 1,
                gameModeData: {
                    scores: gameModeData.scores
                }
            });
        }
        else if (gameModeData.round + 1 >= gameModeData.numRounds)
        {
            var winner = -1;
            if (gameModeData.scores[0] > gameModeData.scores[1])
            {
                winner = 0;
            }
            else if (gameModeData.scores[0] < gameModeData.scores[1])
            {
                winner = 1;
            }
            this.requestEvent({
                eventId: GameServer.EVENT_GAME_END,
                condition: MatchState.END_CONDITION_SCORE,
                winningTeam: winner,
                gameModeData: {
                    scores: gameModeData.scores
                }
            });
        }
        else
        {
            this.requestEvent({
                eventId: GameServer.EVENT_ROUND,
                type: "end",
                condition: _condition,
                winningTeam: _winningTeam,
                playerSpotlight: _playerSpotlight,
                gameModeData: {
                    scores: gameModeData.scores
                }
            });
            setTimeout(() =>
            {
                this.prepareRound();
            }, 3000);
            gameModeData.round++;
            gameModeData.bAllowRespawns = false;

            for (var i = 0; i < this.game.players.length; i++)
            {
                let ps = this.game.players[i];
                if (ps)
                {
                    ps.bCanRespawn = false;
                    ps.bWaitingToRespawn = false;
                    //TODO: Reset killstreaks
                }
            }
        }
    }

    prepareRound()
    {
        if (this.matchHasEnded())
        {
            return;
        }
        for (var i = 0; i < this.game.supportItems.length; i++)
        {
            let ks = this.game.supportItems[i];
            ks.timer = 0;
        }
        var objects = this.getTypes([
            ObjectType.CHARACTER,
            ObjectType.DINOSAUR,
            ObjectType.HELICOPTER,
            ObjectType.CRATE,
            ObjectType.DROPPED_WEAPON,
            ObjectType.EQUIPMENT,
            ObjectType.GRENADE,
            ObjectType.ARROW
        ]);
        for (var i = 0; i < objects.length; i++)
        {
            this.removeObject(objects[i]);
        }
        var map = this.getCurrentMapData();
        switch (this.game.gameModeId)
        {
            case GameMode.HEADQUARTERS:
                /*
                var flag = this.getAllDominationFlags()[0];
                if (flag)
                {
                    this.resetFlag(flag);
                }
                var hq = map.flags_headquarters;
                if (hq)
                {
                    flag.position = hq[this.Random(0, hq.length - 1)];
                }
                */
                break;

            case GameMode.DINO_RESCUE:
                this.game.gameModeData.numHostages = 2;
                break;
        }
        setTimeout(() =>
        {
            this.startRound();
        }, 5000);
    }

    startRound()
    {
        if (!this.game)
        {
            return;
        }
        var game = this.game;
        var gameModeData = game.gameModeData;
        gameModeData.bAllowRespawns = true;
        gameModeData.bFirstBlood = false;
        gameModeData.firstBloodPlayerId = null;

        if (game.gameModeData.timeLimit)
        {
            game.gameTimer = game.gameModeData.timeLimit;
            var timer_game = setInterval(() =>
            {
                this.onGameTimer();
            }, 1000);
            game.timer_game = timer_game;
        }

        var map = this.getCurrentMapData();
        var objects = map.objects;
        if (objects)
        {
            for (var i = 0; i < objects.length; i++)
            {
                let curObject = objects[i];
                if (!this.getObjectById(curObject.id))
                {
                    switch (curObject.type)
                    {
                        case ObjectType.OBSTACLE:
                            switch (curObject.obstacleId)
                            {
                                case "barrel_explosive":
                                case "barrel_oil":
                                case "barrel_poison":
                                default:
                                    this.createObstacle(curObject);
                                    break;
                            }
                            break;
                    }
                }
            }
        }

        var doors = this.getDoors();
        for (var i = 0; i < doors.length; i++)
        {
            let door = doors[i];
            if (!door.data.bDisabled)
            {
                this.setDoorClosed(door, true, null, false, true);
            }
        }

        switch (gameModeData.id)
        {
            case GameMode.HEADQUARTERS:
                gameModeData.hqTeam = null;
                break;

            case GameMode.DEMOLITION:
                gameModeData.bombTimer = null;
                gameModeData.bombTeam = gameModeData.bombTeam == 0 ? 1 : 0;
                gameModeData.bBombPlanted = false;
                if (!this.getBombCrate())
                {
                    this.createBombCrate(gameModeData.bombTeam);
                }
                break;

            case GameMode.ASSASSINATION:
                gameModeData.vipTeam = gameModeData.vipTeam == 0 ? 1 : 0;
                break;

            case GameMode.DINO_RESCUE:
                gameModeData.rescueTeam = gameModeData.rescueTeam == 0 ? 1 : 0;
                gameModeData.numHostages = 2;
                this.setDataValue(this.getObjectById("rescueZone"), "team", gameModeData.rescueTeam);
                break;
        }

        //Start pre-game timer
        game.state = MatchState.STATE_PRE_GAME;
        game.preGameTimer = 10;
        var timer_preGame = setInterval(() =>
        {
            this.onPreGameTimer();
        }, 1000);
        game.timer_preGame = timer_preGame;
        this.onEvent({
            eventId: GameServer.EVENT_GAME_UPDATE,
            data: game.gameModeData
        });
        this.onEvent({
            eventId: GameServer.EVENT_GAME_PRE_TIMER,
            timer: game.preGameTimer
        });

        //Start round
        this.requestEvent({
            eventId: GameServer.EVENT_ROUND,
            type: "start",
            round: gameModeData.round
        });

        //Respawn players
        for (var i = 0; i < this.game.players.length; i++)
        {
            let ps = this.game.players[i];
            ps.bCanRespawn = true;
            ps.bWaitingToRespawn = true;
            ps.desiredSpawn = this.getSpawnPointForTeam(ps.team);
            ps.bAutoRespawn = true;
            this.respawnPlayer(ps.id);            
        }

        this.onRoundStart();
    }

    onRoundStart()
    {
        switch (this.game.gameModeId)
        {
            case GameMode.ASSASSINATION:
                var players = this.clone(this.game.players);
                this.shuffleArray(players);
                for (var i = 0; i < players.length; i++)
                {
                    let ps = players[i];
                    if (ps.team == this.game.gameModeData.vipTeam)
                    {
                        this.makePlayerVIP(ps.id);
                        break;
                    }
                }
                break;

            case GameMode.DINO_RESCUE:
                var map = this.getCurrentMapData();
                var hostageSpawnPoints = map.hostages ? map.hostages : map.bombs.destruction[1];
                if (hostageSpawnPoints)
                {
                    let hostageDinos = [
                        {
                            id: Dinosaur.COMPY,
                            speed: 0.3
                        },
                        {
                            id: Dinosaur.DILO,
                            speed: 0.5
                        },
                        {
                            id: Dinosaur.PACHY,
                            speed: 0.5
                        }
                    ];
                    for (var i = 0; i < hostageSpawnPoints.length; i++)
                    {
                        //Create hostage
                        let spawnPos = hostageSpawnPoints[i];
                        let dino = hostageDinos[this.Random(0, hostageDinos.length - 1)];
                        let hostage = this.createDinosaur({
                            x: spawnPos[0],
                            y: spawnPos[1],
                            team: this.game.gameModeData.rescueTeam,
                            dinoType: dino.id,
                            bBot: true,
                            botSkill: BotSkill.SKILL_HARD,
                            objectScale: this.Random(7, 10) * 0.1,
                            bRegenHealth: true,
                            bIgnoreEnemies: true,
                            bHostage: true,
                            bUntargetable: true,
                            bGodMode: true,
                            speedMultiplier: dino.speed,
                            colour: this.getRandomDinosaurColour(),
                            pawnName: "Captive Dinosaur"
                        });
                    }
                }
                else
                {
                    console.warn("Missing hostage spawn points");
                }
                break;
        }
    }

    getInitEventData()
    {
        return {
            eventId: GameServer.EVENT_GAME_INIT,
            shared: this.data.shared,
            mapId: this.game.mapId,
            gameModeId: this.game.gameModeId,
            settings: this.game.settings,
            gameSettings: this.game.gameSettings,
            gameModeData: this.game.gameModeData,
            mapData: this.getCurrentMapData(),
            tiles: this.game.tiles
        }
    }

    getGameStartEventData()
    {
        return {
            eventId: GameServer.EVENT_GAME_START,
            timer: 0
        }
    }

    getGameModeEventData()
    {
        var data = this.clone(this.game.gameModeData);
        data.tickRate = this.game.settings.fps;
        return {
            eventId: GameServer.EVENT_GAME_UPDATE,
            data: data
        };
    }

    getNumPlayers()
    {
        return this.game.players.length;
    }

    getPlayers()
    {
        return this.game.players;
    }

    checkPerformanceMode()
    {
        if (this.game && this.game.bMultiplayer)
        {
            for (var i = 0; i < this.game.players.length; i++)
            {
                let player = this.game.players[i];
                if (!player.bBot)
                {
                    this.setPerformanceMode(false);
                    return;
                }
            }
            this.setPerformanceMode(true);
        }
    }

    setPerformanceMode(_bVal)
    {
        if (this.game && this.game.bPerformanceMode != _bVal)
        {
            this.setTickRate(_bVal ? 10 : 60);               
            this.game.world.solver.tolerance = _bVal ? 0.999 : 0.1;
            this.game.world.solver.iterations = _bVal ? 1 : 2;
            this.game.bPerformanceMode = _bVal;
            this.log(_bVal ? "Performance mode ENABLED" : "Peformance mode DISABLED");
            if (!_bVal)
            {
                delete this.game.gameSettings.tickRate;
            }
        }
    }

    getCurrentGameData()
    {
        return {
            timer: this.game.gameTimer,
            scores: this.game.gameModeData.scores
        };
    }

    getObjectsEventData()
    {
        var arr = [];
        for (var key in this.game.objects)
        {
            let body = this.game.objects[key];
            let data = body ? body.data : null;
            if (data)
            {
                switch (data.type)
                {
                    case ObjectType.CHARACTER:
                        arr.push({
                            eventId: GameServer.EVENT_SPAWN_OBJECT,
                            type: data.type,
                            position: body.position,
                            rotation: body.angle,
                            data: data
                        });
                        break;
                    default:
                        arr.push({
                            eventId: GameServer.EVENT_SPAWN_OBJECT,
                            type: data.type,
                            position: body.position,
                            angle: body.angle,
                            rotation: body.angle,
                            velocity: body.velocity,
                            angularVelocity: body.angularVelocity,
                            data: data
                        });
                        break;
                }
            }
        }

        var chars = this.getCharacters();
        for (var i = 0; i < chars.length; i++)
        {
            let char = chars[i];
            if (char.data && char.data.controllableId)
            {
                let veh = this.getObjectById(char.data.controllableId);
                if (veh && veh.data.seats)
                {
                    arr.push({
                        eventId: GameServer.EVENT_PAWN_ACTION,
                        pawnId: char.data.id,
                        type: GameServer.PAWN_VEHICLE_ENTER,
                        vehicleId: veh.data.id,
                        scale: veh.data.scale,
                        seatIndex: char.data.seatIndex,
                        seat: veh.data.seats[char.data.seatIndex]
                    });
                }
            }
        }
        return arr;
    }

    onBeginContact(_event)
    {
        if (!this.game)
        {
            return;
        }
        if (_event.bodyA && _event.bodyB)
        {
            this.onHit(_event.bodyA, _event.bodyB);
            this.onHit(_event.bodyB, _event.bodyA);
        }
    }

    onHit(_bodyA, _bodyB)
    {
        var dataA = _bodyA.data;
        var dataB = _bodyB.data;
        if (dataB)
        {
            if (dataB.bInvisible || dataB.bPendingRemoval || dataA.type == ObjectType.REVIVER)
            {
                return;
            }
        }
        if (dataA)
        {
            if (dataA.bInvisible || dataA.bPendingRemoval || dataB.type == ObjectType.REVIVER)
            {
                return;
            }
            switch (dataA.type)
            {
                case ObjectType.OBSTACLE:
                    switch (dataA.obstacleId)
                    {
                        case "window":
                            switch (dataB.type)
                            {
                                case ObjectType.CAR:
                                case ObjectType.TANK:
                                    if (this.vehicleHasOccupant(_bodyB))
                                    {
                                        this.onVehicleImpact(_bodyA, _bodyB);
                                    }
                                    break;
                            }
                            break;
                        case "barrel_generic":
                        case "barrel_explosive":
                        case "barrel_poison":
                        case "barrel_oil":
                            this.onEvent({
                                eventId: GameServer.EVENT_PAWN_ACTION,
                                pawnId: dataA.id,
                                type: GameServer.PAWN_HIT
                            });
                            break;
                    }
                    break;

                case ObjectType.FLAME:
                    switch (dataB.type)
                    {
                        case ObjectType.GROUND:
                            if (_bodyA.velocity)
                            {
                                _bodyA.velocity[0] *= 0.25;
                                _bodyA.velocity[1] *= 0.25;
                            }
                            break;
                    }
                    break;

                case ObjectType.WINDOW:
                    if (this.isVehicle(_bodyB))
                    {
                        this.removeNextStep(_bodyA);
                    }
                    else
                    {
                        switch (dataB.type)
                        {
                            case ObjectType.GRENADE:
                                this.removeNextStep(_bodyA);
                                break;
                        }
                    }
                    break;

                case ObjectType.DOOR:
                    if (dataA.bClosed && !dataA.leverId && !dataA.bDisabled) //Material.METAL
                    {
                        if (dataB.type == ObjectType.CHARACTER || dataB.type == ObjectType.DINOSAUR)
                        {
                            if (dataB.bBot || dataB.bSprinting || dataB.type == ObjectType.DINOSAUR)
                            {
                                this.setDoorClosed(_bodyA, false, _bodyB, true, dataB.bBot);
                            }
                        }
                        else if (this.isVehicle(_bodyB) && dataA.material != Material.METAL)
                        {
                            var vel = Math.abs(_bodyB.velocity[0]);
                            if (vel > 50)
                            {
                                this.setDoorClosed(_bodyA, false, _bodyB, true, dataB.bBot);
                            }
                        }
                    }
                    break;

                case ObjectType.EQUIPMENT:
                    switch (dataA.weaponData.id)
                    {
                        case "ammo_box":
                        case "beacon":
                            this.onEvent({
                                eventId: GameServer.EVENT_PAWN_ACTION,
                                pawnId: dataA.id,
                                type: GameServer.PAWN_HIT
                            });
                            break;
                    }
                    break;

                case ObjectType.PROJECTILE:
                    if (!dataA["bHit"])
                    {
                        var bHit = true;
                        if (!dataA.bHitSameTeam)
                        {
                            bHit = dataA.team != dataB.team;
                        }
                        if (dataA.playerId == dataB.id || dataA.sourceId == dataB.id)
                        {
                            bHit = false;
                        }
                        switch (dataB.type)
                        {
                            case ObjectType.SHIELD:
                                if (dataA.playerId == dataB.playerId)
                                {
                                    bHit = false;
                                }
                                break;
                            case ObjectType.WINDOW:
                                this.removeNextStep(_bodyB);
                                break;
                        }
                        if (bHit)
                        {
                            var ps = this.getPlayerById(dataB["id"]);
                            var bSpawnProtected = ps && ps.bSpawnProtection;
                            if (bSpawnProtected)
                            {
                                bHit = false;
                            }
                        }
                        if (bHit)
                        {
                            if (dataA.weaponId == "rope")
                            {
                                if (_bodyB.mass > 0 && !dataB.controllableId)
                                {
                                    switch (dataB.type)
                                    {
                                        case ObjectType.HELICOPTER:
                                        case ObjectType.TANK:
                                        case ObjectType.CAR:
                                        case ObjectType.OBSTACLE:
                                        case ObjectType.DROPPED_WEAPON:
                                        case ObjectType.CRATE:
                                        case ObjectType.REVIVER:
                                        case ObjectType.CHARACTER:
                                        case ObjectType.CRATE:
                                            if (!dataB.controllableId)
                                            {
                                                var source = this.getObjectById(dataA.sourceId);
                                                if (source)
                                                {
                                                    this.attachObjects(source, _bodyB);
                                                }
                                            }
                                            break;
                                        default:
                                            if (!dataB.health)
                                            {
                                                bHit = false;
                                            }
                                            break;
                                    }
                                }
                            }
                        }
                        if (bHit)
                        {
                            dataA.bHit = true;

                            switch (dataA.weaponData.id)
                            {
                                case Dinosaur.DILO:
                                    var impact = {
                                        x: _bodyA.position[0],
                                        y: _bodyA.position[1],
                                        rotation: _bodyA.angle,
                                        impactType: Material.VENOM,
                                        damageAmount: dataA.weaponData.damage
                                    };
                                    this.createImpactEffects([impact]);
                                    this.createFlame([impact.x, impact.y], 0, dataA.team, dataA.playerId, dataA.weaponData, 0.8, true);
                                    break;
                            }

                            if (dataB.type == ObjectType.CHARACTER || dataB.type == ObjectType.DINOSAUR)
                            {
                                var impactType = dataB["material"] ? dataB["material"] : Material.DEFAULT;
                                this.createImpactEffect(_bodyA.position[0], _bodyA.position[1], _bodyA.angle, impactType, 1);
                            }
                            else
                            {
                                if (dataA.weaponData.id == Dinosaur.NEEDLER)
                                {
                                    this.createImpactEffect(_bodyA.position[0], _bodyA.position[1], _bodyA.angle, Material.DEFAULT, 1);
                                }
                            }
                            if (dataA.team != dataB.team)
                            {
                                var damageType = DamageType.DAMAGE_MELEE;
                                if (dataB["health"])
                                {
                                    var projDamage = dataA.damage;
                                    if (projDamage > 0)
                                    {
                                        this.requestEvent({
                                            eventId: GameServer.EVENT_PAWN_DAMAGE,
                                            damageType: damageType,
                                            damageAmount: projDamage,
                                            pawnId: dataB["id"],
                                            attackerId: dataA.playerId,
                                            causerId: dataA["id"],
                                            weaponId: dataA.weaponId,
                                            bMelee: dataA.bMelee,
                                            bKnife: dataA.weaponId == "knife",
                                            bDirectlyCausedByPlayer: true
                                        });
                                    }
                                }
                            }
                            var pos = _bodyA.previousPosition ? _bodyA.previousPosition : _bodyA.position;
                            switch (dataA.weaponId)
                            {
                                case "knife":
                                    var knife = this.createDroppedWeapon(pos, {
                                        angle: _bodyA.angle,
                                        scale: 1,
                                        weaponData: this.getWeaponData(dataA.weaponId),
                                        playerId: dataA.playerId,
                                        velocity: [_bodyA.velocity[0] * 0.1, _bodyA.velocity[1] * 0.1]
                                    });
                                    knife.applyImpulse([_bodyA.velocity[0] * 0.5, _bodyA.velocity[1] * 0.5], [0, 0]);
                                    break;

                                case "crossbow":
                                case "bow":
                                case "quadra":
                                    this.createImpactEffect(pos[0], pos[1], _bodyA.rotation, "default", 1);
                                    this.createArrow(pos, {
                                        angle: _bodyA.angle
                                    });
                                    break;
                            }
                            this.removeNextStep(_bodyA);
                        }
                    }
                    break;

                case ObjectType.CHARACTER:
                case ObjectType.DINOSAUR:
                case ObjectType.DUMMY:                
                    switch (dataB.type)
                    {
                        case ObjectType.CAR:
                        case ObjectType.TANK:
                            if (this.vehicleHasOccupant(_bodyB))
                            {                                
                                if (dataA.team != dataB.team && _bodyB.mass >= _bodyA.mass)
                                {
                                    this.onVehicleImpact(_bodyA, _bodyB);
                                }
                            }
                            break;
                    }
                    break;

                case ObjectType.DROPPED_WEAPON:
                case ObjectType.CRATE:
                case ObjectType.TANK:
                    this.onEvent({
                        eventId: GameServer.EVENT_PAWN_ACTION,
                        pawnId: dataA.id,
                        type: GameServer.PAWN_HIT
                    });
                    break;

                case ObjectType.CAR:
                    if (dataB.type == ObjectType.GROUND)
                    {
                        this.setDataValue(_bodyA, "currentSurface", dataB.material ? dataB.material : Material.DEFAULT);
                    }
                    this.onEvent({
                        eventId: GameServer.EVENT_PAWN_ACTION,
                        pawnId: dataA.id,
                        type: GameServer.PAWN_HIT
                    });
                    break;

                case ObjectType.HELICOPTER:
                    switch (dataB.type)
                    {
                        case ObjectType.GROUND:
                        case ObjectType.HELICOPTER:
                        case ObjectType.TANK:
                            this.onEvent({
                                eventId: GameServer.EVENT_PAWN_ACTION,
                                pawnId: dataA.id,
                                type: GameServer.PAWN_HIT
                            });
                            break;
                    }
                    if (dataB.type == ObjectType.GROUND)
                    {
                        if (!dataA["health"])
                        {
                            this.createExplosion({
                                eventId: GameServer.EVENT_SPAWN_EXPLOSION,
                                position: _bodyA.position,
                                radius: 500,
                                damage: this.settings.vehicleExplosionDamage,
                                playerId: null,
                                causerId: null,
                                weaponId: null
                            });
                            this.removeNextStep(_bodyA);
                        }
                        else if (this.matchInProgress())
                        {
                            var deg = Math.abs(this.ToDeg(_bodyA.angle));
                            if (deg)
                            {
                                var vx = _bodyA.velocity[0];
                                var vy = _bodyA.velocity[1];
                                var damage = 1; //((vx * vx + vy * vy) * 0.0005) * (deg * 0.05);
                                if (damage > _bodyA.data.maxHealth * 0.5)
                                {
                                    this.requestEvent({
                                        eventId: GameServer.EVENT_PAWN_DAMAGE,
                                        damageType: DamageType.DAMAGE_WORLD,
                                        damageAmount: damage,
                                        pawnId: dataA.id,
                                        causerId: dataA.id,
                                        weaponId: "generic"
                                    });
                                }
                            }
                        }
                    }
                    break;

                case ObjectType.GRENADE:
                    if (dataA.bImpact && dataA.lifespan > 0)
                    {
                        if (this.isVehicle(_bodyB) && !this.vehicleHasOccupant(_bodyB))
                        {
                            break;
                        }                    
                        if (dataB)
                        {
                            if (dataA.causerId == dataB.id)
                            {
                                break;
                            }
                            if (dataA.team == dataB.team)
                            {
                                break;
                            }
                            var bDud = dataA.minTimer > 0 && !dataA.bDud;
                            switch (dataB.type)
                            {
                                case ObjectType.HELICOPTER:
                                case ObjectType.TANK:
                                case ObjectType.CAR:
                                    var bDamage = true;
                                    var bDetonate = true;
                                    if (!this.vehicleHasOccupant(_bodyB))
                                    {
                                        var attacker = this.getPlayerById(dataA.playerId);
                                        if (attacker)
                                        {
                                            if (attacker.team == dataB.team)
                                            {
                                                bDamage = false;
                                                bDetonate = false;
                                            }
                                        }
                                        else if (dataA.team == dataB.team)
                                        {
                                            bDamage = false;
                                            bDetonate = false;
                                        }
                                    }
                                    if (bDamage)
                                    {
                                        var useDamage = dataA.damage;
                                        this.requestEvent({
                                            eventId: GameServer.EVENT_PAWN_DAMAGE,
                                            damageType: DamageType.DAMAGE_EXPLOSIVE,
                                            damageAmount: useDamage,
                                            pawnId: dataB.id,
                                            attackerId: dataA.playerId,
                                            causerId: dataA.id,
                                            weaponId: dataA.weaponId
                                        });
                                    }
                                    if (bDetonate)
                                    {
                                        this.detonate(_bodyA, dataB.id);
                                    }
                                    break;

                                case ObjectType.CHARACTER:
                                    var bDetonate = true;
                                    var attacker = this.getPlayerById(dataA.playerId);
                                    if (attacker)
                                    {
                                        if (attacker.id == dataB.id)
                                        {
                                            bDetonate = false;
                                        }
                                    }
                                    else
                                    {
                                        if (dataA.playerId == dataB.id)
                                        {
                                            bDetonate = false;
                                        }
                                    }
                                    if (bDetonate)
                                    {
                                        if (dataA.team == dataB.team)
                                        {
                                            bDetonate = !this.game.bSurvival;
                                        }
                                    }
                                    if (bDetonate)
                                    {
                                        if (bDud && 0)
                                        {
                                            var ps = this.getPlayerById(dataB.id);
                                            var bSpawnProtected = ps && ps.bSpawnProtection;
                                            if (!bSpawnProtected && dataA.team != dataB.team)
                                            {
                                                this.requestEvent({
                                                    eventId: GameServer.EVENT_PAWN_DAMAGE,
                                                    damageType: DamageType.DAMAGE_MELEE,
                                                    damageAmount: 100, //Direct impact
                                                    pawnId: dataB.id,
                                                    attackerId: dataA.playerId,
                                                    causerId: dataA.id,
                                                    weaponId: dataA.weaponId, //"impact"
                                                    bDirectImpact: true
                                                });
                                                dataA["bDud"] = true;
                                            }
                                            else
                                            {
                                                this.createImpactEffect(_bodyA.position[0], _bodyA.position[1], _bodyA.angle, "grenade", 1);
                                            }
                                            this.removeNextStep(_bodyA);
                                        }
                                        else
                                        {
                                            this.detonate(_bodyA);
                                        }
                                    }
                                    break;

                                case ObjectType.MOUNTED_WEAPON:
                                    var bDetonate = true;
                                    if (this.game.bSurvival)
                                    {
                                        bDetonate = false;
                                    }
                                    else if (dataA.team == dataB.team || dataB.team == -1)
                                    {
                                        bDetonate = false;
                                    }
                                    if (bDetonate)
                                    {
                                        this.detonate(_bodyA);
                                    }
                                    break;

                                case ObjectType.OBSTACLE:
                                    if (this.game.bSurvival && dataA.team == 0 && !dataB.bBlockLOS)
                                    {
                                        //Pass through
                                    }
                                    else if (!bDud)
                                    {
                                        this.detonate(_bodyA);
                                    }
                                    else
                                    {
                                        console.log("dud");
                                    }
                                    break;

                                case ObjectType.DOOR:
                                    this.detonate(_bodyA);
                                    if (dataB.material != Material.METAL)
                                    {
                                        this.setDoorClosed(_bodyB, false, _bodyA, true);
                                    }
                                    break;

                                case ObjectType.LEVER:
                                    break;

                                default:
                                    this.detonate(_bodyA);
                                    break;
                            }
                        }
                    }
                    else
                    {
                        if (dataA.bStartDetonationAfterHit)
                        {
                            dataA["bDetonationTimerEnabled"] = true;
                        }
                        var weaponData = this.getWeaponData(dataA.weaponId);
                        if (weaponData["bSticky"])
                        {
                            if (!_bodyA["constraint"])
                            {
                                _bodyA.velocity = [0, 0];
                                _bodyA.mass = 0.1;
                                _bodyA.angularVelocity = 0;
                                _bodyA.angularDamping = 0.99;
                                _bodyA.shapes[0].collisionMask = CollisionGroups.PROJECTILE;
                                var constraint = new this.p2.RevoluteConstraint(_bodyA, _bodyB, {
                                    worldPivot: [_bodyA.position[0], _bodyA.position[1]]
                                });
                                this.game.world.addConstraint(constraint);
                                _bodyA["constraint"] = constraint;
                                dataA["stuckToId"] = _bodyB.data.id;
                                this.setDataValue(_bodyA, "bStuck", true);
                            }
                        }
                    }
                    break;

                case ObjectType.ROCKET:
                    if (dataB)
                    {
                        switch (dataB.type)
                        {
                            case ObjectType.HELICOPTER:
                            case ObjectType.TANK:
                            case ObjectType.CAR:
                            case ObjectType.MOUNTED_WEAPON:
                                var bDamage = true;
                                var bDetonate = true;
                                var attacker = this.getPlayerById(dataA.playerId);
                                var playerId = dataB.playerId; // == ObjectType.HELICOPTER ? dataB.heliData.playerId : dataB.tankData.playerId;
                                if (attacker)
                                {
                                    if (dataA.causerId == dataB.id)
                                    {
                                        bDamage = false;
                                    }
                                    else if (attacker.id == playerId)
                                    {
                                        bDamage = this.game.bFriendlyFire;
                                    }
                                    else if (attacker.team == dataB.team)
                                    {
                                        bDamage = false; //this.game["bFriendlyFire"];
                                    }
                                }
                                else
                                {
                                    if (dataA.team == dataB.team)
                                    {
                                        bDamage = false;
                                    }
                                }
                                if (this.game.bSurvival && (!this.vehicleHasOccupant(_bodyB) || !dataB.health))
                                {
                                    bDamage = false;
                                }
                                bDetonate = bDamage;
                                if (bDamage)
                                {
                                    this.requestEvent({
                                        eventId: GameServer.EVENT_PAWN_DAMAGE,
                                        damageType: DamageType.DAMAGE_EXPLOSIVE,
                                        damageAmount: dataA.damage,
                                        pawnId: dataB.id,
                                        attackerId: dataA.playerId,
                                        causerId: dataA.id,
                                        weaponId: dataA.weaponId
                                    });
                                }
                                if (bDetonate)
                                {
                                    this.detonate(_bodyA, dataB.id);
                                }
                                break;

                            case ObjectType.CHARACTER:
                            case ObjectType.DINOSAUR:
                                var bDetonate = true;
                                var attackerPawn = this.getObjectById(dataA.playerId);
                                if (attackerPawn)
                                {
                                    if (attackerPawn.data.id == dataB.id)
                                    {
                                        bDetonate = false;
                                    }
                                    else if (dataA.team == dataB.team)
                                    {
                                        bDetonate = false; //!attackerPawn.data.bBot && this.game.gameModeData.bHardcore;
                                    }
                                }
                                if (dataB.controllableId)
                                {
                                    bDetonate = false;
                                }
                                if (bDetonate)
                                {
                                    this.requestEvent({
                                        eventId: GameServer.EVENT_PAWN_DAMAGE,
                                        damageType: DamageType.DAMAGE_EXPLOSIVE,
                                        damageAmount: dataA.damage,
                                        pawnId: dataB.id,
                                        attackerId: dataA.playerId,
                                        causerId: dataA.id,
                                        weaponId: dataA.weaponId
                                    });
                                    this.detonate(_bodyA);
                                }
                                break;

                            case ObjectType.OBSTACLE:
                                if (!dataA.bRequireLock)
                                {
                                    this.detonate(_bodyA);
                                }
                                break;

                            case ObjectType.EQUIPMENT:
                            case ObjectType.LEVER:
                                break;

                            case ObjectType.DOOR:
                                this.detonate(_bodyA);
                                if (dataB.material != Material.METAL)
                                {
                                    this.setDoorClosed(_bodyB, false, _bodyA, true);
                                }
                                break;

                            default:
                                this.detonate(_bodyA);
                                break;
                        }
                    }
                    break;
            }
        }
    }

    createExplosion(_data)
    {
        this.requestEvent(_data);
    }

    getExplosionObjects()
    {
        var objects = this.getTypes([
            ObjectType.CHARACTER,
            ObjectType.DINOSAUR,
            ObjectType.FLYING_DINOSAUR,
            ObjectType.DUMMY,
            ObjectType.HELICOPTER,
            ObjectType.TANK,
            ObjectType.CAR,
            ObjectType.MOUNTED_WEAPON,
            ObjectType.CRATE,
            ObjectType.EQUIPMENT,
            ObjectType.DROPPED_WEAPON,
            ObjectType.GRENADE,
            ObjectType.OBSTACLE,
            ObjectType.WINDOW,
            ObjectType.EGG
        ]);
        //if (cur.mass > 0 && cur.data && !cur.data.bPendingRemoval)
        return objects;
    }

    checkExplosion(_data)
    {       
        if (_data.position)
        {
            var x = _data.position[0];
            var y = _data.position[1];
        }
        else
        {
            x = _data.x;
            y = _data.y;
        }
        var radius = _data.radius;
        var damage = _data.damage;
        var instigatorId = _data.playerId;
        var causerId = _data.causerId;
        var weaponId = _data.weaponId;
        var bIgnoreLOS = _data.bLOS;
        var directHitId = _data.directHitId;
        var instigator = this.getPlayerById(instigatorId);
        var causer = this.getObjectById(causerId);
        var damageAmount = damage;
        var bLOS = !bIgnoreLOS;

        var causerTeam = _data.team != null ? _data.team : null;
        if (causerTeam == null)
        {
            causerTeam = instigator ? instigator.team : null;
        }
        if (causerTeam == null)
        {
            causerTeam = causer ? causer.data.team : null;
        }

        this.emitAISound([x, y], [x, y], radius, causerTeam);

        var objects = this.getExplosionObjects();
        loop: for (var i = 0; i < objects.length; i++)
        {
            let cur = objects[i];
            if (!cur.data || cur.data.bPendingRemoval || cur.data.bInvisible || cur.data.bNoBody)
            {
                continue;
            }
            let curDamage = damageAmount;
            switch (cur.data.type)
            {
                case ObjectType.CHARACTER:
                case ObjectType.DINOSAUR:
                    if (cur.data.controllableId)
                    {
                        var vehicle = this.getObjectById(cur.data.controllableId);
                        if (vehicle && vehicle.data.type != ObjectType.MOUNTED_WEAPON)
                        {
                            continue loop;
                        }
                    }
                    let ps = this.getPlayerById(cur.data.id);
                    if (ps && ps.bSpawnProtection)
                    {
                        continue loop;
                    }
                    break;
                case ObjectType.DOOR:
                    if (!cur.data.bClosed)
                    {
                        continue loop;
                    }
                    break;
                case ObjectType.CRATE:
                    if (cur.data.crateType == Crate.BOMB)
                    {
                        continue loop;
                    }
                    break;
            }
            let distMult = 1;
            let distFromCenter = this.Dist(x, y, cur.position[0], cur.position[1]);
            if (distFromCenter > radius)
            {
                continue;
            }
            let bLOSCheck = bLOS ? this.checkLineOfSight([x, y], cur.position, true, cur) : true;
            if (bLOSCheck && cur.mass != Number.MAX_VALUE)
            {
                switch (cur.data.type)
                {
                    case ObjectType.OBSTACLE:
                    case ObjectType.DROPPED_WEAPON:
                    case ObjectType.CAR:
                    case ObjectType.TANK:
                    case ObjectType.HELICOPTER:
                        let angle = this.Angle(x, y, cur.position[0], cur.position[1]);
                        if (!isNaN(angle))
                        {
                            let force = (damage / cur.mass) * (this.Random(5, 10) * 0.1);
                            cur.applyImpulse([Math.cos(angle) * force, Math.sin(angle) * force]);
                            cur.angularVelocity += (angle / cur.mass) * this.Random(1, 10);
                        }
                        break;
                }
            }
            if (cur.data.health > 0)
            {
                if (cur.data.type == ObjectType.DOOR && cur.data.bClosed && cur.data.material != Material.METAL)
                {
                    this.setDoorClosed(cur, false, causer);
                }
                if (!bLOSCheck)
                {
                    continue;
                }
                let bAlly = false;
                let bSelf = false;
                if (instigator)
                {
                    bSelf = cur.data.id == instigator.id;
                    bAlly = cur.data.team == instigator.team && !bSelf;
                }
                else if (causer)
                {
                    bSelf = cur.data.id == causer.data.id;
                    bAlly = cur.data.team == causer.data.team && !bSelf;
                }
                if (cur.data.type == ObjectType.MOUNTED_WEAPON)
                {
                    bAlly = bAlly || (causer && cur.data.id == causer.data.id);
                }
                if (!this.game.bFriendlyFire)
                {
                    bAlly = bAlly || bSelf;
                }
                if (weaponId == "bomb")
                {
                    bAlly = false; //Bomb crates kill everyone
                }
                if (bAlly)
                {
                    //curDamage = 0;
                    continue;
                }
                else if (this.isVehicle(cur) && this.vehicleHasOccupant(cur) && bAlly && !this.game.bFriendlyFire)
                {
                    //curDamage = 0;
                    continue;
                }
                else if (this.isVehicle(cur))
                {
                    //Handle vehicle explosive damage
                    if (bAlly)
                    {
                        //damageAmount = 0;
                    }
                    else if (cur.data.id == directHitId)
                    {
                        curDamage = Math.round(curDamage * 0.25); //Direct hit, so don't apply additional explosive damage
                    }
                    else
                    {
                        distMult = (1 - distFromCenter / radius);
                        curDamage = damage * distMult;
                        if (cur.data.type == ObjectType.MOUNTED_WEAPON)
                        {
                            if (weaponId == "stun" || _data.modId == Mods.GRENADE_STUN)
                            {
                                cur.data.bStunned = true;
                                let maxStunTime = Math.round(this.game.settings.fps * this.settings.maxStunTime);
                                cur.data.stunTimer = Math.ceil(maxStunTime * distMult);
                                console.log(maxStunTime, cur.data.stunTimer);
                                this.onEvent({
                                    eventId: GameServer.EVENT_PAWN_ACTION,
                                    pawnId: cur.data.id,
                                    type: GameServer.PAWN_STUN,
                                    bValue: true,
                                    time: cur.data.stunTimer
                                });
                            }
                            else if (weaponId == "flashbang" || _data.modId == Mods.GRENADE_FLASH)
                            {
                                cur.data.bFlashed = true;
                                let maxFlashTime = Math.round(this.game.settings.fps * this.settings.maxFlashTime);
                                cur.data.flashTimer = Math.ceil(maxFlashTime * distMult);
                                this.onEvent({
                                    eventId: GameServer.EVENT_PAWN_ACTION,
                                    pawnId: cur.data.id,
                                    type: GameServer.PAWN_FLASH,
                                    bValue: true,
                                    flashIntensity: 1,
                                    time: cur.data.flashTimer
                                });
                            }
                        }
                    }
                }
                else
                {
                    distMult = 1 - distFromCenter / radius;
                    curDamage = damage * distMult;
                    let flashMult = 1;
                    if (weaponId == "stun" || _data.modId == Mods.GRENADE_STUN)
                    {
                        cur.data.bStunned = true;
                        let maxStunTime = Math.round((this.game.settings.fps * this.settings.maxStunTime) / Math.max(1, cur.mass));
                        if (this.characterHasEquipment(cur, "blast_vest"))
                        {
                            maxStunTime *= 0.5;
                        }
                        cur.data.stunTimer = Math.max(this.game.settings.fps * 2, Math.ceil((maxStunTime * distMult) * flashMult));
                        if (cur.data.bImmuneToStun)
                        {
                            cur.data.stunTimer = 1;
                        }
                        cur.data.aimRotation += this.ToRad(this.Random(-30, 30));
                        //TODO: Handle stuns/flashes in EVENT_PAWN_DAMAGE
                        this.onEvent({
                            eventId: GameServer.EVENT_PAWN_ACTION,
                            pawnId: cur.data.id,
                            type: GameServer.PAWN_STUN,
                            bValue: true,
                            time: cur.data.stunTimer
                        });
                    }
                    else if (weaponId == "flashbang" || _data.modId == Mods.GRENADE_FLASH)
                    {
                        cur.data.bFlashed = true;
                        cur.data["flashIntensity"] = Math.min(1, distMult * 2);
                        let maxFlashTime = Math.round((this.game.settings.fps * this.settings.maxFlashTime) / Math.max(1, cur.mass));
                        if (this.characterHasEquipment(cur, "blast_vest"))
                        {
                            maxFlashTime *= 0.5;
                        }
                        cur.data.flashTimer = Math.ceil((maxFlashTime * distMult) * flashMult);
                        if (cur.data.bImmuneToStun)
                        {
                            cur.data.flashTimer = 1;
                        }
                        this.onEvent({
                            eventId: GameServer.EVENT_PAWN_ACTION,
                            pawnId: cur.data.id,
                            type: GameServer.PAWN_FLASH,
                            bValue: true,
                            flashIntensity: cur.data["flashIntensity"],
                            time: cur.data.flashTimer
                        });
                    }
                }
            }
            else
            {
                curDamage = 0;
            }
            if (curDamage > 0)
            {
                switch (cur.data.type)
                {
                    case ObjectType.EQUIPMENT:
                        if (cur.data.id != causerId)
                        {
                            if (cur.data.weaponData["bMine"])
                            {
                                if (instigator)
                                {
                                    cur.data["ownerId"] = instigator.id;
                                }
                                cur.data["bTriggered"] = true;
                                cur.data["triggerTimer"] = 2;
                            }
                            else
                            {
                                this.requestEvent({
                                    eventId: GameServer.EVENT_PAWN_DAMAGE,
                                    damageType: DamageType.DAMAGE_EXPLOSIVE,
                                    damageAmount: curDamage,
                                    pawnId: cur.data.id,
                                    attackerId: instigator ? instigator.id : causerId,
                                    causerId: causerId,
                                    weaponId: weaponId,
                                    bDirectlyCausedByPlayer: true
                                });
                            }
                        }
                        break;
                    case ObjectType.GRENADE:
                        if (cur.data.bRemoteDetonation)
                        {
                            cur.data.bDetonationTimerEnabled = true;
                            cur.data.detonationTimer = 2;
                        }
                        break;
                    default:
                        let bBlastVest = this.characterHasEquipment(cur, "blast_vest");
                        if (bBlastVest)
                        {
                            curDamage = curDamage * 0.5;
                        }
                        this.requestEvent({
                            eventId: GameServer.EVENT_PAWN_DAMAGE,
                            damageType: DamageType.DAMAGE_EXPLOSIVE,
                            damageAmount: curDamage,
                            pawnId: cur.data.id,
                            attackerId: instigator ? instigator.id : causerId,
                            causerId: causerId,
                            weaponId: weaponId,
                            useId: _data.useId,
                            bDirectlyCausedByPlayer: true,
                            bBlastVest: bBlastVest
                        });
                        break;
                }
            }
        }
    }

    detonate(_body, _directHitId)
    {
        if (_body && _body.data)
        {
            var data = _body.data;
            if (data.bDetonated)
            {
                return;
            }
            data.bDetonated = true;
            switch (data.type)
            {
                case ObjectType.CRATE:
                    switch (this.game.gameModeId)
                    {
                        case GameMode.DESTRUCTION:
                            var bombs = this.game.gameModeData.bombs;
                            bombs[data.bombNum] = null;
                            var scoreTeam = data.team == 0 ? 1 : 0;
                            var scores = this.game.gameModeData.scores;
                            scores[scoreTeam]++;
                            this.onEvent({
                                eventId: GameServer.EVENT_GAME_UPDATE,
                                data: {
                                    scores: scores,
                                    bombs: bombs,
                                    bombTeam: scoreTeam,
                                    bombNum: data.bombNum
                                }
                            });
                            if (scores[scoreTeam] >= this.game.gameModeData.scoreLimit)
                            {
                                this.requestEvent({
                                    eventId: GameServer.EVENT_GAME_END,
                                    condition: MatchState.END_CONDITION_SCORE,
                                    winningTeam: scoreTeam,
                                    cameraTargetId: data.id                                    
                                });
                            }
                            else
                            {
                                var numBombs = this.getBombCrates(data.team);
                                if (numBombs.length <= 1)
                                {
                                    this.requestEvent({
                                        eventId: GameServer.EVENT_GAME_END,
                                        condition: MatchState.END_CONDITION_SCORE,
                                        winningTeam: scoreTeam,
                                        cameraTargetId: data.id
                                    });
                                }
                            }
                            break;
                    }
                    this.createExplosion({
                        eventId: GameServer.EVENT_SPAWN_EXPLOSION,
                        position: _body.position,
                        radius: 500,
                        damage: 1000,
                        causerId: data.id,
                        playerId: data.planterId,
                        weaponId: "bomb"
                    });
                    this.removeNextStep(_body);
                    break;

                case ObjectType.OBSTACLE:
                    var ps = this.getPlayerById(data.playerId);
                    if (ps)
                    {
                        data.team = ps.team;
                    }
                    switch (data.obstacleId)
                    {
                        case "barrel_explosive":
                            this.createExplosion({
                                eventId: GameServer.EVENT_SPAWN_EXPLOSION,
                                position: _body.position,
                                radius: 350,
                                damage: 500,
                                playerId: data.playerId ? data.playerId : data.id,
                                causerId: data.id,
                                weaponId: "barrel",
                                bDirectlyCausedByPlayer: true,
                                directHitId: _directHitId
                            });
                            this.removeNextStep(_body);
                            break;
                        case "barrel_poison":
                            this.createExplosion({
                                eventId: GameServer.EVENT_SPAWN_EXPLOSION,
                                position: _body.position,
                                radius: 350,
                                damage: 500,
                                playerId: data.playerId ? data.playerId : data.id,
                                causerId: data.id,
                                weaponId: "barrel",
                                bDirectlyCausedByPlayer: true,
                                directHitId: _directHitId
                            });
                            var numFlames = 10;
                            var weaponData = this.getWeaponData(Dinosaur.DILO);
                            for (var i = 0; i < numFlames; i++)
                            {
                                this.createFlame(_body.position, [this.Random(-500, 500), this.Random(-500, 500)], _body.data.team, data.playerId ? data.playerId : data.id, weaponData, weaponData.fireTime);
                            }
                            this.removeNextStep(_body);
                            break;
                        case "barrel_oil":
                            this.createExplosion({
                                eventId: GameServer.EVENT_SPAWN_EXPLOSION,
                                position: _body.position,
                                radius: 350,
                                damage: 500,
                                playerId: data.playerId ? data.playerId : data.id,
                                causerId: data.id,
                                weaponId: "barrel",
                                bDirectlyCausedByPlayer: true,
                                directHitId: _directHitId
                            });
                            var numFlames = 10;
                            var weaponData = this.getWeaponData("molotov");
                            for (var i = 0; i < numFlames; i++)
                            {
                                this.createFlame(_body.position, [this.Random(-500, 500), this.Random(-500, 500)], _body.data.team, data.playerId ? data.playerId : data.id, weaponData, weaponData.fireTime);
                            }
                            this.removeNextStep(_body);
                            break;
                    }
                    break;

                case ObjectType.EQUIPMENT:
                    var weaponData = data["weaponData"];
                    if (weaponData)
                    {
                        var explosionX = _body.position[0];
                        var explosionY = _body.position[1] - 10;
                        switch (weaponData.id)
                        {
                            case "claymore":
                                explosionX += 50 * data.scale;
                                explosionY -= 10;
                                break;
                        }
                        this.createExplosion({
                            eventId: GameServer.EVENT_SPAWN_EXPLOSION,
                            position: [explosionX, explosionY],
                            radius: weaponData.radius,
                            damage: weaponData.damage,
                            playerId: data["ownerId"] ? data["ownerId"] : data.id,
                            causerId: data.id,
                            weaponId: weaponData.id,
                            bDirectlyCausedByPlayer: true,
                            directHitId: _directHitId
                        });
                    }
                    this.removeNextStep(_body);
                    break;

                case ObjectType.GRENADE:
                    weaponData = data.weaponData ? data.weaponData : this.getWeaponData(data.weaponId);
                    if (data.stuckToId)
                    {
                        var stuck = this.getObjectById(data.stuckToId);
                        if (stuck)
                        {
                            this.requestEvent({
                                eventId: GameServer.EVENT_PAWN_DAMAGE,
                                damageType: DamageType.DAMAGE_EXPLOSIVE,
                                damageAmount: weaponData.damage,
                                pawnId: data.stuckToId,
                                attackerId: data.playerId ? data.playerId : data.id,
                                causerId: data.id,
                                weaponId: weaponData.id,
                                useId: weaponData.id,
                                modId: data.modId,
                                bDirectlyCausedByPlayer: true
                            });
                        }
                    }
                    if (data.weaponId == "smoke" || data.modId == Mods.GRENADE_SMOKE)
                    {
                        _body.data["destroyTimer"] = this.game.settings.fps * 5;
                        this.setDataValue(_body, "bActivated", true);
                        this.createExplosion({
                            eventId: GameServer.EVENT_SPAWN_EXPLOSION,
                            position: _body.position,
                            radius: 200,
                            damage: Math.max(50, weaponData.damage),
                            playerId: data.playerId ? data.playerId : data.id,
                            causerId: data.id,
                            weaponId: weaponData.id,
                            modId: data.modId,
                            bDirectlyCausedByPlayer: true,
                            directHitId: _directHitId
                        });
                        _body.shapes[0].sensor = false;
                        if (data.modId == Mods.GRENADE_SMOKE)
                        {
                            _body.velocity = [0, 0];
                        }
                    }
                    else if (weaponData.id == "napalm" || weaponData.id == "molotov" || data.modId == Mods.GRENADE_FIRE)
                    {
                        var firePos = _body.previousPosition ? _body.previousPosition : _body.position;
                        this.createExplosion({
                            eventId: GameServer.EVENT_SPAWN_EXPLOSION,
                            position: firePos,
                            radius: weaponData.radius,
                            damage: weaponData.damage,
                            playerId: data.playerId ? data.playerId : data.id,
                            causerId: data.id,
                            weaponId: data.weaponId,
                            modId: data.modId,
                            bDirectlyCausedByPlayer: true,
                            directHitId: _directHitId
                        });
                        var numFlames = 15;
                        var flameWeaponData = weaponData;
                        if (data.modId == Mods.GRENADE_FIRE)
                        {
                            flameWeaponData = this.getWeaponData("napalm");
                        }
                        for (var i = 0; i < numFlames; i++)
                        {
                            this.createFlame(_body.position, [this.Random(-500, 500), this.Random(-500, 500)], _body.data.team, data.playerId ? data.playerId : data.id, flameWeaponData, flameWeaponData.fireTime);
                        }
                        this.removeNextStep(_body);
                    }
                    else
                    {
                        if (data["minTimer"] > 0 && 0)
                        {
                            this.removeNextStep(_body);
                            this.createImpactEffect(_body.position[0], _body.position[1], _body.angle, "grenade", 1);
                        }
                        else
                        {
                            var grenadePos = _body.previousPosition;
                            if (grenadePos[0] == 0 && grenadePos[1] == 0)
                            {
                                grenadePos = _body.position;
                            }
                            grenadePos[1] -= 10;
                            var weaponId = data["killstreakId"] ? data["killstreakId"] : data.weaponId;
                            this.createExplosion({
                                eventId: GameServer.EVENT_SPAWN_EXPLOSION,
                                position: grenadePos,
                                radius: data.radius,
                                damage: data.damage,
                                playerId: data.playerId ? data.playerId : data.id,
                                causerId: data.id,
                                weaponId: weaponId,
                                modId: data.modId,
                                bDirectlyCausedByPlayer: true
                            });
                            if (_body["constraint"])
                            {
                                this.game.world.removeConstraint(_body["constraint"]);
                                delete _body["constraint"];
                                _body.collisionMask = CollisionGroups.GROUND | CollisionGroups.PROJECTILE;
                            }
                            this.removeNextStep(_body);
                        }
                    }
                    break;

                case ObjectType.ROCKET:
                    var rocketPos = _body.previousPosition;
                    if (rocketPos[0] == 0 && rocketPos[1] == 0)
                    {
                        rocketPos = _body.position;
                    }
                    this.createExplosion({
                        eventId: GameServer.EVENT_SPAWN_EXPLOSION,
                        position: rocketPos,
                        radius: data.radius,
                        damage: data.damage,
                        playerId: data.playerId ? data.playerId : data.id,
                        causerId: data.id,
                        weaponId: data.useWeaponId ? data.useWeaponId : data.weaponId,
                        bDirectlyCausedByPlayer: true,
                        bLOS: data.enemyId != null
                    });
                    if (data.rocketType == Rocket.NAPALM)
                    {
                        var numFlames = 15;
                        switch (data.weaponId)
                        {
                            default:
                                var flameTime = 5;
                                break;
                        }
                        for (var i = 0; i < numFlames; i++)
                        {
                            this.createFlame(_body.position, [this.Random(-500, 500), this.Random(-500, 500)], _body.data.team, data.playerId ? data.playerId : data.id, this.getWeaponData("napalm"), flameTime);
                        }
                    }
                    this.removeNextStep(_body);
                    break;
            }
        }
    }

    isMeleeWeapon(_weaponData)
    {
        if (_weaponData)
        {
            return (_weaponData.type == Weapon.TYPE_MELEE || _weaponData.bMelee) && !_weaponData.bEquipment; // && !_weaponData.bDinosaur;
        }
        return false;
    }

    applyWeaponMods(_weaponData, _mods)
    {
        if (!_weaponData || _weaponData.mag == null || !_mods)
        {
            return;
        }
        _weaponData.mods = {};
        var mods = _weaponData.mods;
        if (_mods)
        {
            var defaultWeaponData = this.getWeaponData(_weaponData.id);
            mods[Mods.TYPE_OPTIC] = _mods[Mods.TYPE_OPTIC];
            mods[Mods.TYPE_BARREL] = _mods[Mods.TYPE_BARREL];
            mods[Mods.TYPE_ACCESSORY] = _mods[Mods.TYPE_ACCESSORY];
            mods[Mods.TYPE_AMMO] = _mods[Mods.TYPE_AMMO];

            _weaponData.mag = Math.min(_weaponData.mag, defaultWeaponData.magSize);
            _weaponData.fireMode = defaultWeaponData["fireMode"];
            _weaponData.accuracy = defaultWeaponData["accuracy"];
            _weaponData.fireRate = defaultWeaponData["fireRate"];
            _weaponData.burstFireRate = defaultWeaponData["burstFireRate"];
            _weaponData.boltDelayTimer = defaultWeaponData["boltDelayTimer"];
            _weaponData.recoil = defaultWeaponData["recoil"];
            _weaponData.speedModifier = defaultWeaponData["speedModifier"];
            _weaponData.range = defaultWeaponData["range"];
            _weaponData.penetration = defaultWeaponData["penetration"];
            _weaponData.damage = defaultWeaponData.damage;
            _weaponData.radius = defaultWeaponData.radius;
            _weaponData.magSize = defaultWeaponData["magSize"];
            _weaponData.reloadTime = defaultWeaponData["reloadTime"];
            _weaponData.bExplosive = defaultWeaponData["bExplosive"];
            _weaponData.rocketType = defaultWeaponData["rocketType"];
            this.optimizeKeys(_weaponData);

            if (_weaponData.reloadMultiplier)
            {
                _weaponData.reloadMultiplier = 1;
            }
            if (_weaponData.type == Weapon.TYPE_SNIPER)
            {
                switch (mods[Mods.TYPE_OPTIC])
                {
                    case Mods.OPTIC_REFLEX:
                        _weaponData.lookModifier = 1.2;
                        break;
                    case Mods.OPTIC_EOTECH:
                        _weaponData.lookModifier = 1.35;
                        break;
                    case Mods.OPTIC_ACOG:
                        _weaponData.lookModifier = 1.5;
                        break;
                }
            }
            else
            {
                switch (mods[Mods.TYPE_OPTIC])
                {
                    case Mods.OPTIC_REFLEX:
                        _weaponData.lookModifier = defaultWeaponData.lookModifier + 0.025;
                        break;
                    case Mods.OPTIC_EOTECH:
                        _weaponData.lookModifier = defaultWeaponData.lookModifier + 0.05;
                        break;
                    case Mods.OPTIC_ACOG:
                        _weaponData.lookModifier = defaultWeaponData.lookModifier + 0.1;
                        break;
                }
            }

            switch (mods[Mods.TYPE_ACCESSORY])
            {
                case Mods.ACCESSORY_MAG_ASSIST:
                    _weaponData.reloadMultiplier = 0.5;
                    _weaponData.reloadTime = defaultWeaponData.reloadTime * 0.5;
                    break;
                case Mods.ACCESSORY_GRIP:
                    _weaponData.recoil = _weaponData.recoil * 0.5;
                    break;
                case Mods.ACCESSORY_LASER:
                    if (_weaponData.type == Weapon.TYPE_SHOTGUN)
                    {
                        _weaponData.accuracy = _weaponData.accuracy * 0.9;
                    }
                    else
                    {
                        _weaponData.accuracy = _weaponData.accuracy * 0.75;
                    }
                    break;
                case Mods.ACCESSORY_M203:
                case Mods.ACCESSORY_M320:
                case Mods.ACCESSORY_GP25:
                case Mods.ACCESSORY_MASTERKEY:
                    if (_weaponData.barrel && mods[Mods.TYPE_ACCESSORY] != _weaponData.barrel.id)
                    {
                        delete _weaponData.barrel;
                    }
                    if (!_weaponData.barrel)
                    {
                        _weaponData.barrel = this.getWeaponData(mods[Mods.TYPE_ACCESSORY]);
                    }
                    break;
            }

            switch (mods[Mods.TYPE_BARREL])
            {
                case Mods.BARREL_SILENCER:
                    _weaponData.recoil = _weaponData.recoil * 0.75;
                    _weaponData.dropRange = Math.round(_weaponData.dropRange * 0.75);
                    break;
                case Mods.BARREL_COMPENSATOR:
                    _weaponData.recoil = _weaponData.recoil * 0.5;
                    break;
                case Mods.BARREL_BRAKE:
                    _weaponData.recoil = _weaponData.recoil * 1.05;
                    _weaponData.damage = Math.round(_weaponData.damage * 1.1);
                    break;
                case Mods.BARREL_HEAVY:
                    _weaponData.dropRange = Math.round(_weaponData.dropRange * 1.25);
                    break;
            }

            switch (mods[Mods.TYPE_AMMO])
            {
                case Mods.AMMO_FMJ:
                    _weaponData.damage = Math.round(_weaponData.damage * 1.1);
                    break;
                case Mods.AMMO_PIERCING:
                    _weaponData.penetration = _weaponData.penetration + 1;
                    break;
                case Mods.AMMO_EXTENDED:
                    switch (_weaponData.id)
                    {
                        case "l115a3":
                        case "scout":
                        case "dsr1":
                        case "tac50":
                        case "m82":
                        case "intervention":
                        case "flamethrower":
                            _weaponData.magSize = Math.floor(defaultWeaponData.magSize * 2);
                            break;
                        default:
                            _weaponData.magSize = Math.floor(defaultWeaponData.magSize * 1.5);
                            break;
                    }
                    _weaponData.mag = _weaponData.magSize;
                    break;
                case Mods.AMMO_SLUG:
                    _weaponData.bSlug = true;
                    _weaponData.damage *= 5;
                    _weaponData.accuracy *= 0.25;
                    break;
                case Mods.AMMO_DRAGONS_BREATH:
                    _weaponData.bFlame = true;
                    _weaponData.damage *= 0.5;
                    _weaponData.fireDamage = _weaponData.damage;
                    _weaponData.fireTime = 1;
                    _weaponData.velocity = 1400;
                    break;
                case Mods.GRENADE_FIRE:
                    _weaponData.damage *= 0.5;
                    _weaponData.fireDamage = 10;
                    if (_weaponData.bRocket)
                    {
                        _weaponData.rocketType = Rocket.NAPALM;
                    }
                    break;
                case Mods.GRENADE_HE:
                    _weaponData.damage *= 0.75;
                    _weaponData.radius *= 1.5;
                    break;
                case Mods.GRENADE_FLASH:
                case Mods.GRENADE_STUN:
                case Mods.GRENADE_SMOKE:
                    _weaponData.damage *= 0.5;
                    break;
                case Mods.AMMO_EXPLOSIVE:
                    _weaponData.bExplosive = true;
                    _weaponData.penetration = 1;
                    _weaponData.recoil += 0.1;
                    break;
                case Mods.ARROW_EXPLOSIVE:
                    if (_weaponData.round == "arrow")
                    {
                        _weaponData.bExplosive = true;
                        _weaponData.penetration = 1;
                    }
                    break;
                case Mods.ARROW_POISON:
                    if (_weaponData.round == "arrow" || 1)
                    {
                        _weaponData.bPoison = true;
                        _weaponData.damage *= 0.5;
                        _weaponData.fireTime = 1;
                        _weaponData.fireDamage = 10;
                    }
                    break;
            }
        }
    }

    matchInProgress()
    {
        if (this.game && this.game.state == MatchState.STATE_IN_PROGRESS)
        {
            return true;
        }
        return false;
    }

    isPreGame()
    {
        if (this.game && this.game.state == MatchState.STATE_PRE_GAME)
        {
            return true;
        }
        return false;
    }

    matchHasEnded()
    {
        if (!this.game)
        {
            return true;
        }
        return this.game.state == MatchState.STATE_POST_GAME;
    }

    roundHasEnded()
    {
        if (!this.game)
        {
            return true;
        }
        return this.game.state == MatchState.STATE_POST_ROUND;
    }

    isTeamGameMode()
    {
        if (this.game.gameSettings.bTeam)
        {
            return true;
        }
        var data = this.getGameModeData(this.game.gameModeId);
        if (data)
        {
            return data.bTeam;
        }
        return false;
    }

    getGameModeData(_id)
    {
        var modes = this.data.modes;
        for (var i = 0; i < modes.length; i++)
        {
            var mode = modes[i];
            if (mode.id == _id)
            {
                return this.clone(mode);
            }
        }
        return null;
    }

    getSharedData(_id, _bClone)
    {
        var shared = this.data.shared;
        if (shared[_id])
        {
            return _bClone ? this.clone(shared[_id]) : shared[_id];
        }
        return null;
    }

    getVehicleData(_id)
    {
        var vehicles = this.data.vehicles;
        for (var i = 0; i < vehicles.length; i++)
        {
            var veh = vehicles[i];
            if (veh.id == _id)
            {
                return veh;
            }
        }
        return null;
    }

    getModData(_id)
    {
        var mods = this.data.mods;
        for (var i = 0; i < mods.length; i++)
        {
            var mod = mods[i];
            if (mod.id == _id)
            {
                return this.clone(mod);
            }
        }
        return null;
    }

    getModMoneyCost(_data)
    {
        if (_data)
        {
            if (_data.moneyCost)
            {
                return _data.moneyCost;
            }
            if (_data.score)
            {
                return Math.round(_data.score * 0.1);
            }
        }
        return 100;
    }

    getWeaponMoneyCost(_data)
    {
        if (_data)
        {
            var wpn = _data; //this.getWeaponData(_data.id);
            if (wpn.moneyCost)
            {
                return _data.moneyCost;
            }
            if (wpn.score)
            {
                var mult = 0.1;
                switch (_data.type)
                {
                    case Weapon.TYPE_LAUNCHER:
                        mult = 0.5;
                        break;
                    case Weapon.TYPE_LMG:
                    case Weapon.TYPE_DMR:
                    case Weapon.TYPE_SNIPER:
                        mult = 0.2;
                        break;
                    case Weapon.TYPE_PISTOL:
                    case Weapon.TYPE_MACHINE_PISTOL:
                        mult = 0.075;
                        break;
                    case Weapon.TYPE_MELEE:
                        mult = 0.05;
                        break;
                }
                return this.RoundToNearest(wpn.score * mult);
            }
        }
        return 100;
    }

    getRandomOpenWorldStructure()
    {
        if (this.data.openWorld)
        {
            var structures = this.data.openWorld.structures;
            for (var i = 0; i < 3; i++)
            {
                let structure = structures[this.Random(0, structures.length - 1)];
                if (structure.bDisabled)
                {
                    continue;
                }
                if (structure.chance != null && Math.random() > structure.chance)
                {
                    continue;
                }
                if (structure.uses != null)
                {
                    if (structure.uses > 0)
                    {
                        structure.uses--;
                    }
                    else
                    {
                        continue;
                    }
                }
                return structure;
            }
        }
        return null;
    }

    getOpenWorldStructure(_id)
    {
        if (this.data.openWorld)
        {
            var structures = this.data.openWorld.structures;
            for (var i = 0; i < structures.length; i++)
            {
                let cur = structures[i];
                if (cur && cur.id == _id)
                {
                    return this.clone(cur);
                }
            }
        }
        else
        {
            console.warn("Invalid openWorld reference");
        }
        return null;
    }

    createOpenWorldStructure(_position, _structure)
    {
        var objects = _structure.objects;
        if (objects)
        {
            for (var i = 0; i < objects.length; i++)
            {
                let cur = this.clone(objects[i]);
                if (cur)
                {
                    this.checkSpecialStringsInObject(cur);
                    if (!_structure.triggers || _structure.uses != 1)
                    {
                        delete cur.id;
                    }
                    cur.position[0] += _position[0];
                    cur.position[1] += _position[1];
                    if (cur.position[0] < this.getMapWidth() && cur.position[1] < this.getMapHeight())
                    {
                        let object = this.createObject(cur);
                    }
                }
            }
        }
        var tiles = _structure.tiles;
        if (tiles)
        {
            let tilePos = this.getTileCoordinatesAtPoint(_position);
            for (var i = 0; i < tiles.length; i++)
            {
                for (var j = 0; j < tiles[i].length; j++)
                {
                    let tileType = tiles[i][j];
                    try
                    {
                        //this.game.tiles[tilePos[0] + i][tilePos[1] + j] = tileType;
                    }
                    catch (e)
                    {
                        console.warn(e);
                    }
                }
            }
        }
    }

    getTileCoordinatesAtPoint(_position)
    {
        var tileSize = 256;
        var x = Math.floor(_position[0] / tileSize);
        var y = Math.floor(_position[1] / tileSize);
        return [x, y];
    }  

    getWeaponData(_id, _options)
    {
        var weapons = this.data.weapons;
        for (var i = 0; i < weapons.length; i++)
        {
            var wpn = weapons[i];
            if (wpn.id == _id)
            {
                var data = this.clone(wpn);
                if (_options)
                {
                    var keys = Object.keys(_options);
                    for (var j = 0; j < keys.length; j++)
                    {
                        if (_options[keys[j]] != null) data[keys[j]] = _options[keys[j]];
                    }
                }
                if (this.game.bSurvival && !data.bVehicle)
                {
                    switch (data.id)
                    {
                        case "smoke":
                        case "health_box":
                        case "ammo_box":
                            break;
                        default:
                            if (!data.bPassive && data.ammoMax && (data.bEquipment || data.type == Weapon.TYPE_GRENADE))
                            {
                                data.ammoMax = 4;
                            }
                            break;
                    }
                }
                delete data.desc;
                delete data.unlockLevel;
                delete data.unlockPrestige;
                delete data.headshotMultiplier;
                if (!data.reloadTime)
                {
                    data.reloadTime = 1;
                }
                if (data.range && !data.bDinosaur && !this.isMeleeWeapon(data) && !data.bFlame && data.id != "tazer" && !data.bEquipment)
                {
                    data.defaultRange = data.range;
                    switch (data.round)
                    {
                        case "arrow":
                            data.dropRange = data.range;
                            break;
                        default:
                            data.dropRange = data.range * 0.5;
                            break;
                    }
                    data.range = (data.type == Weapon.TYPE_SHOTGUN || data.bShotgun) ? 2000 : 4000;                    
                }
                var keys = Object.keys(data);
                var len = keys.length;
                for (var i = 0; i < len; i++)
                {
                    let key = keys[i];
                    let val = data[key];
                    if (typeof val === "boolean")
                    {
                        data[key] = val == true ? 1 : 0;
                        if (!val)
                        {
                            delete data[key];
                        }
                    }
                }
                return data;
            }
        }
        return null;
    }

    getRandomBotName()
    {
        var bots = this.data.bots;
        if (bots) 
        {
            return bots[this.Random(0, bots.length - 1)];
        }
        return "Bot";
    }

    getSpriteData(_id)
    {
        var sprites = this.data.sprites;
        if (sprites) 
        {
            return sprites[_id];
        }
        return null;
    }

    getWorldWeaponData(_id)
    {
        var weapons = this.data.weapons_world;
        if (weapons)
        {
            let data = weapons.frames[_id];
            if (data)
            {
                return data.frame;
            }
        }
        console.warn("Missing frame data for weapon:", _id);
        return { x: 0, y: 0, w: 32, h: 32 };
    }

    getMapData(_id)
    {
        var maps = this.data.maps;
        for (var i = 0; i < maps.length; i++)
        {
            let map = maps[i];
            if (map && map.id == _id)
            {
                return map;
            }
        }
        return null;
    }

    getItemData(_id)
    {
        var items = this.data.items;
        for (var i = 0; i < items.length; i++)
        {
            let item = items[i];
            if (item && item.id == _id)
            {
                return item;
            }
        }
        return null;
    }

    exitAllPawnsFromVehicle(_vehicle)
    {
        if (!_vehicle)
        {
            return;
        }
        var data = _vehicle.data;
        var seats = data.seats;
        if (seats)
        {
            for (var i = 0; i < seats.length; i++)
            {
                let seat = seats[i];
                if (seat.pawnId)
                {
                    let seatPawnId = seat.pawnId;
                    this.exitVehicle(this.getObjectById(seatPawnId));
                    this.clearPlayerControllable(seatPawnId);
                }
            }
        }
    }

    killAllPawnsInVehicle(_vehicle)
    {
        if (!_vehicle)
        {
            return;
        }
        var data = _vehicle.data;
        var seats = data.seats;
        if (seats)
        {
            for (var i = 0; i < seats.length; i++)
            {
                let seat = seats[i];
                if (seat.pawnId)
                {
                    this.killPawn(seat.pawnId);
                }
            }
        }
    }

    removeNextStep(_body)
    {
        if (_body)
        {
            var data = _body.data;
            if (data)
            {
                data.bPendingRemoval = true;
                if (this.isVehicle(_body))
                {
                    if (data.bKillOccupantsWhenDestroyed)
                    {
                        this.killAllPawnsInVehicle(_body);
                    }
                    else
                    {
                        this.exitAllPawnsFromVehicle(_body);
                    }
                }                
            }
            this.game.toRemove.push(_body);
            return true;
        }
        else
        {
            console.log("No body to remove");
        }
        return false;
    }

    setObjectPosition(_body, _position)
    {
        if (_body && this.isValidArray(_position))
        {
            _body.position[0] = _position[0];
            _body.position[1] = _position[1];
            this.onEvent({
                eventId: GameServer.EVENT_PAWN_ACTION,
                pawnId: _body.data.id,
                type: GameServer.PAWN_MOVE,
                position: _body.position
            });
            this.pushObjectUpdate(_body.data.id, ["position"]);
        }
    }

    getObjectById(_id)
    {
        if (!this.game || !_id)
        {
            return null;
        }
        var object = this.game.objects[_id];
        if (object && object.data && !object.data.bPendingRemoval)
        {
            return object;
        }
        return null;
    }

    getPawns(_team, _bIncludeUntargetable)
    {
        var arr = [];
        var pawns = this.getTypes([
            ObjectType.CHARACTER,
            ObjectType.DINOSAUR,
            ObjectType.DUMMY,
            ObjectType.HELICOPTER,
            ObjectType.TANK,
            ObjectType.CAR,
            ObjectType.MOUNTED_WEAPON,
            ObjectType.EGG
        ]);
        for (var i = 0; i < pawns.length; i ++)
        {
            let cur = pawns[i];
            if (cur.data && !cur.data.bPendingRemoval && (_bIncludeUntargetable ? true : !cur.data.bUntargetable))
            {
                if (_team == null || cur.data.team == _team)
                {
                    arr.push(cur);
                }
            }
        }
        return arr;
    }

    generateOpenWorldMap()
    {
        this.log("Generating open world map..."); 

        this.game.bGeneratingMap = true;

        //Initialize map
        var map = this.getCurrentMapData();
        map.spawns = null;

        var tileSize = 256;
        var w = this.game.gameSettings.mapSize ? this.game.gameSettings.mapSize : 32;
        var h = w;
        map.width = w * tileSize;
        map.height = h * tileSize;
        this.game.gameSettings.width = map.width;
        this.game.gameSettings.height = map.height;
        console.log(this.getMapWidth(), this.getMapHeight());

        //Create tiles
        var tiles = [];
        for (var i = 0; i < h; i++)
        {
            tiles[i] = [];
            for (var j = 0; j < w; j++)
            {
                tiles[i][j] = 0;
            }
        }        
        this.game.tiles = tiles;

        //Create structures    
        var grid = this.clone(tiles);
        var structures = [
            this.getOpenWorldStructure("spawnArea")
        ];
        var maxStructures = 20;
        for (var i = 0; i < maxStructures; i++)
        {
            let structure = this.getRandomOpenWorldStructure();
            if (structure)
            {
                if (!structure.width)
                {
                    structure.width = 10;
                    console.warn(structure.id);
                }
                if (!structure.height)
                {
                    structure.height = 10;
                    console.warn(structure.id);
                }
                structures.push(structure);
            }
        }
        this.ShuffleArray(structures);
        for (var i = 0; i < structures.length; i++)
        {
            let structure = structures[i];
            let pos = this.getOpenGridPosition(grid, structure.width, structure.height);
            if (pos)
            {
                switch (structure.id)
                {
                    case "spawnArea":
                        if (!map.teamSpawns[0])
                        {
                            map.teamSpawns[0] = {
                                x: pos[0] + 600,
                                y: pos[1] + 600,
                                w: 200,
                                h: 200
                            };
                        }
                        else if (!map.teamSpawns[1])
                        {
                            map.teamSpawns[1] = {
                                x: pos[0] + 600,
                                y: pos[1] + 600,
                                w: 200,
                                h: 200
                            }
                        }
                        break;
                }
                if (structure.triggers)
                {
                    console.log("Add", structure.triggers.length, "triggers for", structure.id);
                    this.game.triggers = this.game.triggers.concat(structure.triggers);
                }
                this.createOpenWorldStructure(pos, structure);
            }
        }
        console.log(this.game.triggers.length, "triggers");
        //Check for empty grid areas
        for (var i = 0; i < grid.length; i++)
        {
            for (var j = 0; j < grid[i].length; j++)
            {
                if (grid[i][j] == 0)
                {
                    if (this.Random(1, 3) == 1)
                    {
                        this.createTree({
                            position: [j * 256, i * 256],
                            angle: this.RandomAngle(),
                            treeType: this.getRandomTreeType()
                        });
                    }
                }
            }
        }
        /*
        var numStructures = 0;
        var threshold = 8;
        for (var i = 0; i < h; i++)
        {
            for (var j = 0; j < w; j++)
            {
                if (i % threshold == 0 && j % threshold == 0)
                {
                    let structure = this.getRandomOpenWorldStructure();
                    if (structure)
                    {
                        this.createOpenWorldStructure([j * tileSize, i * tileSize], structure);
                        numStructures++;
                        if (numStructures > maxStructures)
                        {
                            break;
                        }
                    }
                }
            }
        }
        */

        //Create edge trees
        var treeW = 1150;
        var numTreesH = Math.round(this.getMapWidth() / treeW);
        for (var i = 0; i < numTreesH; i++)
        {
            this.createTree({
                treeType: "tree_long2", position: [(treeW * 0.5) + (treeW * i), 0]
            });
        }
        for (var i = 0; i < numTreesH; i++)
        {
            this.createTree({
                treeType: "tree_long2", position: [(treeW * 0.5) + (treeW * i), this.getMapHeight()]
            });
        }
        var numTreesV = Math.round(this.getMapHeight() / treeW);
        for (var i = 0; i < numTreesV; i++)
        {
            this.createTree({
                treeType: "tree_long2", position: [0, (treeW * 0.5) + (treeW * i)], rotation: 90
            });
        }
        for (var i = 0; i < numTreesV; i++)
        {
            this.createTree({
                treeType: "tree_long2", position: [this.getMapWidth(), (treeW * 0.5) + (treeW * i)], rotation: 90
            });
        }         

        this.generateMapNodes();
        delete this.game.bGeneratingMap;        
    }

    onNodesGenerated()
    {
        switch (this.game.gameModeId)
        {
            case GameMode.OPEN_WORLD:
                this.spawnOpenWorldAirdrop();
                this.spawnOpenWorldMilitiaAirdrop();
                for (var i = 0; i < 6; i++)
                {
                    let pack = this.getDinoPackArray();
                    for (var j = 0; j < pack.length; j++)
                    {
                        let dino = this.createObject(pack[j]);
                    }
                }
                break;
        }
    }

    getOpenGridPosition(_grid, _w, _h)
    {
        for (var y = 0; y < _grid.length; y++)
        {
            for (var x = 0; x < _grid[y].length; x++)
            {
                try
                {
                    let cur = _grid[y][x];
                    let left = x > 0 ? _grid[y][x - 1] : 0;
                    let right = x < _grid[y].length ? _grid[y][x + _w] : 1;
                    let top = y > 0 ? _grid[y - 1][x] : 0;
                    let bottom = y < _grid.length ? _grid[y + _h][x] : 1;
                    if (cur == 0 && left == 0 && top == 0 && right == 0 && bottom == 0)
                    {
                        for (var i = 0; i < _h; i++)
                        {
                            for (var j = 0; j < _w; j++)
                            {
                                if (_grid[y + i][x + j] != null)
                                {
                                    _grid[y + i][x + j] = 1;
                                }
                            }
                        }
                        return [x * 256, y * 256];
                    }
                }
                catch (e)
                {
                    //console.warn(e);
                }
            }
        }
        return null;
    }

    handleOpenWorldEvent(_data)
    {
        console.log(_data.id, _data.chance);
        if (_data.chance != null)
        {
            if (Math.random() > _data.chance)
            {
                return;
            }
        }        
        switch (_data.id)
        {
            case "shopkeeper":
                if (!this.getStoreCrate())
                {
                    this.createHelicopter([this.RandomBoolean() ? 0 : this.getMapWidth(), this.RandomBoolean() ? 0 : this.getMapHeight()], {
                        vehicleId: Helicopter.MH6,
                        team: 0,
                        destination: this.getRandomSpawnPosition(),
                        items: [
                            {
                                type: ObjectType.CHARACTER,
                                avatar: this.getAvatarDataById(AvatarPresets.SHOPKEEPER),
                                team: 0,
                                inventory: [
                                    {
                                        id: this.getRandomWeaponByType(Weapon.TYPE_LMG),
                                        mods: {
                                            accessory: Mods.ACCESSORY_MAG_ASSIST
                                        }
                                    }
                                ],
                                damageMultipliers: {
                                    1: 0.25,
                                    2: 0.25,
                                    3: 0.25,
                                    4: 0.25
                                },
                                health: 500,
                                equipment: "kevlar",
                                bSwitchToMelee: false,
                                bUnlimitedAmmo: true,
                                bBot: true,
                                bInteract: false,
                                botSkill: BotSkill.SKILL_INSANE,
                                bCamp: true,
                                maxRange: 1000,
                                mass: 50,
                                pawnName: "Shopkeeper",
                                followTargetId: "shopCrate",
                                destroyTimer: 180
                            },
                            {
                                type: ObjectType.CRATE,
                                id: "shopCrate",
                                crateType: Crate.STORE,
                                destroyTimer: 60,
                                mass: 0,
                                bDisposable: false,
                                bDisableStoreSupportItems: true
                            }
                        ],
                        bAutomated: true,
                        bUntargetable: true,
                        departSpeedMult: 2,
                        itemTimerMax: 0.5
                    });
                }
                break;
            case "dinogenAirdrop":
                this.spawnOpenWorldAirdrop();
                break;
            case "militiaAirdrop":
                if (this.getCharactersOnTeam(1).length < 40)
                {
                    this.spawnOpenWorldMilitiaAirdrop();
                }
                break;
            case "dinoPackEgg":
                if (this.getDinosaurs().length < 50)
                {
                    this.spawnDinoPackEgg();
                }
                break;
        }
    }

    isOpenWorldNight()
    {
        return this.game.gameModeData.worldTime % 720 > 720;
    }

    getDinoPackArray(_dinoType)
    {
        let pos = this.getRandomSpawnPosition();
        let info = {
            chicken: {
                maxRange: this.Random(300, 500),
                wanderArea: this.Random(200, 500),
                bUntargetable: true
            },
            lizard: {
                maxRange: this.Random(300, 500),
                wanderArea: this.Random(500, 1000),
                bUntargetable: true
            },
            compy: {
                packSize: this.Random(5, 10),
            },
            ankylosaurus: {
                maxRange: this.Random(500, 1000)
            },
            stegosaurus: {
                maxRange: this.Random(500, 1000)
            },
            trex: {
                packSize: this.Random(1, 2),
                speedMult: this.Random(8, 10) * 0.1
            }
        }
        let dinoTeam = this.Random(10, 30);
        let dinoType = _dinoType ? _dinoType : this.getRandomOpenWorldDinosaur();
        let dinoColour = this.getRandomColour();        
        let bSavage = this.Random(1, this.isOpenWorldNight() ? 10 : 20) == 1;
        let dinos = [];
        let curInfo = info[dinoType];
        let speedMult = curInfo ? curInfo.speedMult : (this.Random(6, 10) * 0.1);
        let packSize = curInfo ? curInfo.packSize : this.Random(3, 6);
        for (var i = 0; i < packSize; i++)
        {
            let dinoData = {
                id: this.getRandomUniqueId(),
                type: ObjectType.DINOSAUR,
                dinoType: dinoType,
                position: [pos[0] + this.Random(-25, 25), pos[1] + this.Random(-25, 25)],
                rotation: 0,
                bRegenHealth: true,
                regenThreshold: 0.25,
                bCanInteract: false,
                bBot: true,
                botSkill: bSavage ? BotSkill.SKILL_INSANE : this.Random(BotSkill.SKILL_NORMAL, BotSkill.SKILL_INSANE),
                team: dinoTeam,
                colour: dinoColour + this.Random(-50, 50),
                objectScale: (i == 0 ? this.Random(10, 15) : this.Random(6, 10)) * 0.1,
                speedMultiplier: speedMult,
                bIgnoreOutOfSight: true,
                bInvestigate: true,
                bUntargetable: curInfo ? curInfo.bUntargetable : false,
                bSavage: bSavage,
                wanderArea: curInfo ? curInfo.wanderArea : this.Random(200, 400),
                maxRange: curInfo ? curInfo.maxRange : this.Random(1500, 2000)
            };
            dinoData.healthMultiplier = dinoData.objectScale * (this.Random(10, 15) * 0.1);
            if (dinoData.objectScale < 1)
            {
                dinoData.attackDamageMultiplier = dinoData.objectScale;
            }
            if (i == 0)
            {
                if (dinoData.objectScale >= 1.5)
                {
                    dinoData.pawnName = "Alpha";
                    dinoData.bRegenHealth = true;
                    dinoData.regenThreshold = 1;
                    dinoData.speedMultiplier += 0.1;
                    dinoData.botSkill = Math.max(BotSkill.SKILL_HARD, dinoData.botSkill);
                }
            }
            else
            {
                if (dinoData.objectScale <= 0.8)
                {
                    dinoData.followTargetId = dinos[0].id;
                }
            }
            dinos.push(dinoData);
        }
        return dinos;
    }

    spawnDinoPackEgg(_dinoType)
    {
        let pos = this.getRandomSpawnPosition();
        let dinos = this.getDinoPackArray();
        if (dinos.length)
        {
            var egg = this.createEgg(pos, {
                eggType: Egg.MASSIVE,
                team: dinos[0].team,
                items: dinos,
                tint: dinos[0].tint,
                hatchTimer: 5,
                bShowHatchTimer: true
            });
            return egg;
        }
        return null;
    }

    spawnOpenWorldMilitiaAirdrop()
    {
        var team = 1;
        var heliType = Helicopter.SEAKNIGHT;
        var numSoldiers = 5;
        var items = [];
        var rand = this.Random(1, 15);        
        switch (rand)
        {
            case 1:
                var cars = [Car.PICKUP, Car.PICKUP, Car.GROWLER, Car.GROWLER, Car.MRAP, Car.LAV25];
                var vehicleData = {
                    id: this.getRandomUniqueId(),
                    type: ObjectType.CAR,
                    vehicleId: cars[this.Random(0, cars.length - 1)],
                    tint: 0x666666,
                    team: team
                };
                items.push(vehicleData);
                break;
            case 2:
                heliType = Helicopter.OSPREY;
                numSoldiers = this.Random(1, 3);
                break;
        }
        for (var i = 0; i < numSoldiers; i++)
        {
            let char = this.getOpenWorldCharacterData(team);
            char.id = this.getRandomUniqueId();
            char.type = ObjectType.CHARACTER;
            char.team = team;
            char.bIgnoreOutOfSight = true;
            char.bUnlimitedAmmo = true;
            char.bRegenHealth = true;
            char.bInteract = true;
            char.maxRange = this.Random(1500, 2000);
            char.botSkill = this.Random(BotSkill.SKILL_HARD, BotSkill.SKILL_INSANE);
            char.wanderArea = this.Random(1000, 2000);
            let charItems = [];
            let numItems = this.Random(1, 3);
            for (let j = 0; j < numItems; j++)
            {
                charItems.push({
                    type: ObjectType.MONEY,
                    value: this.Random(10, 100),
                    bRandomVelocity: true
                });
            }
            if (charItems && charItems.length > 0)
            {
                char.items = charItems;
            }
            if (vehicleData)
            {
                char.objectiveItemId = vehicleData.id;
            }
            switch (rand)
            {
                case 2:
                    char.avatar = this.getAvatarDataById(AvatarPresets.JUGGERNAUT);
                    char.bJuggernaut = true;
                    char.speedMultiplier = 0.6;
                    char.health = 1000;
                    char.regenThreshold = 0.25;
                    char.damageMultipliers = {
                        1: 0.25,
                        2: 0.25,
                        3: 0.25,
                        4: 0.25
                    }
                    char.pawnName = "Juggernaut";
                    break;
                default:
                    if (i == 0)
                    {
                        char.pawnName = "Commander";
                        char.health = 400;
                    }
                    else if (!vehicleData)
                    {
                        char.followTargetId = items[0].id;
                    }
                    break;
            }            
            items.push(char);
        }
        var heli = this.createHelicopter([this.RandomBoolean() ? 0 : this.getMapWidth(), this.RandomBoolean() ? this.getMapHeight() : 0], {
            vehicleId: heliType,
            team: team,
            tint: team == 0 ? 0xFFFFFF : 0x666666,
            destination: this.getRandomSpawnPosition(),
            items: items,
            bDropItemsWhenDestroyed: false,
            bUntargetable: true,
            bAutomated: true,
            maxRange: 1000,
            speedMultiplier: 1,
            itemTimerMax: 0.5,
            departSpeedMult: 2
        });
        return heli;
    }

    spawnOpenWorldAirdrop()
    {
        var team = 0;
        var crates = [
            {
                type: ObjectType.CRATE,
                crateType: Crate.AMMO,
                bRandomVelocity: true
            },
            {
                type: ObjectType.CRATE,
                crateType: Crate.ITEM,
                itemId: this.getRandomItemId(),
                bRandomVelocity: true
            },
            {
                type: ObjectType.CRATE,
                crateType: Crate.WEAPON,
                bRandomVelocity: true,
                items: [
                    {
                        type: ObjectType.DROPPED_WEAPON,
                        weaponData: this.getRandomWeapon(),
                        bRandomVelocity: true
                    },
                    {
                        type: ObjectType.DROPPED_WEAPON,
                        weaponData: this.getRandomWeapon(),
                        bRandomVelocity: true
                    },
                    {
                        type: ObjectType.DROPPED_WEAPON,
                        weaponData: this.getRandomWeapon(),
                        bRandomVelocity: true
                    },
                    {
                        type: ObjectType.DROPPED_WEAPON,
                        weaponData: this.getRandomWeapon(),
                        bRandomVelocity: true
                    },
                    {
                        type: ObjectType.DROPPED_WEAPON,
                        weaponData: this.getRandomWeapon(),
                        bRandomVelocity: true
                    }
                ]
            }
        ];
        var items = [];
        var numCrates = this.Random(1, 3);
        for (var i = 0; i < numCrates; i++)
        {
            items.push(crates[this.Random(0, crates.length - 1)]);
        }
        var heli = this.createHelicopter([this.RandomBoolean() ? 0 : this.getMapWidth(), this.RandomBoolean() ? this.getMapHeight() : 0], {
            vehicleId: Helicopter.MH6,
            team: team,
            tint: team == 0 ? 0xFFFFFF : 0x666666,
            destination: this.getRandomSpawnPosition(),
            items: items,
            bDropItemsWhenDestroyed: true,
            bUntargetable: true,
            bAutomated: true,
            itemTimerMax: 0.5,
            departSpeedMult: 2
        });
        return heli;
    }

    getBotClasses()
    {
        try
        {
            var classes = this.getSharedData("classes", true);
            var types = [Weapon.TYPE_RIFLE, Weapon.TYPE_SMG, Weapon.TYPE_LMG, Weapon.TYPE_SNIPER];
            var keys = Object.keys(classes);
            for (var i = 0; i < keys.length; i++)
            {
                let key = keys[i];
                let curClass = classes[key];
                let primary = curClass.primary;
                let rand = this.Random(1, 5);
                switch (rand)
                {
                    case 1:
                        var wpnType = Weapon.TYPE_DMR;
                        break;
                    case 2:
                        wpnType = Weapon.TYPE_CARBINE;
                        break;
                    default:
                        wpnType = types[i];
                        break;
                }
                if (!wpnType)
                {
                    console.warn("Invalid weapon type", wpnType, i)
                    wpnType = Weapon.TYPE_CARBINE;
                }
                let wpns = this.getAllWeaponsByType(wpnType);
                primary.id = wpns[this.Random(0, wpns.length - 1)].id;
                if (!primary.id)
                {
                    console.warn("Invalid primary id", primary.id);
                    primary.id = "m4a1";
                }
                let primaryData = this.getWeaponData(primary.id);
                this.setRandomWeaponMods(primaryData);
                primary.mods = primaryData.mods;
                let secondary = curClass.secondary;
                switch (key)
                {
                    case Classes.ASSAULT:
                        var secondaryWpnTypes = [Weapon.TYPE_SHOTGUN];
                        break;
                    case Classes.COMMANDO:
                        secondaryWpnTypes = [Weapon.TYPE_LAUNCHER];
                        break;
                    default:
                        secondaryWpnTypes = [Weapon.TYPE_PISTOL, Weapon.TYPE_MACHINE_PISTOL];
                        break;
                }
                wpns = this.getAllWeaponsByType(secondaryWpnTypes[this.Random(0, secondaryWpnTypes.length - 1)]);
                switch (key)
                {
                    case Classes.SUPPORT:
                        wpns.push(this.getWeaponData("riot_shield"), this.getWeaponData("tazer"));
                        break;
                    case Classes.HUNTER:
                        wpns.push(this.getWeaponData("bow"), this.getWeaponData("crossbow"), this.getWeaponData("quadra"));
                        break;
                }
                secondary.id = wpns[this.Random(0, wpns.length - 1)].id;
                if (!secondary.id)
                {
                    console.warn("Invalid secondary id", secondary.id);
                    secondary.id = "m9";
                }
                let secondaryData = this.getWeaponData(secondary.id);
                this.setRandomWeaponMods(secondaryData);
                secondary.mods = secondaryData.mods;
                let grenades = this.getAllWeaponsByType(Weapon.TYPE_GRENADE);
                curClass.grenade = grenades[this.Random(0, grenades.length - 1)].id;
                curClass.melee = this.getRandomMelee().id;                
                if (this.Random(1, 4) == 1)
                {
                    var equipments = [curClass.equipment];
                    switch (key)
                    {
                        case Classes.ASSAULT:
                            equipments.push("juice", "knife", "kevlar");
                            break;
                        case Classes.COMMANDO:
                            equipments.push("c4", "betty", "blast_vest");
                            break;
                        case Classes.SUPPORT:
                            equipments.push("trophy", "health_box", "blowtorch");
                            break;
                        case Classes.HUNTER:
                            equipments.push("jammer", "dino_vest");
                            break;
                    }
                    curClass.equipment = equipments[this.Random(0, equipments.length - 1)];
                }
                curClass.avatar[Faction.DINOGEN].body = this.getRandomBody(Faction.DINOGEN);
                curClass.avatar[Faction.DINOGEN].head = this.RandomBoolean() ? Character.HEAD_NONE : Character.HEAD_US_HELMET;
                curClass.avatar[Faction.MILITIA].body = this.getRandomBody(Faction.MILITIA);
                curClass.avatar[Faction.MILITIA].head = this.RandomBoolean() ? Character.HEAD_NONE : Character.HEAD_OPFOR_HELMET;
                curClass.avatar[Faction.DINOGEN].facewear = this.Random(1, 3 == 1) ? Character.FACEWEAR_GAITER : Character.FACEWEAR_NONE;
                curClass.avatar[Faction.MILITIA].facewear = this.Random(1, 3 == 1) ? Character.FACEWEAR_GAITER : Character.FACEWEAR_NONE;
                curClass.avatar[Faction.DINOGEN].hair = this.getRandomHair();
                curClass.avatar[Faction.MILITIA].hair = this.getRandomHair();
                curClass.avatar[Faction.DINOGEN].hairColour = this.getRandomHairColour();
                curClass.avatar[Faction.MILITIA].hairColour = this.getRandomHairColour();
                curClass.avatar[Faction.DINOGEN].legs = this.getRandomLegs();
                curClass.avatar[Faction.MILITIA].legs = this.getRandomLegs();
            }
            classes.preferredFaction = this.game.bSurvival ? Faction.DINOGEN : (this.RandomBoolean() ? Faction.DINOGEN : Faction.MILITIA);
        }
        catch (e)
        {
            console.warn(e);
            classes = {
                "assault": {
                    "primary": {
                        "id": "m16a4",
                        "mods": {}
                    },
                    "secondary": {
                        "id": "m3",
                        "mods": {}
                    },
                    "grenade": "frag",
                    "equipment": "stim",
                    "melee": "melee_knife",
                    "avatar": {
                        "dinogen": {
                            "hair": "hair0000",
                            "hairColour": "HAIR_COLOUR_BROWN",
                            "body": "body0000",
                            "head": "head0000"
                        },
                        "militia": {
                            "hair": "hair0000",
                            "hairColour": "HAIR_COLOUR_BROWN",
                            "body": "body0001",
                            "head": "head0000"
                        }
                    }
                },
                "commando": {
                    "primary": {
                        "id": "mp5",
                        "mods": {}
                    },
                    "secondary": {
                        "id": "thumper",
                        "mods": {}
                    },
                    "grenade": "frag",
                    "equipment": "claymore",
                    "melee": "melee_knife",
                    "avatar": {
                        "dinogen": {
                            "hair": "hair0000",
                            "hairColour": "HAIR_COLOUR_BROWN",
                            "body": "body0000",
                            "head": "head0000"
                        },
                        "militia": {
                            "hair": "hair0000",
                            "hairColour": "HAIR_COLOUR_BROWN",
                            "body": "body0001",
                            "head": "head0000"
                        }
                    }
                },
                "support": {
                    "primary": {
                        "id": "mg4",
                        "mods": {}
                    },
                    "secondary": {
                        "id": "m9",
                        "mods": {}
                    },
                    "grenade": "smoke",
                    "equipment": "ammo_box",
                    "melee": "melee_knife",
                    "avatar": {
                        "dinogen": {
                            "hair": "hair0000",
                            "hairColour": "HAIR_COLOUR_BROWN",
                            "body": "body0000",
                            "head": "head0000"
                        },
                        "militia": {
                            "hair": "hair0000",
                            "hairColour": "HAIR_COLOUR_BROWN",
                            "body": "body0001",
                            "head": "head0000"
                        }
                    }
                },
                "hunter": {
                    "primary": {
                        "id": "m40a3",
                        "mods": { "optic": "scope" }
                    },
                    "secondary": {
                        "id": "m9",
                        "mods": {}
                    },
                    "grenade": "smoke",
                    "equipment": "sensor",
                    "melee": "melee_knife",
                    "avatar": {
                        "dinogen": {
                            "hair": "hair0000",
                            "hairColour": "HAIR_COLOUR_BROWN",
                            "body": "body0000",
                            "head": "head0000"
                        },
                        "militia": {
                            "hair": "hair0000",
                            "hairColour": "HAIR_COLOUR_BROWN",
                            "body": "body0001",
                            "head": "head0000"
                        }
                    }
                }
            }
        }
        return classes;
    }

    getAvatarDataById(_id)
    {
        switch (_id)
        {
            case AvatarPresets.BIGFOOT:
                return {
                    body: Character.BODY_SHIRTLESS,
                    head: Character.HEAD_US_GHILLIE,
                    hair: Character.HAIR_DREADS,
                    legs: Character.LEGS_BAREFOOT,
                    hairColour: this.getRandomHairColour(),
                    beard: Character.BEARD_FULL
                };
            case AvatarPresets.ZOMBIE:
                var faces = [
                    Character.FACE_ZOMBIE_1,
                    Character.FACE_ZOMBIE_2,
                    Character.FACE_ZOMBIE_3,
                    Character.FACE_ZOMBIE_4,
                    Character.FACE_ZOMBIE_SPRINTER
                ];
                var bodies = [
                    Character.BODY_ZOMBIE,
                    Character.BODY_ZOMBIE_2,
                    Character.BODY_ZOMBIE_3
                ];
                return {
                    body: bodies[this.Random(0, bodies.length - 1)],
                    hair: Character.HAIR_BALD,
                    face: faces[this.Random(0, faces.length - 1)],
                    legs: Character.LEGS_BAREFOOT
                };
            case AvatarPresets.ZOMBIE_JUGGERNAUT:
                var faces = [
                    Character.FACE_ZOMBIE_1,
                    Character.FACE_ZOMBIE_2,
                    Character.FACE_ZOMBIE_3,
                    Character.FACE_ZOMBIE_4,
                    Character.FACE_ZOMBIE_SPRINTER
                ];
                return {
                    body: Character.BODY_JUGGERNAUT,
                    hair: Character.HAIR_BALD,
                    face: faces[this.Random(0, faces.length - 1)],
                    legs: Character.LEGS_JUGGERNAUT
                };
            case AvatarPresets.PETERSON:
                return {
                    body: Character.BODY_DINOGEN,
                    eyewear: Character.EYEWEAR_GLASSES,
                    hair: Character.HAIR_HORSESHOE,
                    beard: Character.BEARD_MOUSTACHE,
                    hairColour: Character.HAIR_COLOUR_WHITE
                };
            case AvatarPresets.BROCK:
                return {
                    body: Character.BODY_DINOGEN_RIG,
                    hair: Character.HAIR_STYLED,
                    beard: Character.BEARD_GOATEE,
                    hairColour: Character.HAIR_COLOUR_BROWN
                };
            case AvatarPresets.LIAM:
                return {
                    body: Character.BODY_DINOGEN_HEAVY,
                    eyewear: Character.EYEWEAR_GLASSES,
                    hair: Character.HAIR_SHORT,
                    beard: Character.BEARD_FULL,
                    hairColour: Character.HAIR_COLOUR_BLACK
                };
            case AvatarPresets.SHOPKEEPER:
                return {
                    body: Character.BODY_DINOGEN_RIG,
                    head: Character.HEAD_ALTYN_HELMET_VISOR_UP,
                    hair: Character.HAIR_BUZZED,
                    beard: Character.BEARD_FULL,
                    eyewear: Character.EYEWEAR_GOGGLES_BLACK,
                    hairColour: Character.HAIR_COLOUR_BLACK
                };
            case AvatarPresets.JUGGERNAUT:
                return {
                    body: Character.BODY_JUGGERNAUT,
                    head: Character.HEAD_JUGGERNAUT_HELMET,
                    facewear: Character.FACEWEAR_MASK,
                    legs: Character.LEGS_JUGGERNAUT
                };
            case AvatarPresets.COMMANDER:
                return {
                    body: Character.BODY_JUGGERNAUT,
                    head: Character.HEAD_OPFOR_COMMANDER,
                    facewear: Character.FACEWEAR_NONE,
                    legs: Character.LEGS_JUGGERNAUT
                };
            case AvatarPresets.SHIRTLESS:
                return {
                    body: Character.BODY_SHIRTLESS
                };
            case AvatarPresets.MILITIA:
                return {
                    body: Character.BODY_MILITIA,
                    head: Character.HEAD_OPFOR_HELMET
                };
            case AvatarPresets.DINOGEN_RANDOM:
                var bodies = [
                    Character.BODY_DINOGEN,
                    Character.BODY_DINOGEN_RIG
                ];
                var heads = [
                    null,
                    Character.HEAD_US_HELMET_TACTICAL
                ];
                var legs = [
                    Character.LEGS_SHORTS,
                    Character.LEGS_BOOTS
                ];
                return {
                    body: bodies[this.Random(0, bodies.length - 1)],
                    head: heads[this.Random(0, heads.length - 1)],
                    hair: this.getRandomHair(),
                    hairColour: this.getRandomHairColour(),
                    legs: legs[this.Random(0, legs.length - 1)]
                };
            case AvatarPresets.DINOGEN_HEAVY:
                return {
                    body: Character.BODY_DINOGEN_HEAVY,
                    head: Character.HEAD_US_HELMET_TACTICAL
                };
            case AvatarPresets.DINOGEN:
            default:
                return {
                    body: Character.BODY_DINOGEN,
                    head: Character.HEAD_US_HELMET
                };
        }
    }

    getRandomBody(_faction)
    {
        switch (_faction)
        {            
            case Faction.MILITIA:
                var bodies = [
                    Character.BODY_MILITIA,
                    Character.BODY_MILITIA_RIG,
                    Character.BODY_MILITIA_HEAVY
                ];
                break;
            case Faction.DINOGEN:
            default:
                bodies = [
                    Character.BODY_DINOGEN,
                    Character.BODY_DINOGEN_RIG,
                    Character.BODY_DINOGEN_HEAVY
                ];
                break;
        }        
        return bodies[this.Random(0, bodies.length - 1)];
    }

    getRandomHairColour()
    {
        var colours = [
            Character.HAIR_COLOUR_BROWN,
            Character.HAIR_COLOUR_BROWN_LIGHT,
            Character.HAIR_COLOUR_BLACK,
            Character.HAIR_COLOUR_BLONDE,
            Character.HAIR_COLOUR_GINGER
        ];
        return colours[this.Random(0, colours.length - 1)];
    }

    getRandomHair()
    {
        var hairs = [
            Character.HAIR_BALD,
            Character.HAIR_SHORT,
            Character.HAIR_LONG,
            Character.HAIR_DREADS,
            Character.HAIR_PONYTAIL,
            Character.HAIR_STYLED,
            Character.HAIR_UNDERCUT,
            Character.HAIR_HORSESHOE
        ];
        return hairs[this.Random(0, hairs.length - 1)];
    }

    getRandomLegs()
    {
        var legs = [
            Character.LEGS_BOOTS,
            Character.LEGS_SHORTS
        ];
        return legs[this.Random(0, legs.length - 1)];
    }

    setRandomWeaponMods(_weaponData)
    {
        if (_weaponData.bEquipment || _weaponData.bVehicle || this.isMeleeWeapon(_weaponData))
        {
            return;
        }
        switch (_weaponData.id)
        {
            case "riot_shield":
            case "flamethrower":
            case "bow":
            case "quadra":
            case "crossbow":
                return;
        }
        if (!_weaponData.mods)
        {
            _weaponData.mods = {};
        }
        var mods = this.getModsForWeapon(_weaponData.id, Mods.TYPE_OPTIC);
        _weaponData.mods.optic = mods[this.Random(0, mods.length - 1)];
        mods = this.getModsForWeapon(_weaponData.id, Mods.TYPE_ACCESSORY);
        _weaponData.mods.accessory = mods[this.Random(0, mods.length - 1)];
        mods = this.getModsForWeapon(_weaponData.id, Mods.TYPE_BARREL);
        _weaponData.mods.barrel = mods[this.Random(0, mods.length - 1)];
        mods = this.getModsForWeapon(_weaponData.id, Mods.TYPE_AMMO);
        _weaponData.mods.ammo = mods[this.Random(0, mods.length - 1)];
        this.applyWeaponMods(_weaponData, _weaponData.mods);
    }

    getAllModsForWeapon(_weaponId)
    {
        var res = {};
        var mods = this.getModsForWeapon(_weaponId, Mods.TYPE_OPTIC);
        res.optic = mods[this.Random(0, mods.length - 1)];
        mods = this.getModsForWeapon(_weaponId, Mods.TYPE_ACCESSORY);
        res.accessory = mods[this.Random(0, mods.length - 1)];
        mods = this.getModsForWeapon(_weaponId, Mods.TYPE_BARREL);
        res.barrel = mods[this.Random(0, mods.length - 1)];
        mods = this.getModsForWeapon(_weaponId, Mods.TYPE_AMMO);
        res.ammo = mods[this.Random(0, mods.length - 1)];
        return res;
    }

    getModsForWeapon(_weaponId, _modType)
    {
        var mods = [null];
        var wpn = this.getWeaponData(_weaponId);
        if (wpn && !this.isMeleeWeapon(wpn))
        {
            if (wpn.bVehicle)
            {
                return mods;
            }
            if (wpn.id == "bow" || wpn.id == "quadra")
            {
                return mods;
            }
            switch (_modType)
            {
                case Mods.TYPE_OPTIC:
                    switch (wpn.id)
                    {
                        case "deagle":
                        case "m82":
                        case "tac50":
                            return mods;
                    }
                    switch (wpn.type)
                    {
                        case Weapon.TYPE_PISTOL:
                        case Weapon.TYPE_MACHINE_PISTOL:
                        case Weapon.TYPE_SHOTGUN:
                            mods.push(Mods.OPTIC_REFLEX, Mods.OPTIC_EOTECH);
                            break;
                        case Weapon.TYPE_LAUNCHER:
                            return mods;
                        case Weapon.TYPE_SNIPER:
                            mods = [Mods.OPTIC_SCOPE];
                            if (this.RandomBoolean())
                            {
                                mods.push(Mods.OPTIC_REFLEX, Mods.OPTIC_EOTECH, Mods.OPTIC_ACOG);
                            }
                            break;
                        case Weapon.TYPE_DMR:
                            mods = [Mods.OPTIC_SCOPE_DMR, Mods.OPTIC_REFLEX, Mods.OPTIC_EOTECH, Mods.OPTIC_ACOG];
                            break;
                        default:
                            mods.push(Mods.OPTIC_REFLEX, Mods.OPTIC_EOTECH, Mods.OPTIC_ACOG);
                            break;
                    }
                    break;
                case Mods.TYPE_ACCESSORY:
                    switch (wpn.type)
                    {
                        case Weapon.TYPE_PISTOL:
                        case Weapon.TYPE_MACHINE_PISTOL:
                        case Weapon.TYPE_SHOTGUN:
                            mods.push(Mods.ACCESSORY_LASER);
                            break;
                        default:
                            mods.push(Mods.ACCESSORY_LASER, Mods.ACCESSORY_GRIP, Mods.ACCESSORY_GRIP_ANGLED);
                            if (wpn.type == Weapon.TYPE_RIFLE)
                            {
                                //mods.push(wpn.id == "ak47" ? Mods.ACCESSORY_GP25 : Mods.ACCESSORY_M320);
                            }
                            break;
                    }
                    if (!wpn.bGrenade && !wpn.bRocket && !wpn.bSingleRoundLoaded && wpn.magSize > 1)
                    {
                        mods.push(Mods.ACCESSORY_MAG_ASSIST);
                    }
                    break;
                case Mods.TYPE_BARREL:
                    if (wpn.id == "m82" || wpn.id == "tac50" || wpn.id == "pgm")
                    {
                        mods.push(Mods.BARREL_COMPENSATOR, Mods.BARREL_BRAKE, Mods.BARREL_HEAVY);
                    }
                    else
                    {
                        switch (wpn.type)
                        {
                            case Weapon.TYPE_LAUNCHER:
                            case Weapon.TYPE_SHOTGUN:
                                break;
                            case Weapon.TYPE_DMR:
                            case Weapon.TYPE_SNIPER:
                            case Weapon.TYPE_RIFLE:
                            case Weapon.TYPE_CARBINE:
                            case Weapon.TYPE_SMG:
                                if (!wpn.bSilenced && !wpn.bRevolver)
                                {
                                    mods.push(Mods.BARREL_COMPENSATOR, Mods.BARREL_BRAKE, Mods.BARREL_HEAVY);
                                    if (this.Random(1, 3) > 1)
                                    {
                                        mods.push(Mods.BARREL_SILENCER);
                                    }
                                }
                                else
                                {
                                    mods.push(Mods.BARREL_COMPENSATOR, Mods.BARREL_BRAKE, Mods.BARREL_HEAVY);
                                }
                                break;
                            case Weapon.TYPE_WEAPON_TACTICAL:
                                return mods;
                            default:
                                mods.push(Mods.BARREL_COMPENSATOR, Mods.BARREL_BRAKE, Mods.BARREL_HEAVY);
                                break;
                        }
                    }
                    break;
                case Mods.TYPE_AMMO:
                    switch (wpn.type)
                    {
                        case Weapon.TYPE_LAUNCHER:
                            if (wpn.bGrenade && wpn.magSize == 1)
                            {
                                mods.push(null, Mods.GRENADE_STUN, Mods.GRENADE_FLASH, Mods.GRENADE_FIRE, Mods.GRENADE_HE);
                            }
                            break;
                        case Weapon.TYPE_WEAPON_TACTICAL:
                            return mods;
                        default:
                            mods.push(Mods.AMMO_FMJ, Mods.AMMO_PIERCING, Mods.AMMO_HOLLOW_POINT, Mods.AMMO_EXTENDED);
                            if (wpn.type == Weapon.TYPE_SHOTGUN)
                            {
                                if (wpn.bBoltAction)
                                {
                                    mods.push(Mods.AMMO_SLUG);
                                }
                                mods.push(Mods.AMMO_DRAGONS_BREATH);
                            }
                            break;
                    }
                    break;
            }
        }
        return mods;
    }

    getAllWeaponsByType(_type)
    {
        var arr = [];
        for (var i = 0; i < this.data.weapons.length; i++)
        {
            let wpn = this.data.weapons[i];
            if (wpn.bHidden || wpn.bVehicle || wpn.bDinosaur)
            {
                continue;
            }
            if (wpn.type == _type)
            {
                arr.push(wpn);
            }
        }
        return arr;
    }

    getAllWeapons()
    {
        var arr = [];
        for (var i = 0; i < this.data.weapons.length; i++)
        {
            let wpn = this.data.weapons[i];
            if (wpn.bHidden || wpn.bVehicle || wpn.bDinosaur || wpn.bZombie)
            {
                continue;
            }
            arr.push(wpn);
        }
        return arr;
    }

    getAllFirearms()
    {
        var arr = [];
        for (var i = 0; i < this.data.weapons.length; i++)
        {
            let wpn = this.data.weapons[i];
            if (wpn.bHidden || wpn.bVehicle || wpn.bDinosaur || wpn.bZombie || wpn.bEquipment || this.isMeleeWeapon(wpn))
            {
                continue;
            }
            arr.push(wpn);
        }
        return arr;
    }

    getAllEquipment()
    {
        var arr = [];
        for (var i = 0; i < this.data.weapons.length; i++)
        {
            let wpn = this.data.weapons[i];
            if (wpn.bHidden || wpn.bVehicle || wpn.bDinosaur || wpn.bZombie || !wpn.bEquipment || this.isMeleeWeapon(wpn) || wpn.type == Weapon.TYPE_GRENADE)
            {
                continue;
            }
            arr.push(wpn);
        }
        return arr;
    }

    getAllGrenades()
    {
        var arr = [];
        for (var i = 0; i < this.data.weapons.length; i++)
        {
            let wpn = this.data.weapons[i];
            if (wpn.bHidden || wpn.bVehicle || wpn.bDinosaur || wpn.bZombie || this.isMeleeWeapon(wpn) || wpn.type != Weapon.TYPE_GRENADE)
            {
                continue;
            }
            arr.push(wpn);
        }
        return arr;
    }

    getAllMelees()
    {
        var arr = [];
        for (var i = 0; i < this.data.weapons.length; i++)
        {
            let wpn = this.data.weapons[i];
            if (wpn.bHidden || wpn.bVehicle || wpn.bDinosaur || wpn.bZombie || wpn.bEquipment || !this.isMeleeWeapon(wpn) || wpn.type != Weapon.TYPE_MELEE)
            {
                continue;
            }
            arr.push(wpn);
        }
        return arr;
    }

    getRandomWeapon()
    {
        var wpns = this.getAllWeapons();
        var weapon = this.clone(wpns[this.Random(0, wpns.length - 1)]);
        this.setRandomWeaponMods(weapon);
        return weapon;
    }

    getRandomWeaponByType(_type)
    {
        var wpns = this.getAllWeaponsByType(_type);
        var weapon = this.clone(wpns[this.Random(0, wpns.length - 1)]);
        this.setRandomWeaponMods(weapon);
        return weapon;
    }

    getRandomHeavyWeapon()
    {
        var wpns = this.getAllWeaponsByType(Weapon.TYPE_LMG).concat(this.getAllWeaponsByType(Weapon.TYPE_LAUNCHER));
        var ids = [
            "railgun",
            "minigun",
            "flamethrower",
            "m82",
            "tac50",
            "quadra"
        ];
        for (var i = 0; i < ids.length; i++)
        {
            wpns.push(this.getWeaponData(ids[i]));
        }
        var weapon = this.clone(wpns[this.Random(0, wpns.length - 1)]);
        this.setRandomWeaponMods(weapon);
        return weapon;
    }

    getRandomFirearm()
    {
        var wpns = this.getAllFirearms();
        var weapon = this.clone(wpns[this.Random(0, wpns.length - 1)]);
        this.setRandomWeaponMods(weapon);
        return weapon;
    }

    getRandomEquipment()
    {
        var wpns = this.getAllEquipment();
        return this.clone(wpns[this.Random(0, wpns.length - 1)]);
    }

    getRandomGrenade()
    {
        var wpns = this.getAllGrenades();
        return this.clone(wpns[this.Random(0, wpns.length - 1)]);
    }

    getRandomMelee()
    {
        var wpns = this.getAllMelees();
        return this.clone(wpns[this.Random(0, wpns.length - 1)]);
    }

    getRandomUniqueId()
    {
        for (var i = 0; i < 100; i++)
        {
            var id = Math.random().toString(36).substr(2, 3);
            if (!this.getObjectById(id))
            {
                return id;
            }
        }
        return id;
    }

    pxmi(v)
    {
        return v;
    }

    loadPolygon(_id, _body, _width, _height, _scale, _shapeData)
    {
        var data = this.getSpriteData(_id);
        if (!data)
        {
            console.log("No sprite data for", _id);
            return;
        }
        var p2 = this.p2;
        var scale = 1;
        var cm = p2.vec2.create();
        for (var i = 0; i < data.length; i++)
        {
            var vertices = [];
            for (var s = 0; s < data[i].shape.length; s += 2)
            {
                vertices.push([
                    this.pxmi(data[i].shape[s] * scale),
                    this.pxmi(data[i].shape[s + 1] * scale)
                ]);
            }
            var c = new this.p2.Convex({ vertices: vertices });
            c.material = _shapeData.material;
            c.collisionGroup = _shapeData.collisionGroup;
            c.collisionMask = _shapeData.collisionMask;
            for (var j = 0; j !== c.vertices.length; j++)
            {
                var v = c.vertices[j];
                p2.vec2.sub(v, v, c.centerOfMass);
            }
            p2.vec2.scale(cm, c.centerOfMass, 1);
            cm[0] -= this.pxmi(_width / 2);
            cm[1] -= this.pxmi(_height / 2);
            c.updateTriangles();
            c.updateCenterOfMass();
            c.updateBoundingRadius();
            _body.addShape(c, cm);
        }
        _body.aabbNeedsUpdate = true;
        return true;
    }

    getTotalVelocity(_body)
    {
        if (_body)
        {
            var vx = _body.velocity[0];
            var vy = _body.velocity[1];
            return vx * vx + vy * vy;
        }
        return 0;
    }

    constrainVelocity(_body, _val)
    {
        var angle, currVelocitySqr, vx, vy;
        vx = _body.velocity[0];
        vy = _body.velocity[1];
        currVelocitySqr = vx * vx + vy * vy;
        if (currVelocitySqr > _val * _val)
        {
            angle = Math.atan2(vy, vx);
            vx = Math.cos(angle) * _val;
            vy = Math.sin(angle) * _val;
            _body.velocity[0] = vx;
            _body.velocity[1] = vy;
        }
    }

    optimize(_data)
    {
        var keys = Object.keys(_data);
        for (var i = 0; i < keys.length; i++)
        {
            var key = keys[i];
            var val = _data[key];
            if (typeof val === "boolean")
            {
                _data[key] = val == true ? 1 : 0;
            }
            else if (typeof val === "number" && val % 1 != 0)
            {
                _data[key] = this.RoundDecimal(val);
            }
        }
    }

    clone(_data)
    {
        if (!_data)
        {
            return null;
        }
        return JSON.parse(JSON.stringify(_data));
    }

    Random(_min, _max)
    {
        return Math.floor(Math.random() * (_max - _min + 1)) + _min;
    }

    RandomAngle()
    {
        return this.ToRad(this.Random(0, 360));
    }

    RandomBoolean()
    {
        return Math.random() >= 0.5;
    }

    DistBodies(_bodyA, _bodyB)
    {
        return this.Dist(_bodyA.position[0], _bodyA.position[1], _bodyB.position[0], _bodyB.position[1]);
    }

    DistPositions(_posA, _posB)
    {
        return this.Dist(_posA[0], _posA[1], _posB[0], _posB[1]);
    }

    Dist(_x1, _y1, _x2, _y2)
    {
        return Math.sqrt((_x1 - _x2) * (_x1 - _x2) + (_y1 - _y2) * (_y1 - _y2));
    }

    Angle(_x1, _y1, _x2, _y2)
    {
        var distX = _x2 - _x1;
        var distY = _y2 - _y1;
        return this.RoundDecimal(Math.atan2(distY, distX));
    }

    ToRad(_degrees)
    {
        return this.RoundDecimal(_degrees * (Math.PI / 180));
    }

    ToDeg(_radians)
    {
        return _radians * (180 / Math.PI);
    }

    WrapAngle(angle, radians)
    {
        return this.RoundDecimalFine(radians ? this.Wrap(angle, -Math.PI, Math.PI) : this.Wrap(angle, -180, 180));
    }

    Wrap(value, min, max)
    {
        var range = max - min;
        if (range <= 0)
        {
            return 0;
        }
        var result = (value - min) % range;
        if (result < 0)
        {
            result += range;
        }
        return result + min;
    }

    CheckValidArray(_arr)
    {
        if (!_arr || isNaN(_arr[0]) || isNaN(_arr[1]))
        {
            return false;
        }
        return true;
    }

    RoundNumberArray(_arr)
    {
        if (_arr)
        {
            return [Math.round(_arr[0]), Math.round(_arr[1])];
        }
        return _arr;
    }

    RoundToNearest(_val)
    {
        return Math.ceil(_val / 5) * 5;
    }

    optimizeKeys(_data)
    {
        if (_data)
        {
            var num = 0;
            var keys = Object.keys(_data);
            for (var i = keys.length - 1; i >= 0; i--)
            {
                let key = keys[i];
                let val = _data[key];
                if (val === undefined)
                {
                    delete _data[key];
                    num++;
                }
                else if (typeof val === "boolean")
                {
                    _data[key] = _data[key] == true ? 1 : 0;
                    num++;
                }
            }
            return num;
        }
        return 0;
    }

    RoundDecimal(_val)
    {
        return Math.trunc(_val * 100) / 100;
    }

    RoundDecimalFine(_val)
    {
        return Math.trunc(_val * 10000) / 10000;
    }

    ShuffleArray(array)
    {
        var currentIndex = array.length, temporaryValue, randomIndex;
        while (0 !== currentIndex)
        {
            randomIndex = Math.floor(Math.random() * currentIndex);
            currentIndex -= 1;
            temporaryValue = array[currentIndex];
            array[currentIndex] = array[randomIndex];
            array[randomIndex] = temporaryValue;
        }
        return array;
    }

}
if (typeof module !== "undefined")
{
    module.exports = {
        GameInstance: GameInstance
    };
}